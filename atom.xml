<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>it❤ld</title>
  
  
  <link href="http://www.itbuild.cn/atom.xml" rel="self"/>
  
  <link href="http://www.itbuild.cn/"/>
  <updated>2020-12-19T12:49:18.156Z</updated>
  <id>http://www.itbuild.cn/</id>
  
  <author>
    <name>DuanChaojie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-设计模式/9.设计模式-桥接模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.142Z</published>
    <updated>2020-12-19T12:49:18.156Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>江头未是风波恶，别有人间行路难！</p><p align="right">——辛弃疾《鹧鸪天》</p><a id="more"></a>## 设计模式-桥接模式<h4 id="1-案例引出桥接模式"><a href="#1-案例引出桥接模式" class="headerlink" title="1. 案例引出桥接模式"></a>1. 案例引出桥接模式</h4><blockquote><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)；</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/PhoneANli.jpg" alt="PhoneANli"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/umlleitu-1592747308439.jpg" alt="umlleitu"></p><p><code>传统方案解决手机操作问题分析</code></p><ol><li><code>扩展性问题( 类爆炸)</code>，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li><li>违反了<a href="https://blog.csdn.net/weixin_45267102/article/details/106630885" target="_blank" rel="noopener">单一职责原则</a>，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本</li><li>解决方案–就是设计模式中的<code>桥接模式</code>。</li></ol></blockquote><h4 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2. 桥接模式"></a>2. 桥接模式</h4><h5 id="2-1-桥接模式基本介绍"><a href="#2-1-桥接模式基本介绍" class="headerlink" title="2.1 桥接模式基本介绍"></a>2.1 桥接模式基本介绍</h5><blockquote><ol><li><code>桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</code></li><li>是一种<code>结构型设计模式。</code></li><li>Bridge 模式基于<code>类的最小设计原则</code>，<a href="https://blog.csdn.net/weixin_45267102/article/details/106618210" target="_blank" rel="noopener">通过使用封装、聚合及继承等行为</a>让不同的类承担不同的职责。<code>它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。</code></li></ol></blockquote><h5 id="2-2-桥接模式原理类图"><a href="#2-2-桥接模式原理类图" class="headerlink" title="2.2 桥接模式原理类图"></a>2.2 桥接模式原理类图</h5><blockquote><ol><li><code>Client 类：</code>桥接模式的调用者</li><li><code>抽象类(Abstraction) :</code>充当桥接类</li><li><code>RefinedAbstraction类 : 是</code> Abstraction 抽象类的子类</li><li><code>Implementor接口</code> : 行为实现类的接口</li><li><code>ConcreteImplementorA/B类</code> ：行为的具体实现类</li><li><code>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</code>，重点是抽象类Abstraction，其维护了 Implementor接口 <code>（即它的实现类 ConcreteImplementorA/B）</code>, <strong>抽象类Abstraction与接口Implementor是聚合关系。</strong></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200508211712743xx.png" alt="20200508211712743xx"></p><h5 id="2-3-桥接模式解决手机操作问题"><a href="#2-3-桥接模式解决手机操作问题" class="headerlink" title="2.3 桥接模式解决手机操作问题"></a>2.3 桥接模式解决手机操作问题</h5><p>使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护。</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/qjmsumlleitu.jpg" alt="qjmsumlleitu"></p><h5 id="2-4-代码实现之"><a href="#2-4-代码实现之" class="headerlink" title="2.4 代码实现之"></a>2.4 代码实现之</h5><h6 id="抽象类Phone及其子类"><a href="#抽象类Phone及其子类" class="headerlink" title="抽象类Phone及其子类"></a>抽象类Phone及其子类</h6><blockquote><p><code>注意Phone抽象类是怎么与Brand接口进行关联的。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合品牌</span></span><br><span class="line"><span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.brand.open();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">brand.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">brand.call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直立样式手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpRightPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UpRightPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(brand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open();</span><br><span class="line">System.out.println(<span class="string">" 直立样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.close();</span><br><span class="line">System.out.println(<span class="string">" 直立样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.call();</span><br><span class="line">System.out.println(<span class="string">" 直立样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(brand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open();</span><br><span class="line">System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.close();</span><br><span class="line">System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.call();</span><br><span class="line">System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="接口Brand及其子类"><a href="#接口Brand及其子类" class="headerlink" title="接口Brand及其子类"></a>接口Brand及其子类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vivo类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" Vivo手机开机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" Vivo手机关机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" Vivo手机打电话 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XiaoMi类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 小米手机开机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 小米手机关机 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 小米手机打电话 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="调用端Client测试"><a href="#调用端Client测试" class="headerlink" title="调用端Client测试"></a>调用端Client测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取折叠式手机 (样式 + 品牌 )</span></span><br><span class="line"></span><br><span class="line">Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">phone1.open();</span><br><span class="line">phone1.call();</span><br><span class="line">phone1.close();</span><br><span class="line">System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">Phone phone2 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">phone2.open();</span><br><span class="line">phone2.call();</span><br><span class="line">phone2.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有的直立式手机</span></span><br><span class="line">Phone phone3 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">phone3.open();</span><br><span class="line">phone3.call();</span><br><span class="line">phone3.close();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">Phone phone4 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">phone4.open();</span><br><span class="line">phone4.call();</span><br><span class="line">phone4.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>通过代码是不是可以领会到桥接模式的力量？</li><li>我们如果增加手机的品牌<code>HUAWEI</code>，我们只需要让其实现Brand类重写方法就可以了；</li><li>如果我们想增加全面屏手机<code>FullScreenPhone</code>类型，我们只需要让其继承Phone类然后重写其方法就行了；</li></ol></blockquote><h5 id="2-5-桥接模式在-JDBC-的源码应用"><a href="#2-5-桥接模式在-JDBC-的源码应用" class="headerlink" title="2.5 桥接模式在 JDBC 的源码应用"></a>2.5 桥接模式在 JDBC 的源码应用</h5><blockquote><p>使用JDBC的时候，你是否一直很困惑获取connection的过程和原理，为什么把不同的数据库驱动名称放到<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>中就能获取到对应的数据库连接呢？</p><p>通过Ctrl +  H 查看。</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200621235556377.png" alt="image-20200621235556377"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200621235614099.png" alt="image-20200621235614099"></p><p><code>Jdbc 的 Driver  接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的Driver，这些就可以当做实现接口类。</code></p><p><code>通过Class.forName(&quot;com.mysql.jdbc.Driver&quot;)类加载的时候执行静态代码块将Driver注册到DriverManager中的registeredDrivers中,DriverManager中的registeredDrivers是个Driver容器，管理不同的Driver,这样具体的数据Driver实现就统一交给容器管理，客户端通过DriverManager执行验证连接，获取连接的操作。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已注册的JDBC驱动程序列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果驱动程序还没有添加到我们的列表中，请注册它 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这是为了与原始驱动管理器兼容</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DriverInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Driver driver;</span><br><span class="line">    DriverAction da;</span><br><span class="line">    DriverInfo(Driver driver, DriverAction action) &#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">        da = action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (other <span class="keyword">instanceof</span> DriverInfo)</span><br><span class="line">                &amp;&amp; <span class="keyword">this</span>.driver == ((DriverInfo) other).driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driver.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"driver[className="</span>  + driver + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DriverAction <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> da;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200621225049710.png" alt="image-20200621225049710"></p><h4 id="3-桥接模式的细节☆"><a href="#3-桥接模式的细节☆" class="headerlink" title="3.桥接模式的细节☆"></a>3.桥接模式的细节☆</h4><blockquote><ol><li><code>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</code></li><li><code>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</code></li><li><code>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</code></li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。</li><li><code>桥接模式要求正确识别出系统中两个独立变化的维度( 抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。</code></li><li><code>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</code></li><li>常见的应用场景<ol><li>JDBC 驱动程序</li><li>银行转账系统<ul><li>转账分类: 网上转账，柜台转账，AMT 转账</li><li>转账用户类型：普通用户，银卡用户，金卡用户..</li></ul></li><li>消息管理<ul><li>消息类型：即时消息，延时消息</li><li>消息分类：手机短信，邮件消息，<code>QQ</code> 消息…</li></ul></li></ol></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;江头未是风波恶，别有人间行路难！&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——辛弃疾《鹧鸪天》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/8.设计模式-适配器模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.140Z</published>
    <updated>2020-12-19T12:49:18.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>薄悻不来门半掩，斜阳。负你残春泪几行。</p><p align="right">——冯延巳《南乡子》</p><a id="more"></a><h2 id="设计模式-适配器模式"><a href="#设计模式-适配器模式" class="headerlink" title="设计模式-适配器模式"></a>设计模式-适配器模式</h2><blockquote><ol><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示， <code>主的目的是兼容性</code>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)。</li><li>适配器模式属于结构型模式</li><li>主要分为三类： <code>类适配器模式、对象适配器模式、接口适配器模式</code></li><li>工作原理<ol><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200614214149706.png" alt="image-20200614214149706"></li></ol></li></ol></blockquote><h4 id="1-类适配器模式"><a href="#1-类适配器模式" class="headerlink" title="1. 类适配器模式"></a>1. 类适配器模式</h4><blockquote><p>基本介绍：<code>Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</code></p><p>以生活中充电器的例子来讲解适配器，<code>充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的dst(即 目标)是 5V 直流电。</code></p><p>类图：</p><ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200614214507198.png" alt="image-20200614214507198"></li></ul></blockquote><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><h6 id="类适配接口Voltage5V"><a href="#类适配接口Voltage5V" class="headerlink" title="类适配接口Voltage5V"></a>类适配接口<code>Voltage5V</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> * 适配接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="被适配的类Voltage220V"><a href="#被适配的类Voltage220V" class="headerlink" title="被适配的类Voltage220V"></a>被适配的类<code>Voltage220V</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被适配的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出220V的电压</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        <span class="comment">//System.out.println("电压=" + src + "伏");</span></span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="适配器类VoltageAdapter"><a href="#适配器类VoltageAdapter" class="headerlink" title="适配器类VoltageAdapter"></a>适配器类<code>VoltageAdapter</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取到220V电压</span></span><br><span class="line"><span class="keyword">int</span> srcV = output220V();</span><br><span class="line"><span class="comment">// 转成 5v</span></span><br><span class="line"><span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dstV;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Phone类"><a href="#Phone类" class="headerlink" title="Phone类"></a>Phone类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"><span class="comment">//充电</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(Voltage5V voltage5V)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(voltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"电压为5V, 可以充电~~"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (voltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"电压大于5V, 不能充电~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  === 类适配器模式 ====</span></span><br><span class="line"><span class="comment"> * 电压为5V, 可以充电~~</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">" === 类适配器模式 ===="</span>);</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类适配器模式细节"><a href="#类适配器模式细节" class="headerlink" title="类适配器模式细节"></a>类适配器模式细节</h5><blockquote><ol><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ol></blockquote><h4 id="2-对象适配器模式"><a href="#2-对象适配器模式" class="headerlink" title="2. 对象适配器模式"></a>2. 对象适配器模式</h4><blockquote><ol><li>基本思路和类的适配器模式相同，<code>只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</code></li><li>根据<code>&quot;合成复用原则&quot;</code>，在系统中尽量使用 关联关系（聚合）来替代继承关系。</li><li>对象适配器模式是适配器模式常用的一种。</li><li><code>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的 dst(即目标)是 5V 直流电，使用对象适配器模式完成。</code></li><li>类图<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200614220320981.png" alt="image-20200614220320981"></li></ul></li></ol></blockquote><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><blockquote><p>类适配接口<code>Voltage5V</code>、被适配的类<code>Voltage220V</code>以及Phone类，都和上面的一样。</p></blockquote><h6 id="适配器类VoltageAdapter-1"><a href="#适配器类VoltageAdapter-1" class="headerlink" title="适配器类VoltageAdapter"></a>适配器类<code>VoltageAdapter</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联关系-聚合</span></span><br><span class="line"><span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line"><span class="comment">// 获取220V 电压</span></span><br><span class="line"><span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line">System.out.println(<span class="string">"使用对象适配器，进行适配~~"</span>);</span><br><span class="line">dst = src / <span class="number">44</span>;</span><br><span class="line">System.out.println(<span class="string">"适配完成，输出的电压为="</span> + dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" === 对象适配器模式 ===="</span>);</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象适配器模式细节"><a href="#对象适配器模式细节" class="headerlink" title="对象适配器模式细节"></a>对象适配器模式细节</h5><blockquote><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</li><li><code>根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst必须是接口。</code></li><li>使用成本更低，更灵活。</li></ol></blockquote><h4 id="3-接口适配器模式"><a href="#3-接口适配器模式" class="headerlink" title="3. 接口适配器模式"></a>3. 接口适配器模式</h4><blockquote><ol><li>一些书籍称为：<code>适配器模式(DefaultAdapter Pattern)</code>或 <code>缺省适配器模式。</code></li><li><code>核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</code></li><li>适用于一个接口不想使用其所有的方法的情况。</li><li>类图：<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200614221314442.png" alt="image-20200614221314442"></li></ul></li></ol></blockquote><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><h6 id="InterfaceFour"><a href="#InterfaceFour" class="headerlink" title="InterfaceFour"></a><code>InterfaceFour</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 17:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceFour</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="AbsAdapter"><a href="#AbsAdapter" class="headerlink" title="AbsAdapter"></a><code>AbsAdapter</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">InterfaceFour</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client-2"><a href="#Client-2" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类</span></span><br><span class="line">AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line"><span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"使用了m1的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">absAdapter.m1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-适配器模式在-SpringMVC-框架应用的源码剖析"><a href="#4-适配器模式在-SpringMVC-框架应用的源码剖析" class="headerlink" title="4. 适配器模式在 SpringMVC 框架应用的源码剖析"></a>4. 适配器模式在 SpringMVC 框架应用的源码剖析</h4><blockquote><p>SpringMVC中的 <code>HandlerAdapter</code>, 就使用了适配器模式。适配器模式在SpringMVC中的体现—详情见SpringMVC执行流程。</p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;薄悻不来门半掩，斜阳。负你残春泪几行。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——冯延巳《南乡子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/7.设计模式-建造者模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.137Z</published>
    <updated>2020-12-19T12:49:17.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>零落成泥碾作尘，只有香如故。</p><p align="right">——陆游《卜算子》</p><a id="more"></a>## 设计模式-建造者模式<h4 id="1-通过案例引入建造者模式"><a href="#1-通过案例引入建造者模式" class="headerlink" title="1. 通过案例引入建造者模式"></a>1. 通过案例引入建造者模式</h4><h5 id="盖房项目需求"><a href="#盖房项目需求" class="headerlink" title="盖房项目需求"></a>盖房项目需求</h5><blockquote><ol><li>需要建房子：我们简化这一过程为打桩、砌墙、封顶。</li><li>房子有各种各样的，比如普通房，高楼，各种房子的过程虽然一样，但是要求不要相同的。</li></ol></blockquote><h5 id="传统方式解决盖房需求"><a href="#传统方式解决盖房需求" class="headerlink" title="传统方式解决盖房需求"></a>传统方式解决盖房需求</h5><h6 id="AbstractHouse"><a href="#AbstractHouse" class="headerlink" title="AbstractHouse"></a><code>AbstractHouse</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 10:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="CommonHouse"><a href="#CommonHouse" class="headerlink" title="CommonHouse"></a><code>CommonHouse</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子砌墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子封顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a><code>Client</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 普通房子打地基</span></span><br><span class="line"><span class="comment">         * 普通房子砌墙</span></span><br><span class="line"><span class="comment">         * 普通房子封顶</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传统方式的问题分析"><a href="#传统方式的问题分析" class="headerlink" title="传统方式的问题分析"></a>传统方式的问题分析</h5><blockquote><p>优点：比较好理解，简单易操作。</p><p>缺点：设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把<code>产品(房子)</code> 和 <code>创建产品的过程(建房子流程)</code> 封装在一起，耦合性增强了。</p></blockquote><h4 id="2-建造者模式改进"><a href="#2-建造者模式改进" class="headerlink" title="2. 建造者模式改进"></a>2. 建造者模式改进</h4><blockquote><ol><li>将产品和产品建造过程解耦  </li><li>建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ol></blockquote><h5 id="建造者模式的四个角色☆"><a href="#建造者模式的四个角色☆" class="headerlink" title="建造者模式的四个角色☆"></a>建造者模式的四个角色☆</h5><blockquote><ol><li><code>Product（产品角色）</code>： 一个具体的产品对象。</li><li><code>Builder（抽象建造者）</code>： 创建一个 Product 对象的各个部件指定的  接口/ 抽象类</li><li><code>ConcreteBuilder（具体建造者）</code>： 实现接口，构建和装配各个部件。</li><li><code>Director（指挥者）</code>： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用：<ul><li>一是：隔离了客户与对象的生产过程</li><li>二是：负责控制产品对象的生产过程。</li></ul></li></ol></blockquote><h5 id="建造者模式创建房子"><a href="#建造者模式创建房子" class="headerlink" title="建造者模式创建房子"></a>建造者模式创建房子</h5><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200614124704789.png" alt="image-20200614124704789"></p><h6 id="House产品类"><a href="#House产品类" class="headerlink" title="House产品类"></a>House产品类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 10:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaise</span><span class="params">(String baise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoofed</span><span class="params">(String roofed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="HouseBuilder抽象建造者"><a href="#HouseBuilder抽象建造者" class="headerlink" title="HouseBuilder抽象建造者"></a><code>HouseBuilder</code>抽象建造者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 11:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将建造的流程写好, 抽象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子好， 将产品(房子) 返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="CommonHouse具体的建造者"><a href="#CommonHouse具体的建造者" class="headerlink" title="CommonHouse具体的建造者"></a><code>CommonHouse</code>具体的建造者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 10:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子砌墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子封顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="HouseDirector指挥者"><a href="#HouseDirector指挥者" class="headerlink" title="HouseDirector指挥者"></a><code>HouseDirector</code>指挥者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器传入 houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过setter 传入 houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 10:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//盖普通房子</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备创建房子的指挥者（这里也可以通过setter注入）</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成盖房子，返回产品(普通房子)</span></span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("输出流程");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-建造者模式在-JDK-的应用和源码分析"><a href="#3-建造者模式在-JDK-的应用和源码分析" class="headerlink" title="3. 建造者模式在 JDK 的应用和源码分析"></a>3. 建造者模式在 JDK 的应用和源码分析</h4><blockquote><ol><li><code>Appendable 接口</code>定义了多个 append 方法(抽象方法), 即 Appendable 为抽象建造者, 定义了抽象方法。</li><li><code>AbstractStringBuilder</code> 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化。</li><li>StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder 完成, 而 StringBuilder 继承了 AbstractStringBuilder</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/14 12:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"hello mm"</span>);</span><br><span class="line">        System.out.println(<span class="string">"stringBuilder = "</span> + stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Appendable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-建造者模式的细节"><a href="#4-建造者模式的细节" class="headerlink" title="4. 建造者模式的细节"></a>4. 建造者模式的细节</h4><blockquote><ol><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li></ol></blockquote><h6 id="抽象工厂模式-VS-建造者模式"><a href="#抽象工厂模式-VS-建造者模式" class="headerlink" title="抽象工厂模式 VS 建造者模式"></a>抽象工厂模式 VS 建造者模式</h6><blockquote><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;零落成泥碾作尘，只有香如故。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——陆游《卜算子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/6.设计模式-原型模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.134Z</published>
    <updated>2020-12-19T12:49:17.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>薄悻不来门半掩，斜阳。负你残春泪几行。</p><p align="right">——冯延巳《南乡子》</p><a id="more"></a><h2 id="设计模式-原型模式-深-浅克隆"><a href="#设计模式-原型模式-深-浅克隆" class="headerlink" title="设计模式-原型模式-深/浅克隆"></a>设计模式-原型模式-深/浅克隆</h2><h4 id="1-原型模式在-Spring-框架中应用"><a href="#1-原型模式在-Spring-框架中应用" class="headerlink" title="1. 原型模式在 Spring 框架中应用"></a>1. 原型模式在 Spring 框架中应用</h4><h5 id="1-1-实体类Student"><a href="#1-1-实体类Student" class="headerlink" title="1.1 实体类Student"></a>1.1 实体类Student</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-配置文件applicationContext-xml"><a href="#1-2-配置文件applicationContext-xml" class="headerlink" title="1.2 配置文件applicationContext.xml"></a>1.2 配置文件applicationContext.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"cn.justweb.pojo.Student"</span> <span class="attr">p:name</span>=<span class="string">"涛哥"</span> <span class="attr">p:sex</span>=<span class="string">"nan"</span> <span class="attr">p:address</span>=<span class="string">"南京"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以及spring的依赖。</p></blockquote><h5 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext( <span class="string">"applicationContext.xml"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时指定bean的id值和类型，来拿到对象</span></span><br><span class="line">        Student student = ctx.getBean( <span class="string">"student"</span>, Student<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"student = "</span> + student );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-通过debug调试追踪getBean-方法"><a href="#1-4-通过debug调试追踪getBean-方法" class="headerlink" title="1.4 通过debug调试追踪getBean()方法"></a>1.4 通过debug调试追踪getBean()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先进到方法里面</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 通过getBeanFactory()方法拿到ConfigurableListableBeanFactory对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"BeanFactory not initialized or already closed - "</span> +</span><br><span class="line"><span class="string">"call 'refresh' before accessing beans via the ApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用getBean（）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.进入到此方法中 Create bean instance.</span></span><br><span class="line"><span class="comment">//prototypeInstance = createBean(beanName, mbd, args);</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String name, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> Class&lt;T&gt; requiredType, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略....</span></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">// 省略.....</span></span><br><span class="line">                   </span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-原型模式"><a href="#2-原型模式" class="headerlink" title="2. 原型模式"></a>2. 原型模式</h4><blockquote><ol><li>原型模式<code>(Prototype 模式)</code>是指：用 原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即  <code>对象.clone()</code>。</li></ol></blockquote><blockquote><p>Sheep实体类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 11:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, Integer age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-传统方式解决克隆羊问题"><a href="#2-1-传统方式解决克隆羊问题" class="headerlink" title="2.1 传统方式解决克隆羊问题"></a>2.1 传统方式解决克隆羊问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 11:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"MM"</span>, <span class="number">3</span>, <span class="string">"yellow"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们很容易想到的克隆对象</span></span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sheep.hashCode() = 1163157884</span></span><br><span class="line"><span class="comment">         * sheep1.hashCode() = 1956725890</span></span><br><span class="line"><span class="comment">         * sheep2.hashCode() = 356573597</span></span><br><span class="line"><span class="comment">         * sheep3.hashCode() = 1735600054</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"sheep.hashCode() = "</span> + sheep.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep1.hashCode() = "</span> + sheep1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep2.hashCode() = "</span> + sheep2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep3.hashCode() = "</span> + sheep3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-原型模式解决克隆羊问题"><a href="#2-2-原型模式解决克隆羊问题" class="headerlink" title="2.2 原型模式解决克隆羊问题"></a>2.2 原型模式解决克隆羊问题</h5><blockquote><p>Java 中 <a href="https://blog.csdn.net/weixin_45267102/article/details/106117366" target="_blank" rel="noopener">Object 类</a>是所有类的根类，Object 类提供了一个 <code>clone()</code>方法，该方法可以将一个 Java 对象复制<br>一份，但是<code>需要实现 clone的Java类必须要实现一个接口Cloneable</code>，该接口表示该类能够复制且具有复制的能力 — 原型模式</p></blockquote><h6 id="第一步：Sheep实体类实现Cloneable接口"><a href="#第一步：Sheep实体类实现Cloneable接口" class="headerlink" title="第一步：Sheep实体类实现Cloneable接口"></a>第一步：Sheep实体类实现Cloneable接口</h6><h6 id="第二步：Sheep中重写clone-方法"><a href="#第二步：Sheep中重写clone-方法" class="headerlink" title="第二步：Sheep中重写clone()方法"></a>第二步：Sheep中重写clone()方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*克隆该实例，使用默认的 clone 方法来完成</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sheep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第三步：使用clone-方法克隆Sheep对象"><a href="#第三步：使用clone-方法克隆Sheep对象" class="headerlink" title="第三步：使用clone()方法克隆Sheep对象"></a>第三步：使用clone()方法克隆Sheep对象</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 11:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"MM"</span>, <span class="number">3</span>, <span class="string">"yellow"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用原型模式</span></span><br><span class="line">        Sheep sheep4 = (Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep5 = (Sheep)sheep.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sheep4 = Sheep&#123;name='MM', age=3, color='yellow'&#125;</span></span><br><span class="line"><span class="comment">         * sheep5 = Sheep&#123;name='MM', age=3, color='yellow'&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"sheep4 = "</span> + sheep4);</span><br><span class="line">        System.out.println(<span class="string">"sheep5 = "</span> + sheep5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sheep4.hashCode() = 1163157884</span></span><br><span class="line"><span class="comment">         * sheep5.hashCode() = 1956725890</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"sheep4.hashCode() = "</span> + sheep4.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sheep5.hashCode() = "</span> + sheep5.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h4><h5 id="3-1-浅拷贝"><a href="#3-1-浅拷贝" class="headerlink" title="3.1 浅拷贝"></a>3.1 浅拷贝</h5><blockquote><ol><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说<code>成员变量是某个数组、某个类的对象等</code>，那么<code>浅拷贝会进行</code><br><code>引用传递</code>，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成<br>员变量都指向同一个实例。<code>在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</code></li><li>前面我们克隆羊就是浅拷贝。</li><li>浅拷贝是使用默认的 clone()方法来实现 <code>sheep = (Sheep) super.clone();</code></li></ol></blockquote><h5 id="3-2-深拷贝"><a href="#3-2-深拷贝" class="headerlink" title="3.2 深拷贝"></a>3.2 深拷贝</h5><blockquote><ol><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说， 对象进行深拷贝要对整个对象( 包括对象的引用类型) 进行拷贝。</li><li>深拷贝实现方式：<ol><li>重写 clone 方法来实现深拷贝</li><li>通过<code>对象序列化实现深拷贝(推荐)</code></li></ol></li></ol></blockquote><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><blockquote><p>测试深拷贝，<code>需要让DeepCloneTarget类作为DeepProtoType类的属性。</code></p><p><code>DeepProtoType类</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 15:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 引用类型</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneTarget deepCloneTarget;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DeepProtoType&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", deepCloneTarget="</span> + deepCloneTarget +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>DeepProtoType类</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 15:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer cloneAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneTarget</span><span class="params">(String cloneName, Integer cloneAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="keyword">this</span>.cloneAge = cloneAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为该类的属性，是String和Integer</span></span><br><span class="line"><span class="comment">     * 因此我们这里使用默认的clone完成即可,即通过浅拷贝拷贝对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DeepCloneTarget&#123;"</span> +</span><br><span class="line">                <span class="string">"cloneName='"</span> + cloneName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cloneAge="</span> + cloneAge +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方案一：重写-clone-方法实现深拷贝"><a href="#方案一：重写-clone-方法实现深拷贝" class="headerlink" title="方案一：重写 clone 方法实现深拷贝"></a>方案一：重写 clone 方法实现深拷贝</h6><blockquote><p>在DeepProtoType类中重写clone()方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝 - 方式 1 使用clone 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">       Object deep = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">       deep = <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">       DeepProtoType deepProtoType = (DeepProtoType) deep;</span><br><span class="line"></span><br><span class="line">       deepProtoType.deepCloneTarget = (DeepCloneTarget) deepCloneTarget.clone();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> deepProtoType;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 16:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepProtoType dpt = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        dpt.name = <span class="string">"MM"</span>;</span><br><span class="line">        dpt.deepCloneTarget = <span class="keyword">new</span> DeepCloneTarget(<span class="string">"DD"</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dpt = DeepProtoType&#123;name='MM', deepCloneTarget=DeepCloneTarget&#123;cloneName='DD', cloneAge=17&#125;&#125;</span></span><br><span class="line"><span class="comment">         * dpt.deepCloneTarget.hashCode() = 1163157884</span></span><br><span class="line"><span class="comment">         * dpt2 = DeepProtoType&#123;name='MM', deepCloneTarget=DeepCloneTarget&#123;cloneName='DD', cloneAge=17&#125;&#125;</span></span><br><span class="line"><span class="comment">         * dpt2.deepCloneTarget.hashCode() = 1956725890</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"dpt = "</span> + dpt);</span><br><span class="line">        System.out.println(<span class="string">"dpt.deepCloneTarget.hashCode() = "</span> + dpt.deepCloneTarget.hashCode());</span><br><span class="line"></span><br><span class="line">        DeepProtoType dpt2 = (DeepProtoType)dpt.clone();</span><br><span class="line">        System.out.println(<span class="string">"dpt2 = "</span> + dpt2);</span><br><span class="line">        System.out.println(<span class="string">"dpt2.deepCloneTarget.hashCode() = "</span> + dpt2.deepCloneTarget.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方案二：对象序列化实现深拷贝-推荐"><a href="#方案二：对象序列化实现深拷贝-推荐" class="headerlink" title="方案二：对象序列化实现深拷贝(推荐)"></a>方案二：对象序列化实现深拷贝(推荐)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将流对象中的数组输入到内存中</span></span><br><span class="line">       ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 序列化流</span></span><br><span class="line">       ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//将内存中的数组输出</span></span><br><span class="line">       ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 反序列化流</span></span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 序列化</span></span><br><span class="line">           bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">           oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 当前这个对象以对象流的方式输出</span></span><br><span class="line">           oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 反序列化</span></span><br><span class="line">           bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">           ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">           DeepProtoType copydeepProtoType = (DeepProtoType)ois.readObject();</span><br><span class="line">           <span class="keyword">return</span> copydeepProtoType;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">           e1.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//关闭流</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               bos.close();</span><br><span class="line">               oos.close();</span><br><span class="line">               bis.close();</span><br><span class="line">               ois.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">               e2.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/11 16:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepProtoType dpt = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        dpt.name = <span class="string">"MM"</span>;</span><br><span class="line">        dpt.deepCloneTarget = <span class="keyword">new</span> DeepCloneTarget(<span class="string">"DD"</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dpt = DeepProtoType&#123;name='MM', deepCloneTarget=DeepCloneTarget&#123;cloneName='DD', cloneAge=17&#125;&#125;</span></span><br><span class="line"><span class="comment">         * dpt.deepCloneTarget.hashCode() = 1163157884</span></span><br><span class="line"><span class="comment">         * dpt2 = DeepProtoType&#123;name='MM', deepCloneTarget=DeepCloneTarget&#123;cloneName='DD', cloneAge=17&#125;&#125;</span></span><br><span class="line"><span class="comment">         * dpt2.deepCloneTarget.hashCode() = 1956725890</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"dpt = "</span> + dpt);</span><br><span class="line">        System.out.println(<span class="string">"dpt.deepCloneTarget.hashCode() = "</span> + dpt.deepCloneTarget.hashCode());</span><br><span class="line"></span><br><span class="line">        DeepProtoType dpt2 = (DeepProtoType)dpt.clone();</span><br><span class="line">        System.out.println(<span class="string">"dpt2 = "</span> + dpt2);</span><br><span class="line">        System.out.println(<span class="string">"dpt2.deepCloneTarget.hashCode() = "</span> + dpt2.deepCloneTarget.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式 2 完成深拷贝</span></span><br><span class="line">        DeepProtoType dpt3 = (DeepProtoType) dpt.deepClone();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dpt.name=MM   dpt.deepCloneableTarget=1163157884</span></span><br><span class="line"><span class="comment">         * dpt3.name=MM   dpt3.deepCloneableTarget=189568618</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"dpt.name="</span> + dpt.name + <span class="string">"   dpt.deepCloneableTarget="</span> + dpt.deepCloneTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"dpt3.name="</span> + dpt3.name + <span class="string">"   dpt3.deepCloneableTarget="</span> + dpt3.deepCloneTarget.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><blockquote><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化<code>(增加或者减少属性--这个指的是对被克隆的对象，如果修改被克隆对象里面的对象属性则需要通过深克隆才能克隆其对象属性)</code>，其它克隆对象的也会发生相应的变化，无需修改代码。</li><li>在实现深克隆的时候可能需要比较复杂的代码，实现深克隆的缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;薄悻不来门半掩，斜阳。负你残春泪几行。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——冯延巳《南乡子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/5.设计模式-工厂模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.132Z</published>
    <updated>2020-12-19T12:49:17.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>旧日堂前燕，和烟雨，又双飞。人自老，春长好，梦佳期。</p><p align="right">——韩元吉《六州歌头》</p><a id="more"></a>[TOC]<h2 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h2><blockquote><p>工厂模式适合场景：</p><ul><li><p>如果你和你对象去饭馆吃饭，如果没有服务员（工厂类），点菜怎么点？</p></li><li><p>餐馆的菜单方便客人更改吗？</p></li><li><p>凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂模式进行创建。</p></li></ul></blockquote><h4 id="1-工厂模式在-JDK-Calendar-的应用"><a href="#1-工厂模式在-JDK-Calendar-的应用" class="headerlink" title="1. 工厂模式在 JDK-Calendar 的应用"></a>1. 工厂模式在 JDK-Calendar 的应用</h4><blockquote><p>工厂方法模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步创建Calendar对象 </span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步调用getInstance()方法（抽象类Calendar）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createCalendar(</span><br><span class="line">        TimeZone.getDefault(), </span><br><span class="line">        Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,Locale aLocale)</span></span>&#123;</span><br><span class="line">        CalendarProvider provider =</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider<span class="class">.<span class="keyword">class</span>, <span class="title">aLocale</span>)</span></span><br><span class="line"><span class="class">                                 .<span class="title">getCalendarProvider</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar cal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">            String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">            <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">                    cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">                    cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If no known calendar type is explicitly specified,</span></span><br><span class="line">            <span class="comment">// perform the traditional way to create a Calendar:</span></span><br><span class="line">            <span class="comment">// create a BuddhistCalendar for th_TH locale,</span></span><br><span class="line">            <span class="comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span></span><br><span class="line">            <span class="comment">// a GregorianCalendar for any other locales.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> The language, country and variant strings are interned.</span></span><br><span class="line">            <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span></span><br><span class="line">                       &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h4><blockquote><ol><li>建立一个工厂类，对<strong>实现了同一接口的一些类</strong>进行实例的创建。</li><li>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</li><li>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建造一个实现类，并且实现定义的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is mailsender!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建造一个实现类，并且实现定义的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is sms sender!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//建工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"mail"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"sms"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入正确的类型!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//创建工厂类对象</span></span><br><span class="line">            SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过工厂类来创建SmsSender对象，</span></span><br><span class="line">            <span class="comment">//SmsSender smsSender = factory.produce("sms");</span></span><br><span class="line">            Sender sender = factory.produce(<span class="string">"sms"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//smsSender.Send();</span></span><br><span class="line">            sender.Send();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为<code>静态工厂方法模式。</code>体现在下面的代码中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Sender sender = SendFactory.produceMail(); </span><br><span class="line">        </span><br><span class="line">        sender.Send();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-工厂方法模式（Factory-Method）"><a href="#3-工厂方法模式（Factory-Method）" class="headerlink" title="3. 工厂方法模式（Factory Method）"></a>3. 工厂方法模式（Factory Method）</h4><blockquote><ol><li>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</li><li>因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1. 创建抽象工厂类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">Manufacture</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；</span></span><br><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</span></span><br><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product Manufactu <span class="title">re</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实</span></span><br><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        FactoryA mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        mFactoryA.Manufacture().Show();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        FactoryB mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        mFactoryB.Manufacture().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-抽象工厂模式（Abstract-Factory）"><a href="#3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="3. 抽象工厂模式（Abstract Factory）"></a>3. 抽象工厂模式（Abstract Factory）</h4><blockquote><p>抽象工厂模式是对工厂方法模式的进一步改进，<code>在工厂方法模式中，工厂的核心类只能产出一种产品。而在抽象工厂模式中，可以创建一组相关联的产品。</code></p></blockquote><h6 id="一系列产品类"><a href="#一系列产品类" class="headerlink" title="一系列产品类"></a>一系列产品类</h6><blockquote><p>这里举两个例子：蛋糕的制作和果汁的制作；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *制作水果汁接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JuiceProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*制作蛋糕的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CakeProduct</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cooking</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 制作苹果汁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleJuiceProduct</span> <span class="keyword">implements</span> <span class="title">JuiceProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在制作苹果汁&gt;&gt;&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 制作梨汁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PearJuiceProduct</span> <span class="keyword">implements</span> <span class="title">JuiceProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在制作梨汁&gt;&gt;&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 制作香蕉汁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaJuiceProduct</span> <span class="keyword">implements</span> <span class="title">JuiceProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在制作香蕉汁&gt;&gt;&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheeseCakeProduct</span> <span class="keyword">implements</span> <span class="title">CakeProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在烹饪芝士蛋糕&gt;&gt;&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="一系列工厂类"><a href="#一系列工厂类" class="headerlink" title="一系列工厂类"></a>一系列工厂类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 制作套餐工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetMealFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产蛋糕</span></span><br><span class="line">    <span class="function">CakeProduct <span class="title">productCake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产果汁</span></span><br><span class="line">    <span class="function">JuiceProduct <span class="title">productJuice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A套餐生产工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASetMealFactory</span> <span class="keyword">implements</span> <span class="title">SetMealFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产芝士蛋糕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CakeProduct <span class="title">productCake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheeseCakeProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产苹果汁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JuiceProduct <span class="title">productJuice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppleJuiceProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过<a href="https://blog.csdn.net/liu88010988/article/details/50799902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159178027719195188455575%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159178027719195188455575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-50799902.first_rank_v2_rank_v25&utm_term=%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">抽象工厂模式和工厂方法模式区别</a>这篇博客的类图可以更通透的理解抽象工厂模式。</p></blockquote><h4 id="5-工厂模式小结"><a href="#5-工厂模式小结" class="headerlink" title="5.  工厂模式小结"></a>5.  工厂模式小结</h4><blockquote><p>工厂模式的意义：</p><ol><li>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</li></ol><p>三种工厂模式：</p><ol><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;旧日堂前燕，和烟雨，又双飞。人自老，春长好，梦佳期。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——韩元吉《六州歌头》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/4.设计模式-单列模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.130Z</published>
    <updated>2020-12-19T12:49:17.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>衣带渐宽终不悔。为伊消得人憔悴。</p><p align="right">——柳永《蝶恋花》</p><a id="more"></a><h2 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h2><blockquote><ul><li>所谓类的单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，<br>并且该类只提供一个取得其对象实例的方法(静态方法)。</li><li>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</li></ul></blockquote><h4 id="1-单例模式在-JDK-源码中的应用"><a href="#1-单例模式在-JDK-源码中的应用" class="headerlink" title="1. 单例模式在 JDK 源码中的应用"></a>1. 单例模式在 JDK 源码中的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*每个Java应用程序都有一个Runtime类的Runtime ，允许应用程序与运行应用程序的环境进行接口。 当前运行时可以*从getRuntime方法获得。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Don't let anyone else instantiate this class </span></span><br><span class="line"><span class="comment">    *  不要让任何人实例化此类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一系列方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-单例设计模式七种方式"><a href="#2-单例设计模式七种方式" class="headerlink" title="2. 单例设计模式七种方式"></a>2. 单例设计模式七种方式</h4><blockquote><ol><li>饿汉式( 静态常量)</li><li>饿汉式（静态代码块）</li><li>懒汉式(线程不安全)</li><li>懒汉式(线程安全，同步方法)</li><li>双重检查</li><li>静态内部类</li><li>枚举</li></ol></blockquote><h5 id="一、饿汉式-静态常量-☆"><a href="#一、饿汉式-静态常量-☆" class="headerlink" title="一、饿汉式( 静态常量)☆"></a>一、饿汉式( 静态常量)☆</h5><blockquote><p>优缺点说明</p><ul><li>优点：这种写法比较简单，就是在<code>类装载的时候就完成实例化</code>。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 <code>Lazy Loading</code> 的效果。如果从始至终从未使用过这个实例，则<br>会造成内存的浪费。</li><li>这种方式基于 classloder 机制避免了多线程的同步问题（<code>可以查看ClassLoader.loadClass()源码得知</code>），不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果。</li></ul><p>结论：</p><ul><li>这种单例模式可用，<code>可能</code>造成内存浪费，并且<code>java.lang.Runtime</code>中就是使用此种方法。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式(静态变量)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造器私有化, 不要让任何人实例化此类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、饿汉式（静态代码块）☆"><a href="#二、饿汉式（静态代码块）☆" class="headerlink" title="二、饿汉式（静态代码块）☆"></a>二、饿汉式（静态代码块）☆</h5><blockquote><p>优缺点说明：</p><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执<br>行静态代码块中的代码，初始化类的实例。</li><li>优缺点和上面是一样的。</li></ol><p>结论：</p><ul><li>这种单例模式可用，但是可能造成内存浪费</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式(静态变量)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 构造器私有化, 不要让任何人实例化此类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、懒汉式-线程不安全-单线程模式下可以使用"><a href="#三、懒汉式-线程不安全-单线程模式下可以使用" class="headerlink" title="三、懒汉式(线程不安全,单线程模式下可以使用)"></a>三、懒汉式<code>(线程不安全,单线程模式下可以使用)</code></h5><blockquote><p>优缺点说明</p><ol><li>起到了 Lazy Loading 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 <code>if (singleton == null)</code> 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会 产生多个实例。所以在多线程环境下不可使用这种方式。</li></ol><p>结论：</p><ul><li>在实际开发中， 不要使用这种方式.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四、懒汉式-线程安全，同步方法"><a href="#四、懒汉式-线程安全，同步方法" class="headerlink" title="四、懒汉式(线程安全，同步方法)"></a>四、懒汉式(线程安全，同步方法)</h5><blockquote><p>优缺点说明：</p><ol><li>解决了 线程安全问题</li><li><code>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。</code>而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。 方法进行同步效率太低。</li></ol><p>结论：</p><ul><li>在实际开发中， 不推荐使用这种方式。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="五、双重检查☆"><a href="#五、双重检查☆" class="headerlink" title="五、双重检查☆"></a>五、双重检查☆</h5><blockquote><p>优缺点说明：</p><ol><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 <code>if (singleton == null)</code>检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 <code>if (singleton == null)</code>，直接 return 实例化对象，也避免的反复进行方法同步。</li><li>线程安全； 延迟加载； 效率较高</li></ol><p>结论：</p><ul><li>在实际开发中推荐使用。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line"><span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="六、静态内部类"><a href="#六、静态内部类" class="headerlink" title="六、静态内部类"></a>六、静态内部类</h5><blockquote><p>tips:</p><ul><li>内部类不能定义static元素(注意不是静态内部类)</li><li><a href="https://blog.csdn.net/vcliy/article/details/85235363" target="_blank" rel="noopener">了解更多内部类知识…</a></li></ul><p>优缺点说明：</p><ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才<br>会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li><li>优点： 避免了线程不安全，利用 静态内部类特点实现延迟加载，效率高。</li><li><a href="https://www.cnblogs.com/zouxiangzhongyan/p/10762540.html" target="_blank" rel="noopener">静态内部类是如何实现懒加载的….</a></li></ol><p>结论： </p><ul><li>推荐使用</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="七、枚举"><a href="#七、枚举" class="headerlink" title="七、枚举"></a>七、枚举</h5><blockquote><p>优缺点说明：</p><ol><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建<br>新的对象。</li><li>这种方式是 Effective Java  作者 Josh Bloch  提倡的方式</li></ol><p>结论： </p><ul><li>推荐使用</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE; <span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ok..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton instance1 = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance1 == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"instance1.hashCode="</span> + instance1.hashCode());</span><br><span class="line">System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">        </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * instance1.getClass().getClassLoader() = sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">      * instance2.getClass().getClassLoader() = sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      System.out.println(<span class="string">"instance1.getClass().getClassLoader() = "</span> + instance1.getClass().getClassLoader());</span><br><span class="line">      System.out.println(<span class="string">"instance2.getClass().getClassLoader() = "</span> + instance2.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 枚举实现单列的测试</span></span><br><span class="line">Singleton instance = Singleton.INSTANCE;</span><br><span class="line">Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">System.out.println(instance == instance2);</span><br><span class="line"></span><br><span class="line">System.out.println(instance.hashCode());</span><br><span class="line">System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line">instance.sayOK();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-单例模式细节说明"><a href="#4-单例模式细节说明" class="headerlink" title="4. 单例模式细节说明"></a>4. 单例模式细节说明</h4><blockquote><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使<br>用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new。</li><li>单例模式 使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级<br>对象)，但又经常用到的对象、 工具类对象、频繁访问数据库或文件的对象(比如 数据源、session  工厂等)</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a><code>☆</code></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;衣带渐宽终不悔。为伊消得人憔悴。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——柳永《蝶恋花》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/3.设计模式概述</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-12-19T12:46:34.128Z</published>
    <updated>2020-12-19T12:49:17.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>月上柳梢头，人约黄昏后。</p><p align="right">——欧阳修《生查子》</p><a id="more"></a><h3 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h3><blockquote><ol><li>解决某一类问题行之有效的方法；设计模式主要强调的是思想，不是代码，就像建房子需要现有地基，然后需要房梁，需要如何建造一个框架，设计模式就是我们要编程过程中解决某类问题可以采用的思路和方法。</li></ol></blockquote><h3 id="2-设计模式概述"><a href="#2-设计模式概述" class="headerlink" title="2. 设计模式概述"></a>2. 设计模式概述</h3><blockquote><ol><li><strong>设计模式（Design pattern）</strong>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是<code>为了可重用代码、让代码更容易被他人理解、保证代码可靠性</code>。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</li><li><code>&lt;&lt; 设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）</code></li><li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式</li></ol></blockquote><p><strong>模式：在某些==场景==下，针对某类==问题==的某种通用的==解决方案==。</strong></p><ul><li><p><strong>场景</strong>：项目所在的环境</p></li><li><p><strong>问题</strong>：约束条件，项目目标等</p></li><li><p><strong>解决方案</strong>：通用、可复用的设计，解决约束达到目标。</p></li></ul><h3 id="3-设计模式分类"><a href="#3-设计模式分类" class="headerlink" title="3. 设计模式分类"></a>3. 设计模式分类</h3><p><code>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</code></p><ul><li><p>==单例模式==：某个类只能有一个实例，提供一个全局的访问点。</p></li><li><p>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p></li><li><p>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</p></li><li><p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</p></li><li><p>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</p></li><li><p>原型模式：通过复制现有的实例来创建新的实例。</p></li></ul><p><code>结构型模式：把类或对象结合在一起形成一个更大的结构。</code></p><ul><li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</li><li>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</li><li>==装饰着模式==：动态的给对象添加新的功能。</li><li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</li><li>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</li><li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</li></ul><p><code>行为型模式：类和对象如何交互，及划分责任和算法。</code></p><ul><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li><li>观察者模式：对象间的一对多的依赖关系。</li><li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</li><li>中介者模式：用一个中介对象来封装一系列的对象交互。</li><li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li><li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li><li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li></ul><h3 id="4-小结-肺腑之言"><a href="#4-小结-肺腑之言" class="headerlink" title="4. 小结-肺腑之言"></a>4. 小结-肺腑之言</h3><blockquote><p>​        学设计模式有什么意义呢？对自己来说当有了一定的数据结构和算法基础后，当然可以写出相对优雅的代码，但是从整个软件架构来说确实很迷茫，你是否认为spring架构的优雅？你是否对spring底层是怎么实现的感兴趣？如果自己想去了解这么优雅架构，除了语言基础，数据结构和算法之外，也应该掌握设计模式。才能去深刻的探索那些优雅的架构。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;月上柳梢头，人约黄昏后。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——欧阳修《生查子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/2.设计模式七大原则</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2020-12-19T12:46:34.126Z</published>
    <updated>2020-12-19T12:49:17.417Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>黯相望。断鸿声里，立尽斜阳。</p><p align="right">——柳永《玉蝴蝶》</p><a id="more"></a><h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote><p>编写软件过程中，程序员面临着来自 <code>耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的</code><br><code>挑战</code>，设计模式是为了让程序(软件)，具有更好的：</p><ol><li><code>代码重用性 (即：相同功能的代码，不用多次编写)</code></li><li><code>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</code></li><li><code>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</code></li><li><code>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</code></li><li><code>使程序呈现高内聚，低耦合的特性</code></li></ol><p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（<code>OOA/D</code>）的精要”</p><p>设计模式原则，其实就是 程序员在编程时，应当遵守的原则，也是各种设计模式的基础。即设计模式为什么<br>这样设计的依据。<br>设计模式常用的七大原则有:</p><ol><li><code>单一职责原则</code></li><li><code>接口隔离原则</code></li><li><code>依赖倒转(倒置)原则</code></li><li><code>里氏替换原则</code></li><li><code>开闭原则</code></li><li><code>迪米特法则</code></li><li><code>合成复用原则</code></li></ol></blockquote><h4 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h4><blockquote><p>对类来说的， 即一个类应该只负责一项职责。</p><p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以<code>需要将类 A 的粒度分解为 A1，A2</code>从而满足单一职责原则。</p></blockquote><h6 id="违反单一职责原则"><a href="#违反单一职责原则" class="headerlink" title="违反单一职责原则"></a>违反单一职责原则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="comment">// 1. 在这里的 run 方法中， 违反了单一职责原则</span></span><br><span class="line"><span class="comment">// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="遵守单一职责原则"><a href="#遵守单一职责原则" class="headerlink" title="遵守单一职责原则"></a>遵守单一职责原则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 遵守单一职责原则</span></span><br><span class="line"><span class="comment">//2. 但是这样做的改动很大，即将 类分解，同时修改客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"公路运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"天空运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">         System.out.println(vehicle + <span class="string">"水中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改进后：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span></span><br><span class="line"><span class="comment">//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在天空上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在水中行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="单一职责原则细节"><a href="#单一职责原则细节" class="headerlink" title="单一职责原则细节"></a>单一职责原则细节</h6><blockquote><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中<br>方法数量足够少，可以在方法级别保持单一职责原则。</li></ol></blockquote><h4 id="2-接口隔离原则"><a href="#2-接口隔离原则" class="headerlink" title="2. 接口隔离原则"></a>2. 接口隔离原则</h4><blockquote><ol><li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</li><li>使用接口隔离原则拆分接口时，首先必须满足<code>单一职责原则</code>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li><li>可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。</li></ol></blockquote><h4 id="3-依赖倒转原则☆"><a href="#3-依赖倒转原则☆" class="headerlink" title="3. 依赖倒转原则☆"></a>3. 依赖倒转原则☆</h4><blockquote><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li><code>依赖倒转(倒置)的中心思想是面向接口编程</code></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架<br>构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用 接口或抽象类 的目的是制定好 规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完<br>成。</li></ol></blockquote><h6 id="违反依赖倒转原则"><a href="#违反依赖倒转原则" class="headerlink" title="违反依赖倒转原则"></a>违反依赖倒转原则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*测试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成 Person 接收消息的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email )</span> </span>&#123;</span><br><span class="line">    System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>简单，比较容易想到</li><li>如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法</li><li>解决思路：引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖。因为 Email, WeiXin 等等属于接收的范围，他们各自实现 IReceiver 接口就 可以了, 这样我们就符合依赖倒转原则。</li></ol></blockquote><h6 id="遵守依赖倒转原则"><a href="#遵守依赖倒转原则" class="headerlink" title="遵守依赖倒转原则"></a>遵守依赖倒转原则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">    System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h6><blockquote><ol><li>接口传递</li><li>构造方法传递</li><li>setter 方式传递</li></ol></blockquote><h6 id="依赖倒转原则的细节"><a href="#依赖倒转原则的细节" class="headerlink" title="依赖倒转原则的细节"></a>依赖倒转原则的细节</h6><blockquote><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</li><li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展<br>和优化</li><li>继承时遵循 里氏替换原则。</li></ol></blockquote><h4 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4. 里氏替换原则"></a>4. 里氏替换原则</h4><blockquote><p>学习里氏替换原则之前我们需要先了解面向对象中的继承性：</p><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有<br>的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时， 也带来了弊端。比如使用继承会给程序带来 侵入性，程序的可移植性降低，<br>增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且<br>父类修改后，所有涉及到子类的功能都有可能产生故障。</li><li>问题提出： 在编程中，如何正确的使用继承? </li><li><code>那就是里氏替换原则</code></li></ol></blockquote><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><blockquote><ol><li><code>里氏替换原则(Liskov Substitution Principle)</code>在 1988 年，由麻省理工学院的以为姓里的女士提出–所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li><li>里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</li><li>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li><li>使用里氏代换原则需要注意：<ol><li>子类的多有方法必须在父类中声明，或者子类必须实现父类中声名的所有方法。</li><li>尽量把父类设计成抽象类或接口，让子类继承父类或实现父接口。增加一个新功能时，通过增加一个新的子类来实现。</li></ol></li></ol></blockquote><h4 id="5-开闭原则☆"><a href="#5-开闭原则☆" class="headerlink" title="5. 开闭原则☆"></a>5. 开闭原则☆</h4><blockquote><p><code>开闭原则（Open Closed Principle）是编程中 最基础、最重要的设计原则。</code></p><ol><li>一个软件实体如类，模块和函数应该 对扩展开放( 对提供方)，对 修改关闭( 对使用方)。用抽象构建框架，用实<br>现扩展细节。</li><li>当软件需要变化时，尽量 通过扩展软件实体的行为来实现变化，而不是 通过修改已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol></blockquote><h6 id="违反了开闭原则"><a href="#违反了开闭原则" class="headerlink" title="违反了开闭原则"></a>违反了开闭原则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用看看存在的问题</span></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line"><span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">drawRectangle(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">drawCircle(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">drawTriangle(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制矩形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制圆形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制三角形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Rectangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Circle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Triangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的开闭原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的<br>时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多。</li></ol></blockquote><h6 id="遵循开闭原则"><a href="#遵循开闭原则" class="headerlink" title="遵循开闭原则"></a>遵循开闭原则</h6><blockquote><ol><li>思路：把创建 Shape  类做成抽象类，并提供一个 抽象的 draw 方法，让 子类去实现即可，这样我们有新的图形<br>种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修改 。</li><li>这样就满足了开闭原则</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用看看存在的问题</span></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line"><span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">s.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Rectangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Circle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Triangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">OtherGraphic() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 绘制其它图形 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6. 迪米特法则"></a>6. 迪米特法则</h4><h6 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h6><blockquote><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类 对自己依赖的类知道的越少越好。也就是说，对于<br>被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息。</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信。<ul><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。</li><li>耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量， 方法参数， 方法返回值中的类为直接的朋友，而出现在 局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ul></li></ol></blockquote><h6 id="迪米特法则细节"><a href="#迪米特法则细节" class="headerlink" title="迪米特法则细节"></a>迪米特法则细节</h6><blockquote><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是<br>要求完全没有依赖关系。</li></ol></blockquote><h4 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h4><blockquote><p><code>原则是尽量使用合成/聚合的方式，而不是使用继承。</code></p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li><code>为了交互对象之间的松耦合设计而努力。</code></li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a><code>☆</code></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;黯相望。断鸿声里，立尽斜阳。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——柳永《玉蝴蝶》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/15.设计模式-模板模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.124Z</published>
    <updated>2020-12-19T12:49:17.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欲将沉醉换悲凉。清歌莫断肠。</p><p align="right">——晏几道《阮郎归》</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;欲将沉醉换悲凉。清歌莫断肠。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《阮郎归》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/14.设计模式-代理模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.122Z</published>
    <updated>2020-12-19T12:49:17.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>便作春江都是泪，流不尽，许多愁。</p><p align="right">——秦观《江城子》</p><a id="more"></a><h2 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式-代理模式"></a>设计模式-代理模式</h2><blockquote><ol><li><code>代理模式：</code>为一个对象提供一个<code>替身</code>，以控制对这个对象的访问。即通过代理对象访问目标对象,这样做的好处是–<code>可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</code></li><li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。</li><li>代理模式主要有三种<ol><li>静态代理</li><li>动态代理 (<code>JDK 代理--接口代理</code>)</li><li>动态代理<code>Cglib 代理</code> (可以在内存动态的创建对象，而不需要实现接口)。</li></ol></li></ol></blockquote><h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><blockquote><p>静态代理在使用时，需要定义接口或者父类，<code>被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。</code></p></blockquote><h5 id="1-1-引出静态代理模式"><a href="#1-1-引出静态代理模式" class="headerlink" title="1.1 引出静态代理模式"></a>1.1 引出静态代理模式</h5><blockquote><ol><li>定义一个<code>接口 ITeacherDao</code></li><li><code>目标对象 TeacherDAO</code> 实现<code>接口 ITeacherDAO</code></li><li>使用静态代理方式，就需要<code>在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200630131354746.png" alt="image-20200630131354746"></li></ol><p>特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</p></blockquote><h5 id="1-2-代码实现之"><a href="#1-2-代码实现之" class="headerlink" title="1.2 代码实现之"></a>1.2 代码实现之</h5><h6 id="接口ITeacherDao"><a href="#接口ITeacherDao" class="headerlink" title="接口ITeacherDao"></a>接口ITeacherDao</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 授课的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="被代理对象TeacherDao"><a href="#被代理对象TeacherDao" class="headerlink" title="被代理对象TeacherDao"></a>被代理对象TeacherDao</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 老师授课中..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="静态代理对象TeacherDaoProxy"><a href="#静态代理对象TeacherDaoProxy" class="headerlink" title="静态代理对象TeacherDaoProxy"></a>静态代理对象TeacherDaoProxy</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line"><span class="comment">// 目标对象，通过接口来聚合</span></span><br><span class="line"><span class="keyword">private</span> ITeacherDao target; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目标方法进行增强</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始代理  完成某些操作..."</span>);</span><br><span class="line">target.teach();</span><br><span class="line">System.out.println(<span class="string">"提交..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建目标对象(被代理对象)</span></span><br><span class="line">TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class="line">TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line"><span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class="line">teacherDaoProxy.teach();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-静态代理优缺点"><a href="#1-3-静态代理优缺点" class="headerlink" title="1.3 静态代理优缺点"></a>1.3 静态代理优缺点</h5><blockquote><p>优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展。<br>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。一旦接口增加方法,目标对象与代理对象都要维护，这违反了<a href="https://blog.csdn.net/weixin_45267102/article/details/106630885" target="_blank" rel="noopener">开闭原则</a>。</p></blockquote><h4 id="2-动态代理-JDk代理"><a href="#2-动态代理-JDk代理" class="headerlink" title="2.动态代理-JDk代理"></a>2.动态代理-JDk代理</h4><h5 id="2-1-JDK代理"><a href="#2-1-JDK代理" class="headerlink" title="2.1 JDK代理"></a>2.1 JDK代理</h5><blockquote><p>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。</p><p>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象，也叫JDK 代理或接口代理。</p><p>代理类所在包<code>java.lang.reflect.Proxy</code>JDK 实现代理只需要使用 <code>newProxyInstance 方法</code>,但是该方法需要<code>接收三个参数</code>，完整的写法是： <code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code></p><p><code>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</code></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200630133133714.png" alt="image-20200630133133714"></p></blockquote><h5 id="2-2-代码实现之"><a href="#2-2-代码实现之" class="headerlink" title="2.2 代码实现之"></a>2.2 代码实现之</h5><h6 id="接口ITeacherDao-1"><a href="#接口ITeacherDao-1" class="headerlink" title="接口ITeacherDao"></a>接口ITeacherDao</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 授课方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="被代理对象TeacherDao-1"><a href="#被代理对象TeacherDao-1" class="headerlink" title="被代理对象TeacherDao"></a>被代理对象TeacherDao</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 老师授课中.... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理对象工厂类ProxyFactory"><a href="#代理对象工厂类ProxyFactory" class="headerlink" title="代理对象工厂类ProxyFactory"></a>代理对象工厂类ProxyFactory</h6><blockquote><p><code>private Object target;</code> 维护一个目标对象 target</p><p><code>public Object getProxyInstance();</code> 给目标对象生成一个代理对象。</p><ul><li><pre><code class="java"><span class="comment">// 注意这是Proxy类中的静态方法</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(</span></span><span class="function"><span class="params">    ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span><span class="function"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  1. &#96;ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定&#96;</span><br><span class="line">  2. &#96;Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型&#96;</span><br><span class="line">  3. &#96;InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入&#96;</span><br><span class="line">  4. 其中使用到了Java中的反射中的一些方法，如果对反射不太了解可以看一下这篇文章：[《 Java基础之深入理解反射》](https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45267102&#x2F;article&#x2F;details&#x2F;107009536)</span><br><span class="line"></span><br><span class="line">~~~~java</span><br><span class="line">public class ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 维护一个目标对象、Object</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造器、对target进行初始化</span><br><span class="line">public ProxyFactory(Object target) &#123;</span><br><span class="line">this.target &#x3D; target;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给目标对象生成一个代理对象</span><br><span class="line">public Object getProxyInstance() &#123;</span><br><span class="line">       </span><br><span class="line">return Proxy.newProxyInstance(</span><br><span class="line">           target.getClass().getClassLoader(), </span><br><span class="line">target.getClass().getInterfaces(), </span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">               @Override</span><br><span class="line">               public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                   System.out.println(&quot;JDK代理开始...&quot;);</span><br><span class="line">                   &#x2F;&#x2F; 反射机制调用目标对象的方法</span><br><span class="line">                   Object returnVal &#x3D; method.invoke(target, args);</span><br><span class="line">                   System.out.println(&quot;JDK代理提交...&quot;);</span><br><span class="line">                   return returnVal;</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br><span class="line">       ); </span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">#### 3. 动态代理-Cglib 代理</span><br><span class="line"></span><br><span class="line">##### 3.1 Cglib 代理</span><br><span class="line"></span><br><span class="line">1. 静态代理和 JDK 代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个 单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-这就是 Cglib  代理。</span><br><span class="line">2. Cglib代理也叫作&#96;子类代理&#96;，&#96;它是在内存中构建一个子类对象从而实现对目标对象功能扩展&#96;, 有些书也将Cglib代理归属到动态代理。</span><br><span class="line">3. Cglib 是一个强大的高性能的代码生成包，它可以在运行期扩展 java 类与实现 java 接口。它广泛的被许多 AOP 的框架使用，例如 SpringAOP，实现方法拦截。</span><br><span class="line">4. 在 AOP 编程中如何选择代理模式：</span><br><span class="line">   1. 目标对象需要实现接口，用 JDK 代理</span><br><span class="line">   2. 目标对象不需要实现接口，用 Cglib 代理</span><br><span class="line">5. Cglib 包的底层是通过使用&#96;字节码处理框架 ASM&#96; 来转换字节码并生成新的类。</span><br><span class="line"></span><br><span class="line">&#96;将前面的案例用 Cglib 代理模式实现&#96;</span><br><span class="line"></span><br><span class="line">![image-20200630140037455](https:&#x2F;&#x2F;oss-blogs.oss-cn-hangzhou.aliyuncs.com&#x2F;blogs&#x2F;itbuild&#x2F;JavaSE-设计模式&#x2F;image-20200630140037455.png)</span><br><span class="line"></span><br><span class="line">##### 3.2 代码实现之</span><br><span class="line"></span><br><span class="line">###### 导入依赖</span><br><span class="line"></span><br><span class="line">~~~~xml</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;net.sourceforge.cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;com.springsource.net.sf.cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.2.0&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">###### 被代理对象TeacherDao</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class TeacherDao &#123;</span><br><span class="line"></span><br><span class="line">  public String teach() &#123;</span><br><span class="line">     System.out.println(&quot; 老师授课中... \r\n 我是cglib代理，不需要实现接口... &quot;);</span><br><span class="line">     return &quot;hello&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></span></code></pre></li></ul></blockquote><h6 id="代理对象工厂类ProxyFactory-1"><a href="#代理对象工厂类ProxyFactory-1" class="headerlink" title="代理对象工厂类ProxyFactory"></a>代理对象工厂类ProxyFactory</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护一个目标对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个代理对象:  是target 对象的代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 创建一个工具类</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="comment">//2. 设置父类</span></span><br><span class="line">enhancer.setSuperclass(target.getClass());</span><br><span class="line"><span class="comment">//3. 设置回调函数</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line"><span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cglib代理模式开始..."</span>);</span><br><span class="line">Object returnVal = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"Cglib代理模式提交..."</span>);</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建目标对象</span></span><br><span class="line">TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"><span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">String res = proxyInstance.teach();</span><br><span class="line">System.out.println(<span class="string">"res="</span> + res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-几种常见的代理模式变体介绍"><a href="#4-几种常见的代理模式变体介绍" class="headerlink" title="4. 几种常见的代理模式变体介绍"></a>4. 几种常见的代理模式变体介绍</h4><blockquote><ol><li><p><code>防火墙代理</code></p><ul><li>内网通过代理穿透防火墙，实现对公网的访问。</li></ul></li><li><p><code>缓存代理</code></p><ul><li>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li></ul></li><li><p><code>远程代理</code></p><ul><li>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</li></ul></li><li><p><code>同步代理：</code>主要使用在多线程编程中，完成多线程间同步工作</p></li></ol></blockquote><h4 id="5-代理模式在Spring中的应用"><a href="#5-代理模式在Spring中的应用" class="headerlink" title="5. 代理模式在Spring中的应用"></a>5. 代理模式在Spring中的应用</h4><blockquote><p><a href="https://blog.csdn.net/weixin_45267102/article/details/106346173" target="_blank" rel="noopener">Spring之AOP前奏</a></p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;便作春江都是泪，流不尽，许多愁。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——秦观《江城子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/13.设计模式-享元模式☆</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%98%86/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%98%86/</id>
    <published>2020-12-19T12:46:34.119Z</published>
    <updated>2020-12-19T12:49:17.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>花城人去今萧索，春梦绕胡沙。</p><p align="right">——赵佶《眼儿媚》</p><a id="more"></a><h2 id="设计模式-享元模式"><a href="#设计模式-享元模式" class="headerlink" title="设计模式-享元模式"></a>设计模式-享元模式</h2><h4 id="1-享元模式概述"><a href="#1-享元模式概述" class="headerlink" title="1. 享元模式概述"></a>1. 享元模式概述</h4><h6 id="1-1-享元模式是什么？"><a href="#1-1-享元模式是什么？" class="headerlink" title="1.1 享元模式是什么？"></a>1.1 享元模式是什么？</h6><blockquote><ol><li><p>享元模式<code>主要用于减少创建对象的数量，以减少内存占用和提高性能。</code>这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p></li><li><p><code>享元模式（Flyweight Pattern） 也叫 蝇量模式：</code> 运用<code>共享技术（共享对象的方式）</code>有效地支持大量细粒度的对象。</p><ul><li>细粒度对象（可以理解为不使用线程池情况下的线程对象） : 是内存中的数量庞大的对象 ，实际使用的数量庞大的对象 ;</li><li>共享对象（可以理解为线程池中的对象） : <ul><li>多个细粒度对象共享的部分数据 ;</li><li>对象缓存池中存储的对象 ;</li></ul></li></ul></li></ol></blockquote><h6 id="1-2-享元模式何时使用？"><a href="#1-2-享元模式何时使用？" class="headerlink" title="1.2 享元模式何时使用？"></a>1.2 享元模式何时使用？</h6><blockquote><ol><li>系统中有大量对象。 </li><li>这些对象消耗大量内存。 </li><li>这些对象的状态大部分可以外部化。 </li><li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 </li><li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li></ol></blockquote><h6 id="1-3-享元模式应用场景？"><a href="#1-3-享元模式应用场景？" class="headerlink" title="1.3 享元模式应用场景？"></a>1.3 享元模式应用场景？</h6><ol start="2"><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个 。</li><li><code>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。</code></li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</li></ol><h4 id="2-内部状态和外部状态"><a href="#2-内部状态和外部状态" class="headerlink" title="2. 内部状态和外部状态"></a>2. 内部状态和外部状态</h4><blockquote><p>使用享元模式时，==注意划分内部状态和外部状态==：</p><ol><li><code>IntrinsicState内部状态 :</code> 有些数据所有的对象都一样 , 显然不能当做对象一致性对比的依据 , 这就是内部状态 ;享元对象共享内部状态</li><li><code>ExtrinsicState外部状态 :</code> 有些数据每个对象都不一样 , 根据该数据确定对象的唯一性 , 相当于 哈希码 , 身份证号 , 档案编号 这一类的数据 , 这就是外部状态 ;每个享元对象的外部状态不同</li></ol></blockquote><h4 id="3-享元模式类图"><a href="#3-享元模式类图" class="headerlink" title="3. 享元模式类图"></a>3. 享元模式类图</h4><blockquote><ul><li><code>Flyweight</code>：享元对象–是产品的抽象类, 同时定义出对象的外部状态和内部状态（抽象类/接口）</li><li><code>ConcreteFlyWeight：</code>是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。</li><li><code>FlyWeightFactory 享元工厂类</code>，用于构建一个池容器(集合)， 同时提供从池中获取对象方法。<ul><li><code>从Client的角度去解释享元工厂类：</code>使用对象时 , 先从对象池中获取对象 , 如果对象池中没有 , 创建一个 , 放入对象池 , 然后再从对象池中获取 。</li></ul></li></ul></blockquote><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br><h4 id="4-享元模式优缺点"><a href="#4-享元模式优缺点" class="headerlink" title="4. 享元模式优缺点"></a>4. 享元模式优缺点</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><blockquote><ol><li>大大较少对象的创建，降低系统的内存，使效率提高。</li></ol></blockquote><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><ol><li>系统的复杂度：<ul><li>需要分类出外部状态和内容状态也就是说将一个类拆解成多个类 ，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</li><li>系统复杂性增加了 ，但是对客户端使用层面来说是简单的。</li></ul></li></ol></blockquote><h4 id="5-享元模式在JDK源码中的应用"><a href="#5-享元模式在JDK源码中的应用" class="headerlink" title="5. 享元模式在JDK源码中的应用"></a>5. 享元模式在JDK源码中的应用</h4><h5 id="String中的体现"><a href="#String中的体现" class="headerlink" title="String中的体现"></a>String中的体现</h5><blockquote><ol><li><p>Java的虚拟机会开辟一个内存区域（叫<code>字符串缓冲池</code>）来存储字符串常量，而通过new创建的字符串对象是存储在堆内存中。</p></li><li><p>当新建一个字符串常量时，首先会从字符串缓冲池中查找，如果找到则返回该常量的引用地址，如果找不到则新建一个字符串常量再返回地址引用。</p></li><li><p>当通过new新建一个字符串对象时，会在堆内存中开辟一个新建的空间，再初始化，即使两个字符串的值是一样的但它们的引用地址是不一样的，属于两个不同的对象。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Integer中的体现"><a href="#Integer中的体现" class="headerlink" title="Integer中的体现"></a>Integer中的体现</h5><blockquote><ol><li>如果 <code>Integer.valueOf(x)</code> ，x 在  <code>-128 -127</code> 直接就是使用享元模式返回，如果不在范围类，则仍然 new。</li><li>在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer, 否则，就直接从缓存池返回。</li><li>valueOf 方法，就使用到享元模式</li><li>如果使用valueOf 方法得到一个Integer 实例，范围在 <code>-128 -127</code> ，执行速度比 new 快。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightInteger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 得到 x 实例，类型 Integer</span></span><br><span class="line">Integer x = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer z = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">System.out.println(<span class="string">"x1==x2 :"</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Integer中的valueOf方法</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Integer静态内部类IntegerCache</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;花城人去今萧索，春梦绕胡沙。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——赵佶《眼儿媚》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/12.设计模式-外观模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.117Z</published>
    <updated>2020-12-19T12:49:17.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>七八个星天外，两三点雨山前。</p><p align="right">——辛弃疾《西江月》</p><a id="more"></a>## 设计模式-外观模式<h4 id="1-案例引出外观模式"><a href="#1-案例引出外观模式" class="headerlink" title="1. 案例引出外观模式"></a>1. 案例引出外观模式</h4><blockquote><p> 影院管理项目，<code>组建一个家庭影院其中包括DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,</code>要求完成使用家庭影院的功能，其过程为：</p><ol><li>直接用遥控器：统筹各设备开关</li><li>开爆<code>米花机Popcorn</code></li><li>放下<code>屏幕Screen</code></li><li>开<code>投影仪Projector</code></li><li>开<code>音响Stereo</code></li><li>开 DVD，选 DVD</li><li>去拿爆米花</li><li>调暗<code>灯光TheaterLight</code></li><li>播放</li><li>观影结束后，关闭各种设备</li></ol><p><code>传统方式解决影院管理</code></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/waiguanmos.jpg" alt="waiguanmos"></p><p>然后再关闭各种设备就完成了，其中的很明显调用的方法太多，我们不方便调用。</p><p><code>传统方式解决影院管理问题分析</code></p><ol><li>在 <code>ClientTest</code> 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程</li><li>不利于在 <code>ClientTest</code> 中，去维护对子系统的操作</li><li>解决思路： 定义一个高层接口，给 子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口。也就是说就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节，这就要使用到<code>设计模式中的外观模式</code>了。</li></ol></blockquote><h4 id="2-外观模式"><a href="#2-外观模式" class="headerlink" title="2. 外观模式"></a>2. 外观模式</h4><h5 id="2-1-外观模式基本介绍"><a href="#2-1-外观模式基本介绍" class="headerlink" title="2.1 外观模式基本介绍"></a>2.1 外观模式基本介绍</h5><blockquote><ol><li><code>外观模式（Facade），也叫“过程模式：</code>外观模式为子系统中的<code>一组接口</code> 提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li>外观模式通过定义一个一致的接口，用 以<code>屏蔽内部子系统的细节，</code>使得 调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。</li></ol></blockquote><h5 id="2-2-外观模式原理类图"><a href="#2-2-外观模式原理类图" class="headerlink" title="2.2 外观模式原理类图"></a>2.2 外观模式原理类图</h5><blockquote><ul><li><code>外观类(Facade):</code> 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象。</li><li><code>调用者(Client):</code> 外观接口的调用者。</li><li><code>子系统的集合：</code>指模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者</li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200624094357543.png" alt="image-20200624094357543"></p><h5 id="2-3-外观模式解决影院管理"><a href="#2-3-外观模式解决影院管理" class="headerlink" title="2.3 外观模式解决影院管理"></a>2.3 外观模式解决影院管理</h5><blockquote><ol><li>外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 <code>pc</code>上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li><li>外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200624095132944.png" alt="image-20200624095132944"></li></ol></blockquote><h5 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4  代码实现"></a>2.4  代码实现</h5><h6 id="创建应用对象"><a href="#创建应用对象" class="headerlink" title="创建应用对象"></a>创建应用对象</h6><blockquote><p><code>播放器DVDPlayer</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DVDPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DVDPlayer</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用单例模式, 使用饿汉式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DVDPlayer instance = <span class="keyword">new</span> DVDPlayer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title">getInstanc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 打开DVD..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 关闭DVD..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 播放电影..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 暂停电影..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>投影仪Projector</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Projector</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Projector</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Projector instance = <span class="keyword">new</span> Projector();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Projector <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 打开投影仪... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 关闭投影仪... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 投影仪正在工作...  "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>音响Stereo</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stereo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Stereo</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Stereo instance = <span class="keyword">new</span> Stereo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stereo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 打开音响... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 关闭音响... "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>爆米花机Popcorn</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popcorn</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Popcorn</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Popcorn instance = <span class="keyword">new</span> Popcorn();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 打开爆米花机..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 关闭爆米花机... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 制作爆米花中..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>屏幕Screen</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line"><span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Screen</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Screen instance = <span class="keyword">new</span> Screen();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 放映结束，升起显示屏..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 开始放映，放下显示屏..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>灯光TheaterLight</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheaterLight</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TheaterLight</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TheaterLight instance = <span class="keyword">new</span> TheaterLight();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TheaterLight <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 打开灯光..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 关闭灯光..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 调暗灯光... "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bright</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 调亮灯光..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="外观类Facade"><a href="#外观类Facade" class="headerlink" title="外观类Facade"></a>外观类Facade</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义各个子系统对象</span></span><br><span class="line"><span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line"><span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line"><span class="keyword">private</span> Stereo stereo;</span><br><span class="line"><span class="keyword">private</span> Projector projector;</span><br><span class="line"><span class="keyword">private</span> Screen screen;</span><br><span class="line"><span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line"><span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line"><span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line"><span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line"><span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line"><span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备工作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开爆米花机，制作爆米花</span></span><br><span class="line">popcorn.on();</span><br><span class="line">popcorn.pop();</span><br><span class="line">        <span class="comment">// 放下屏幕</span></span><br><span class="line">screen.down();</span><br><span class="line">        <span class="comment">// 打开投影仪</span></span><br><span class="line">projector.on();</span><br><span class="line">        <span class="comment">// 打开音响</span></span><br><span class="line">stereo.on();</span><br><span class="line">        <span class="comment">// 打开DVD</span></span><br><span class="line">dVDPlayer.on();</span><br><span class="line">        <span class="comment">// 调暗灯光</span></span><br><span class="line">theaterLight.dim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放DVD</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dVDPlayer.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停DVD</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dVDPlayer.pause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观影结束，关闭各种设备</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭爆米花机</span></span><br><span class="line">popcorn.off();</span><br><span class="line">        <span class="comment">// 打开灯光</span></span><br><span class="line">theaterLight.bright();</span><br><span class="line"><span class="comment">// 升起屏幕</span></span><br><span class="line">        screen.up();</span><br><span class="line">        <span class="comment">// 关闭投影仪</span></span><br><span class="line">projector.off();</span><br><span class="line">        <span class="comment">// 关闭音响</span></span><br><span class="line">stereo.off();</span><br><span class="line">        <span class="comment">// 关闭DVD</span></span><br><span class="line">dVDPlayer.off();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><blockquote><p>Client就是用户，是不是感觉这么复杂的操作用户操作起来感觉很简单，这就是外观模式的力量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">        </span><br><span class="line">homeTheaterFacade.ready();</span><br><span class="line">homeTheaterFacade.play();</span><br><span class="line">homeTheaterFacade.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200624104116030.png" alt="image-20200624104116030"></p><h5 id="2-5-外观模式的细节"><a href="#2-5-外观模式的细节" class="headerlink" title="2.5 外观模式的细节"></a>2.5 外观模式的细节</h5><blockquote><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性。</li><li>外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展。</li><li><code>通过合理的使用外观模式，可以帮我们更好的划分访问的层次。</code></li><li><code>当系统需要进行分层设计时，可以考虑使用 Facade 模式。</code></li><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性。</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;七八个星天外，两三点雨山前。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——辛弃疾《西江月》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/11.设计模式-组合模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.115Z</published>
    <updated>2020-12-19T12:49:16.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>何须浅碧深红色，自是花中第一流。</p><p align="right">——李清照《鹧鸪天》</p><a id="more"></a>## 设计模式-组合模式<h3 id="1-案例引出组合模式"><a href="#1-案例引出组合模式" class="headerlink" title="1. 案例引出组合模式"></a>1. 案例引出组合模式</h3><blockquote><p>编写程序展示一个学校院系结构（使用数据库中的表间关系很容易实现，注意这里是使用Java程序实现）：需求是这样，<code>要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个专业，</code>如下图：</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200623100442489.png" alt="image-20200623100442489"></p><p>传统方式解决上述问题（类图如下）：</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200623100926867.png" alt="image-20200623100926867"></p><p><code>传统方案存在的问题：</code></p><ol><li>将学院看做是学校的子类， 专业是学院的子类，这样实际上是站在组织大小来进行分层次的。</li><li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个专业， 因此这种方案， 不能很好实现的管理的操作，比如对学院、专业的 添加，删除，遍历等。</li><li>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。这就要使用到设计模式中的组合模式。</li></ol></blockquote><h3 id="2-组合模式"><a href="#2-组合模式" class="headerlink" title="2. 组合模式"></a>2. 组合模式</h3><h4 id="2-1-组合模式基本介绍"><a href="#2-1-组合模式基本介绍" class="headerlink" title="2.1 组合模式基本介绍"></a>2.1 组合模式基本介绍</h4><blockquote><ol><li><code>组合模式（Composite Pattern），又叫部分整体模式</code>，它创建了对象组的树形结构，<code>将对象组合成树状结构以表示“ 整体- 部分”的层次关系</code>。</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于<a href="https://blog.csdn.net/weixin_45267102/article/details/106652439" target="_blank" rel="noopener">结构型模式</a>。</li><li><code>组合模式使得 用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。</code></li></ol></blockquote><h4 id="2-2-组合模式类图"><a href="#2-2-组合模式类图" class="headerlink" title="2.2 组合模式类图"></a>2.2 组合模式类图</h4><blockquote><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口。</li><li>Leaf : 在组合中表示叶子节点，叶子节点没有子节点。</li><li>Composite :非叶子节点， 用于存储子部件， 在 Component 接口中实现 子部件的相关操作，比如增加(add),删除。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png" alt="2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a"></p><h4 id="2-3-组合模式解决学校院系展示"><a href="#2-3-组合模式解决学校院系展示" class="headerlink" title="2.3 组合模式解决学校院系展示"></a>2.3 组合模式解决学校院系展示</h4><h5 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h5><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200623103452887.png" alt="image-20200623103452887"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><h6 id="OrganizationComponent"><a href="#OrganizationComponent" class="headerlink" title="OrganizationComponent"></a><code>OrganizationComponent</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line"><span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认实现</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认实现</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.des = des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.des = des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="University-Composite"><a href="#University-Composite" class="headerlink" title="University--Composite"></a><code>University--Composite</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, des);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写add</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">organizationComponents.add(organizationComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写remove</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">organizationComponents.remove(organizationComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line"><span class="comment">//遍历 organizationComponents </span></span><br><span class="line"><span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">organizationComponent.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="College"><a href="#College" class="headerlink" title="College"></a><code>College</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//List 中存放的Department</span></span><br><span class="line">List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, des);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写add</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">organizationComponents.add(organizationComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写remove</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">organizationComponents.remove(organizationComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line"><span class="comment">//遍历 organizationComponents </span></span><br><span class="line"><span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">organizationComponent.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Department"><a href="#Department" class="headerlink" title="Department"></a><code>Department</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, des);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"南京工程学院"</span>, <span class="string">" 中国顶级大学 "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 学院</span></span><br><span class="line">OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">" 计算机学院 "</span>);</span><br><span class="line">OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">" 信息工程学院 "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>, <span class="string">" 软件工程不错 "</span>));</span><br><span class="line">computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程"</span>, <span class="string">" 网络工程不错 "</span>));</span><br><span class="line">computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术"</span>, <span class="string">" 计算机科学与技术是老牌的专业 "</span>));</span><br><span class="line"></span><br><span class="line">infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>, <span class="string">" 通信工程不好学 "</span>));</span><br><span class="line">infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"信息工程"</span>, <span class="string">" 信息工程好学 "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将学院加入到 学校</span></span><br><span class="line">university.add(computerCollege);</span><br><span class="line">university.add(infoEngineercollege);</span><br><span class="line"></span><br><span class="line"><span class="comment">//university.print();</span></span><br><span class="line">infoEngineercollege.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-组合模式在-JDK-Map集合源码体现"><a href="#3-组合模式在-JDK-Map集合源码体现" class="headerlink" title="3 .组合模式在 JDK Map集合源码体现"></a>3 .组合模式在 JDK Map集合源码体现</h3><blockquote><p>Java 的集合类<code>HashMap</code> 就使用了组合模式</p><p><code>HashMap</code>中的静态内部类Node相当于组合模式的中的Leaf 即叶子节点，叶子节点没有子节点。</p><p>Map接口相当于组合模式中的Component对象声明接口，用于访问和管理Component 子部件。</p><p>而<code>HashMap</code>相当于组合模式中的Composite非叶子节点， 用于存储子部件，具体通过两个 方法体现出：</p></blockquote><h5 id="putAll"><a href="#putAll" class="headerlink" title="putAll"></a><code>putAll</code></h5><p> <code>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定映射中的所有映射复制到此映射。这些映射将替换此映射对指定映射中当前键的任何映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><blockquote><p><code>public V put(K key, V value) ;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *将此映射中的指定值与指定键关联。如果映射以前包含键的映射，旧值将被替换。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现了Map及put相关方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>put方法是将单个Node添加到<code>HashMap</code>中，而<code>putAll</code>方法是将一个<code>HashMap</code>放到另一个<code>HashMap</code>中，通过下面的关系映射：</p><ol><li>Node —-&gt;  专业</li><li>put  —-&gt;    院系添加专业</li><li><code>putAll</code> —-&gt;  学校添加院系</li></ol><p>因为put和<code>putAll</code>都是<code>HashMap</code>中的方法，所以<code>HashMap</code>相当于组合模式中的<code>Composite</code>非叶子节点。这样下来就可以理解了，面试的时候又可以吹一波了哈哈哈</p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;何须浅碧深红色，自是花中第一流。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——李清照《鹧鸪天》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/10.设计模式-装饰者模式</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-19T12:46:34.113Z</published>
    <updated>2020-12-19T12:49:16.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>七八个星天外，两三点雨山前。</p><p align="right">——辛弃疾《西江月》</p><a id="more"></a>## 设计模式-装饰者模式<h4 id="1-案例引出装饰者模式"><a href="#1-案例引出装饰者模式" class="headerlink" title="1. 案例引出装饰者模式"></a>1. 案例引出装饰者模式</h4><blockquote><p> 星巴克咖啡订单项目</p><ol><li>咖啡种类：Espresso(意大利浓咖啡)、LongBlack(美式咖啡)、Decaf(无因咖啡)</li><li>调料：Milk、Chocolate。</li><li>要求在扩展新的咖啡种类时，<code>具有良好的扩展性、改动方便、维护方便</code></li><li><code>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</code></li><li>传统实现方式如下：</li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zhuangshizhemoshi.jpg" alt="zhuangshizhemoshi"></p><p><code>传统实现方式分析：</code></p><ol><li>Drink 是一个抽象类，表示抽象饮料。</li><li>description 就是对咖啡的描述, 比如咖啡的名字、受欢迎程度等</li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li><li>Decaf 就是单品咖啡， 继承 Drink, 并实重写 cost方法。</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li>问题： 这样设计会有很多类，当我们增加一个单品咖啡 ， 或者一个新的调料 ， 类的数量就会倍，就会出现<code>类爆炸</code>。</li></ol><p><code>改进传统方案：</code></p><ol><li>前面分析到传统方案 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性：</li><li>说明: milk,chocolate 可以设计为 Boolean,表示是否要添加相应的调料。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zhuangshizhemoshigaijin.jpg" alt="zhuangshizhemoshigaijin"></li><li><code>改进后解决星巴克咖啡订单问题的方案分析</code><ol><li>改进后可以控制类的数量，不至于造成很多的类</li><li><code>在增加或者删除调料种类时，代码的维护量很大</code></li><li>考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int</li><li>下面我们看一下设计模式中的装饰模式，见识一下它的力量…</li></ol></li></ol></blockquote><h4 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2. 装饰者模式"></a>2. 装饰者模式</h4><h5 id="2-1-装饰者模式定义"><a href="#2-1-装饰者模式定义" class="headerlink" title="2.1 装饰者模式定义"></a>2.1 装饰者模式定义</h5><ol><li>装饰者模式： <code>动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性</code>， 装饰者模式也体现了<a href="https://blog.csdn.net/weixin_45267102/article/details/106630885" target="_blank" rel="noopener">开闭原则(ocp)。</a></li><li>这里提到的动态的将新功能附加到对象和 ocp 原则，在后面的应用实例上会以代码的形式体现。</li></ol><h5 id="2-2-装饰者模式原理"><a href="#2-2-装饰者模式原理" class="headerlink" title="2.2 装饰者模式原理"></a>2.2 装饰者模式原理</h5><blockquote><p>装饰者模式就像打包一个快递</p><ul><li><p>主体：比如：陶瓷、衣服，是被装饰者 Component</p></li><li><p>包装：比如：报纸填充、塑料泡沫、纸板、木板，是装饰着Decorator</p></li></ul><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="6b833bc2-517a-4270-8a5e-0a5f6df8cd96"></p><ol><li>Component 主体：比如类似前面的 Drink</li><li>ConcreteComponent 和 Decorator<ol><li>ConcreteComponent：具体的主体，比如前面的各个单品咖啡</li><li>Decorator: 装饰者，比如各调料.</li></ol></li><li>在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</li></ol></blockquote><h5 id="2-3-装饰者模式解决星巴克咖啡订单问题"><a href="#2-3-装饰者模式解决星巴克咖啡订单问题" class="headerlink" title="2.3 装饰者模式解决星巴克咖啡订单问题"></a>2.3 装饰者模式解决星巴克咖啡订单问题</h5><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zszms1.jpg" alt="zszms1"></p><h5 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h5><blockquote><p>结合着上图来看：</p></blockquote><h6 id="抽象类Drink以及其子类"><a href="#抽象类Drink以及其子类" class="headerlink" title="抽象类Drink以及其子类"></a>抽象类Drink以及其子类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类Drink</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"><span class="comment">// 描述</span></span><br><span class="line"><span class="keyword">public</span> String des; </span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.des = des;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算费用的抽象方法</span></span><br><span class="line"><span class="comment">//子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲层Coffee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的单品咖啡ShortBlack</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setDes(<span class="string">" shortblack "</span>);</span><br><span class="line">setPrice(<span class="number">4.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的单品咖啡LongBlack</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setDes(<span class="string">" longblack "</span>);</span><br><span class="line">setPrice(<span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="装饰者Decorator着及其子类☆"><a href="#装饰者Decorator着及其子类☆" class="headerlink" title="装饰者Decorator着及其子类☆"></a>装饰者Decorator着及其子类☆</h6><blockquote><p>关键体现在Decorator这个类中：</p><ol><li><code>Decorator继承Drink类</code></li><li><code>Decorator聚合Drink类</code></li><li><code>Decorator组合Drink类</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 聚合</span></span><br><span class="line"><span class="keyword">private</span> Drink obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.obj = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// getPrice 自己价格</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line"><span class="keyword">return</span> des + <span class="string">" "</span> + getPrice() + <span class="string">" &amp;&amp; "</span> + obj.getDes();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的Decorator， 这里就是调味品Chocolate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(obj);</span><br><span class="line">setDes(<span class="string">" 巧克力 "</span>);</span><br><span class="line">setPrice(<span class="number">3.0f</span>); <span class="comment">// 调味品 的价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的Decorator， 这里就是调味品Milk</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(obj);</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">setDes(<span class="string">" 牛奶 "</span>);</span><br><span class="line">setPrice(<span class="number">2.0f</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试星巴克咖啡下单"><a href="#测试星巴克咖啡下单" class="headerlink" title="测试星巴克咖啡下单"></a>测试星巴克咖啡下单</h6><blockquote><p><code>装饰者模式下的订单：2份巧克力+ 1份牛奶的LongBlack</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 单点一份 LongBlack</span></span><br><span class="line">Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">System.out.println(<span class="string">"费用1="</span> + order.cost());</span><br><span class="line">System.out.println(<span class="string">"描述="</span> + order.getDes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订单 order 加入一份牛奶</span></span><br><span class="line">order = <span class="keyword">new</span> Milk(order);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"order 加入一份牛奶 费用 ="</span> + order.cost());</span><br><span class="line">System.out.println(<span class="string">"order 加入一份牛奶 描述 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 订单 order 加入一份巧克力</span></span><br><span class="line"></span><br><span class="line">order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力  费用 ="</span> + order.cost());</span><br><span class="line">System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力 描述 = "</span> + order.getDes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-装饰者模式在-JDK-IO源码分析"><a href="#3-装饰者模式在-JDK-IO源码分析" class="headerlink" title="3. 装饰者模式在 JDK  IO源码分析"></a>3. 装饰者模式在 JDK  IO源码分析</h4><blockquote><p>Java 的 IO 结构，FilterInputStream 就是一个装饰者，源码如下，通过源码我们发现FilterInputStream与我们之前的Decorator有以下相同特征：</p><ol><li><code>FilterInputStream装饰者继承InputStream</code></li><li><code>FilterInputStream装饰者聚合InputStream</code></li><li><code>FilterInputStream装饰者组合InputStream</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要过滤的输入流。这里使用聚合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过将参数赋值给字段this来创建FilterInputStream。以便记住以后使用。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是JDK IO源码InputStram中的源码的UML类图，你只要了解FilterInputStream类与抽象类InputStream之间的关系（继承，组合，聚合），然后就很容易理解了。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200622133655988.png" alt="image-20200622133655988"></p><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;七八个星天外，两三点雨山前。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——辛弃疾《西江月》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-设计模式/1.设计模式基础之UML类图</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/</id>
    <published>2020-12-19T12:46:34.105Z</published>
    <updated>2020-12-19T12:49:16.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>渐写到别来，此情深处，红笺为无色。</p><p align="right">——晏几道《思远人》</p><a id="more"></a><h2 id="设计模式基础之UML–类图"><a href="#设计模式基础之UML–类图" class="headerlink" title="设计模式基础之UML–类图"></a>设计模式基础之<code>UML</code>–类图</h2><h4 id="了解UML图"><a href="#了解UML图" class="headerlink" title="了解UML图"></a>了解UML图</h4><blockquote><p><code>UML——Unified modeling language UML (统一建模语言)</code>，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。</p><p><code>UML</code> 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等。</p><p>画 <code>UML</code> 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，<code>UML</code> 图分类</p><ol><li>用例图(use case)</li><li>静态结构图： 类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li></ol><p>类图是描述类与类之间的关系的，是 <code>UML</code> 图中最核心的，在学习设计模式时，我们必然会接触到<code>UML</code>图中的类图，所以下面我们详细了解一下UML的类图，如果你对UML图感兴趣，可以看一下这篇文章–</p><p><a href="https://blog.csdn.net/weixin_33860553/article/details/93969452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">UML学习入门就这一篇文章</a>。</p></blockquote><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><blockquote><p>用于描述系统中的 类( 对象) 本身的组成和类( 对象) 之间的各种静态关系。<br><code>类之间的关系： 依赖、泛化（继承）、实现、关联、聚合与组合。</code></p></blockquote><h5 id="1-idea查看类图的方法"><a href="#1-idea查看类图的方法" class="headerlink" title="1. idea查看类图的方法"></a>1. idea查看类图的方法</h5><blockquote><p>首先需要进行以下设置(也不是必须的，不建议设置):</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608095732011.png" alt="image-20200608095732011"></p><p>使用<code>Ctrl  + ALT + U</code>查看类图，下面这个就没有进行上面设置生成的类图这样结构很清晰，因为一个类中的方法和属性往往有很多，所以添加生成的类图比较臃肿…</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608095900858.png" alt="image-20200608095900858"></p><p>最后idea这样只能查看类图，如果进行软件功能设计，你可以使用一些绘制类图的工具，比如<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>（可视化编辑）、<code>draw.io</code>（可视化编辑）、<code>PlantUML</code>(代码生成)等。</p></blockquote><h5 id="2-类图–依赖关系（Dependence）"><a href="#2-类图–依赖关系（Dependence）" class="headerlink" title="2. 类图–依赖关系（Dependence）"></a>2. 类图–依赖关系<code>（Dependence）</code></h5><blockquote><p>只要是在 类中用到了对方，那么他们之间就存在依赖关系。</p><ol><li>类中用到了对方</li><li>如果是 类的成员属性</li><li>如果是 方法的返回类型</li><li>是方法 接收的参数类型</li><li>方法中使用到</li></ol><p>出现以上五种情况，类之间就存在依赖关系，由此可见类与类之间产生依赖关系是很常见的。</p><p>由类图表示的话就是：</p><ul><li>在UML中，<code>依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方</code>。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608110525888.png" alt="image-20200608110525888"></li></ul></blockquote><h5 id="3-类图—泛化关系-generalization）"><a href="#3-类图—泛化关系-generalization）" class="headerlink" title="3. 类图—泛化关系(generalization）"></a>3. 类图—泛化关系<code>(generalization）</code></h5><blockquote><p>泛化关系实际上就是继承关系，他是依赖关系的特例。</p><ol><li>如果 A 类继承了 B 类，我们就说 A 和 B 存在泛化关系</li></ol><p>由类图表示的话就是：</p><ul><li>在UML中，<code>泛化关系用带空心三角形的直线来表示</code>。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608105854539.png" alt="image-20200608105854539"></li></ul></blockquote><h5 id="4-类图—实现关系（Implementation）"><a href="#4-类图—实现关系（Implementation）" class="headerlink" title="4. 类图—实现关系（Implementation）"></a>4. 类图—实现关系<code>（Implementation）</code></h5><p>实现关系实际上就是 是 A  类实现 B  接口，他是依赖关系的特例。</p><p>由类图表示的话就是：</p><ul><li>在UML中，<code>实现关系用带空心三角形的虚线来表示</code>。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608110800235.png" alt="image-20200608110800235"></li></ul><h5 id="5-类图—关联关系（Association）"><a href="#5-类图—关联关系（Association）" class="headerlink" title="5. 类图—关联关系（Association）"></a>5. 类图—关联关系<code>（Association）</code></h5><p>关联关系实际上就是类与类之间的联系，他是依赖关系的特例。</p><ol><li>两个相对独立的对象，当一个对象的实例与另外一个对象的特定实例存在固定关系时，这两个对象之间就存在关联关系</li><li>关联具有导航性：即双向关系或单向关系</li><li>关系具有多重性：一个类的实例能够与另一个类的多少个实例相关联。</li></ol><blockquote><p>单向关联</p></blockquote><p><code>A1—&gt;A2</code>: <code>表示A1认识A2，A1知道A2的存在，A1可以调用A2中的方法和属性。</code></p><p>场景：订单和商品，订单中包括商品，但是商品并不了解订单的存在。</p><blockquote><p>双向关联</p></blockquote><p><code>B1—B2</code>: <code>表示B1认识B2，B1知道B2的存在，B1可以调用B2中的方法和属性；同样B2也知道B1的存在，B2也可以调用B1的方法和属性</code>。</p><p>场景：订单和客户，订单属于客户，客户拥有一些特定的订单。</p><h5 id="6-类图—聚合关系（Aggregation）"><a href="#6-类图—聚合关系（Aggregation）" class="headerlink" title="6. 类图—聚合关系（Aggregation）"></a>6. 类图—聚合关系（Aggregation）</h5><p>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。</p><p>由类图表示的话就是：</p><ul><li>在UML中，使用带空心菱形的实线来表示。</li></ul><h5 id="7-类图—组合关系（Composition）"><a href="#7-类图—组合关系（Composition）" class="headerlink" title="7. 类图—组合关系（Composition）"></a>7. 类图—组合关系（Composition）</h5><p>组合关系：也是整体与部分的关系，<code>但是整体与部分不可以分开</code>。<br>在程序中我们定义实体：</p><ol><li><code>Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</code></li><li>但是如果在程序中 Person 实体中定义了对 <code>IDCard</code> 进行级联删除，即删除 Person 时连同 <code>IDCard</code> 一起删除，那<br>么 <code>IDCard</code> 和 Person 就是组合了。</li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200608113721215.png" alt="image-20200608113721215"></p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><blockquote><p>UML虽然不是一门程序设计语言，但他的重要性是不可忽视的。他的重要性主要体现在：</p><ol><li>使复杂的软件设计更为简单，也能够实现像<code>OOP（面向对象编程）</code>这一类被广泛应用的概念；</li><li>用理解起来可能更容易的图来描述，避免了大量的文字；</li><li>使表达和交流概念或系统结构变得更容易；</li><li>在一张图中就能够描绘出整个系统；</li><li><code>程序员实用类图来描述实际需求时，可让问题更加清晰明了，实现起来更容易。</code></li></ol><p>后面会总结设计模式七大原则，继而通过23种设计模式来探究面向对象语言的精髓。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;渐写到别来，此情深处，红笺为无色。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《思远人》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-设计模式" scheme="http://www.itbuild.cn/categories/JavaSE-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/8.JDK8新特性--Stream API</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/8.JDK8%E6%96%B0%E7%89%B9%E6%80%A7--Stream%20API/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/8.JDK8%E6%96%B0%E7%89%B9%E6%80%A7--Stream%20API/</id>
    <published>2020-12-19T10:57:43.927Z</published>
    <updated>2020-12-19T11:56:30.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欲将沉醉换悲凉。清歌莫断肠。</p><p align="right">——晏几道《阮郎归》</p><a id="more"></a><h2 id="JDK8新特性–Stream-API"><a href="#JDK8新特性–Stream-API" class="headerlink" title="JDK8新特性–Stream API"></a>JDK8新特性–Stream API</h2><h3 id="1-Stream简介"><a href="#1-Stream简介" class="headerlink" title="1. Stream简介"></a>1. Stream简介</h3><blockquote><ol><li>Java8中有两大最为重要的改变。<code>第一个是 Lambda  表达式</code>；另外一个则是 Stream API。</li><li><code>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中</code>。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li><li><code>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</code> 使用Stream API 对集合数据进行操作，就<code>类似于使用 SQL 执行的数据库查询</code>。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li><li><code>为什么要使用Stream API呢？</code><ol><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</li><li>==Stream 和 Collection 集合的区别：==<code>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</code></li></ol></li><li><code>什么是 Stream？</code><ol><li>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。==“集合讲的是数据，Stream讲的是计算！“==</li><li>==注意：==<ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol></li></ol></li></ol></blockquote><h3 id="2-Stream的操作三个步骤"><a href="#2-Stream的操作三个步骤" class="headerlink" title="2. Stream的操作三个步骤"></a>2. Stream的操作三个步骤</h3><blockquote><ol><li>==创建 Stream==<ul><li>一个数据源（如：集合、数组），获取一个流。</li></ul></li><li>==中间操作==<ul><li>一个中间操作链，对数据源的数据进行处理。</li></ul></li><li>==终止操作（终端操作）==<ul><li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用。</li></ul></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201114200719472.png" alt="image-20201114200719472"></p><blockquote><p>测试数据：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title">getEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"马化腾"</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">"马云"</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">"刘强东"</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">"雷军"</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">"李彦宏"</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1006</span>, <span class="string">"比尔盖茨"</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1007</span>, <span class="string">"任正非"</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1008</span>, <span class="string">"扎克伯格"</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Employee</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee&#123;"</span> + <span class="string">"id="</span> + id + <span class="string">", name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">", salary="</span> + salary + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Employee employee = (Employee) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != employee.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age != employee.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(employee.salary, salary) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(employee.name) : employee.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        temp = Double.doubleToLongBits(salary);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-创建Stream"><a href="#2-1-创建Stream" class="headerlink" title="2.1 创建Stream"></a>2.1 创建Stream</h4><h6 id="创建-Stream方式一：通过集合"><a href="#创建-Stream方式一：通过集合" class="headerlink" title="创建 Stream方式一：通过集合"></a>创建 Stream方式一：通过集合</h6><blockquote><p>JDK8中的 Collection 接口被扩展，提供了两个获取流的方法：</p><ul><li><code>default Stream&lt;E&gt; stream() :  返回一个顺序流。</code></li><li>default Stream<E> parallelStream() :  返回一个并行流。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建 Stream方式一：通过集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">       <span class="comment">// default Stream&lt;E&gt; stream() :  返回一个顺序流。</span></span><br><span class="line">       Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// default Stream&lt;E&gt; parallelStream() :  返回一个并行流。</span></span><br><span class="line">       Stream&lt;Employee&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式二：通过数组"><a href="#创建-Stream方式二：通过数组" class="headerlink" title="创建 Stream方式二：通过数组"></a>创建 Stream方式二：通过数组</h6><blockquote><p>JDK8中的 <code>Arrays 的静态方法 stream()</code> 可以获取数组流：<code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array):</code>  返回一个流重载形式，能够处理对应基本类型的数组：</p><ol><li><code>public static IntStream stream(int[] array)</code></li><li><code>public static LongStream stream(long[] array)</code></li><li><code>public static DoubleStream stream(double[] array)</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式二：通过数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">    Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tom"</span>);</span><br><span class="line">    Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">"Jerry"</span>);</span><br><span class="line">    Employee[] emps = <span class="keyword">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class="line">    Stream&lt;Employee&gt; employeeStream = Arrays.stream(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式三：通过Stream的of"><a href="#创建-Stream方式三：通过Stream的of" class="headerlink" title="创建 Stream方式三：通过Stream的of()"></a>创建 Stream方式三：通过Stream的of()</h6><blockquote><ol><li><code>可以调用Stream类静态方法 of(), 通过显示值创建一个流</code>。它可<code>以接收任意数量的参数。</code></li><li>public static<T> Stream<T> of(T… values) : </li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式三：通过Stream的of()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式四：创建无限流"><a href="#创建-Stream方式四：创建无限流" class="headerlink" title="创建 Stream方式四：创建无限流"></a>创建 Stream方式四：创建无限流</h6><blockquote><p>可以使用<code>静态方法 Stream.iterate() 和 Stream.generate()</code>,创建无限流。</p><ol><li>迭代<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li></ul></li><li>生成<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式四：创建无限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// generate遍历前十个偶数</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>,t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate生成十个随机数</span></span><br><span class="line">    Stream.generate(() -&gt; Math.random()).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-中间操作"><a href="#2-2-中间操作" class="headerlink" title="2.2 中间操作"></a>2.2 中间操作</h4><blockquote><p><code>多个 中间操作可以连接起来形成一个 流水线，除非流水线上触发终止操作，否则 中间操作不会执行任何的处理！而在 终止操作时一次性全部处理，称为“惰性求值”。</code></p></blockquote><h6 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201114203553549.png" alt="image-20201114203553549"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 筛选与切片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.filter()-----------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">// 练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">    stream.filter(e -&gt; e.getSalary()&gt;<span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.limit()-----------"</span>);</span><br><span class="line">    <span class="comment">// limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">    list.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.skip()-----------"</span>);</span><br><span class="line">    <span class="comment">// skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。</span></span><br><span class="line">    <span class="comment">// 若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">    list.stream().skip(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.distinct()-----------"</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，<br>并将其映射成一个新的元素。</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，<br/>然后把所有流连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------map()-------------------"</span>);</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">    <span class="comment">// map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">    namesStream.filter(e -&gt; e.length()&gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2：</span></span><br><span class="line">    <span class="comment">// list.stream().map(StreamAPITest2::fromStringToStream);</span></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(str -&gt; fromStringToStream(str));</span><br><span class="line">    streamStream.forEach(s -&gt; &#123;</span><br><span class="line">        s.forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------------flatMap()-------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">    Stream&lt;Character&gt; characterStream = list.stream().flatMap(str -&gt; fromStringToStream(str));</span><br><span class="line">    characterStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character c:str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了更好地理解map()和flatMap()</span></span><br><span class="line"><span class="comment"> *      map()更像add()</span></span><br><span class="line"><span class="comment"> *      flatMap()更像addAll()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list2.add(<span class="number">4</span>);</span><br><span class="line">    list2.add(<span class="number">5</span>);</span><br><span class="line">    list2.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list1.add(list2);</span></span><br><span class="line">    list1.addAll(list2);</span><br><span class="line">    System.out.println(list1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><table><thead><tr><th>方法</th><th>描述<br/></th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，其中按自然顺序排序<br/></td></tr><tr><td><code>sorted(Comparator com)</code></td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"--------sorted()——自然排序--------"</span>);</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">66</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">77</span>, -<span class="number">22</span>, <span class="number">7</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.lang.ClassCastException: cn.justweb.methody.Employee cannot be cast to java.lang.Comparable</span></span><br><span class="line">    <span class="comment">// 抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line">    <span class="comment">// List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line">    <span class="comment">// employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------sorted(Comparator com)——定制排序------"</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    employees.stream().sorted((e1, e2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> ageValue = Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">        <span class="keyword">if</span> (ageValue != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ageValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(e1.getSalary(), e2.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-终止操作"><a href="#2-3-终止操作" class="headerlink" title="2.3 终止操作"></a>2.3 终止操作</h4><blockquote><ol><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void </li><li>流进行了终止操作后，不能再次使用。</li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109700686" target="_blank" rel="noopener">Optional类</a></li></ol></blockquote><h6 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115085705510.png" alt="image-20201115085705510"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配与查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------allMatch(Predicate p)——检查是否匹配所有元素。-----------"</span>);</span><br><span class="line">    <span class="comment">//练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">    <span class="keyword">boolean</span> result1 = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">    System.out.println(<span class="string">"result1 = "</span> + result1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------anyMatch(Predicate p)——检查是否至少匹配一个元素。-----------"</span>);</span><br><span class="line">    <span class="comment">// 练习：是否存在员工的工资大于 8000</span></span><br><span class="line">    <span class="keyword">boolean</span> result2 = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">8000</span>);</span><br><span class="line">    System.out.println(<span class="string">"result2 = "</span> + result2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"----------noneMatch(Predicate p)——检查是否没有匹配的元素。-----------"</span>);</span><br><span class="line">    <span class="comment">//练习：是否存在员工姓“雷”</span></span><br><span class="line">    <span class="keyword">boolean</span> result3 = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">"雷"</span>));</span><br><span class="line">    System.out.println(<span class="string">"result3 = "</span> + result3);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"----------findFirst——返回第一个元素-----------"</span>);</span><br><span class="line">    Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">    <span class="comment">// any = Optional[Employee&#123;id=1006, name='比尔盖茨', age=42, salary=9500.43&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">"first = "</span> + first);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------findAny——返回当前流中的任意元素-----------"</span>);</span><br><span class="line">    Optional&lt;Employee&gt; any = employees.parallelStream().findAny();</span><br><span class="line">    <span class="comment">// any = Optional[Employee&#123;id=1001, name='马化腾', age=34, salary=6000.38&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">"any = "</span> + any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115091214399.png" alt="image-20201115091214399"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配与查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">    <span class="keyword">long</span> count = employees.stream().count();</span><br><span class="line">    System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max(Comparator c)——返回流中最大值</span></span><br><span class="line">    <span class="comment">// 练习：返回最高的工资：</span></span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; max = salaryStream.max((e1, e2) -&gt; Double.compare(e1, e2));</span></span><br><span class="line">    Optional&lt;Double&gt; max = salaryStream.max(Double::compare);</span><br><span class="line">    System.out.println(<span class="string">"max = "</span> + max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// min(Comparator c)——返回流中最小值</span></span><br><span class="line">    <span class="comment">// 练习：返回最低工资的员工</span></span><br><span class="line">    Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(<span class="string">"min = "</span> + min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forEach(Consumer c)——内部迭代</span></span><br><span class="line">    employees.parallelStream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h6><blockquote><p><code>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google用它来进行网络搜索而出名。</code></p></blockquote><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)<br/></td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td>reduce(BinaryOperator b)<br/></td><td>可以将流中元素反复结合起来，得到一个值。返回 <code>Optional&lt;T&gt;</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归约</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">    <span class="comment">// 练习1：计算1-10的自然数的和</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Integer result1 = list.stream().reduce(0, (e1, e2) -&gt; Integer.sum(e1, e2));</span></span><br><span class="line">    Integer result1 = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">// result1 = 55</span></span><br><span class="line">    System.out.println(<span class="string">"result1 = "</span> + result1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2：计算公司所有员工工资的总和</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line">    <span class="comment">// Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; result2 = salaryStream.reduce((e1, e2) -&gt; Double.sum(e1, e2));</span></span><br><span class="line">    Optional&lt;Double&gt; result2 = salaryStream.reduce((e1, e2) -&gt; e1 + e2);</span><br><span class="line">    System.out.println(<span class="string">"result2 = "</span> + result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h6><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td><code>collect(Collector c)</code></td><td>将流转换为其他形式。接收一个 Collector接口<br/>的实现，用于给Stream中元素做汇总的方法。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">// 练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Employee&gt; employeeStream1 = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>);</span><br><span class="line">    List&lt;Employee&gt; list = employeeStream1.collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">"list = "</span> + list);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Employee&gt; employeeStream2 = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>);</span><br><span class="line">    Set&lt;Employee&gt; set = employeeStream2.collect(Collectors.toSet());</span><br><span class="line">    System.out.println(<span class="string">"set = "</span> + set);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</li><li>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115094432477.png" alt="image-20201115094432477"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115094451544.png" alt="image-20201115094451544"></p><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;欲将沉醉换悲凉。清歌莫断肠。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《阮郎归》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/7.Map接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.925Z</published>
    <updated>2020-12-19T11:56:30.441Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>黯相望。断鸿声里，立尽斜阳。</p><p align="right">——柳永《玉蝴蝶》</p><a id="more"></a><h1 id="Map接口及其实现类"><a href="#Map接口及其实现类" class="headerlink" title="Map接口及其实现类"></a>Map接口及其实现类</h1><h2 id="1-Map接口介绍"><a href="#1-Map接口介绍" class="headerlink" title="1. Map接口介绍"></a>1. Map接口介绍</h2><blockquote><ol><li>现实生活中，我们常会看到这样的一种集合：<code>IP</code>地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种<code>一一对应</code>的关系，就叫做映射。<code>Java</code>提供了专门的集合类用来存放这种对象关系的对象，即 <code>java.util.Map</code> 接口。</li><li>Map与Collection并列存在。用于保存具有<code>映射关系的数据:key-value。</code></li><li>Map 中的 key 和 value 都可以是任何引用类型的数据</li><li><code>Map 中的 key 用Set来存放， 不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</code><ul><li><code>常用String类作为Map的“键”。</code></li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113172115578.png" alt="image-20201113172115578"></li></ul></li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li><li>Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</li><li>Map接口的常用实现类：<code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code>和<code>Properties</code>。<code>其中HashMap是 Map 接口使用频率最高的实现类</code></li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/20201113230328581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI2NzEwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-Map接口中常用方法"><a href="#2-Map接口中常用方法" class="headerlink" title="2. Map接口中常用方法"></a>2. Map接口中常用方法</h2><h4 id="元素的添加-、-删除、修改操作"><a href="#元素的添加-、-删除、修改操作" class="headerlink" title="元素的添加 、 删除、修改操作"></a>元素的添加 、 删除、修改操作</h4><blockquote><p><code>Object put(Object key,Object value)：</code>将指定key-value<code>添加到(或修改)</code>当前map对象中。</p><p><code>void putAll(Map m):</code>将m中的所有key-value对存放到当前map中。</p><p><code>Object remove(Object key)：</code>移除指定key的key-value对，并返回value。</p><p><code>void clear()：</code>清空当前map中的所有数据。</p></blockquote><h4 id="元素查询的操作"><a href="#元素查询的操作" class="headerlink" title="元素查询的操作"></a>元素查询的操作</h4><blockquote><p><code>Object get(Object key)：</code>获取指定key对应的value。</p><p><code>boolean containsKey(Object key)：</code>是否包含指定的key。</p><p><code>boolean containsValue(Object value)：</code>是否包含指定的value。</p><p><code>int size()：</code>返回map中key-value对的个数。</p><p><code>boolean isEmpty()：</code>判断当前map是否为空。</p><p><code>boolean equals(Object obj)：</code>判断当前mp和参数对象obj是否相等。</p></blockquote><h4 id="遍历Map的三种方式☆"><a href="#遍历Map的三种方式☆" class="headerlink" title="遍历Map的三种方式☆"></a>遍历Map的三种方式☆</h4><blockquote><p><code>public Set&lt;K&gt; keySet()</code> : 获取Map集合中所有的键，存储到Set集合中。</p><ul><li><p>获取<code>Map</code>中所有的键，由于键是唯一的，所以返回一个<code>Set</code>集合存储所有的键。方法提示: <code>keyset()</code></p></li><li><p>遍历键的<code>Set</code>集合，得到每一个键。</p></li><li><p>根据键，获取键所对应的值。方法提示: <code>get(K key)</code></p></li></ul><p><code>Collection values()：</code>返回所有value构成的Collection集合</p><p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p><ul><li><p>我们已经知道， <code>Map</code> 中存放的是两种对象，一种称为key(键)，一种称为<code>value</code>(值)，它们在在 <code>Map</code> 中是一一对应关系，这一对对象又称做 <code>Map</code> 中的一个 <code>Entry</code>(项) 。 <code>Entry</code> 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 <code>Map</code> 集合时，就可以从每一个键值对（ <code>Entry</code> ）对象中获取对应的键与对应的值。既然<code>Entry</code>表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p></li><li><p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p><ul><li><p>public K getKey() ：获取Entry对象中的键。</p></li><li><p>public V getValue() ：获取Entry对象中的值。</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/13 17:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 集合初始化时，指定集合初始值大小</span></span><br><span class="line">        <span class="comment">// 说明:HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//map.put(..,..)省略</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map的所有key:"</span>);</span><br><span class="line">        <span class="comment">// HashSet</span></span><br><span class="line">        Set keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"-&gt;"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map的所有的value："</span>);</span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        Iterator iter = values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map所有的映射关系："</span>);</span><br><span class="line">        <span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line">        Set mappings = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) mapping;</span><br><span class="line">            System.out.println(<span class="string">"key是："</span> + entry.getKey() + <span class="string">"，value是："</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Map接口的实现类"><a href="#3-Map接口的实现类" class="headerlink" title="3. Map接口的实现类"></a>3. Map接口的实现类</h2><h3 id="3-1-HashMap集合"><a href="#3-1-HashMap集合" class="headerlink" title="3.1 HashMap集合"></a>3.1 HashMap集合</h3><blockquote><ol><li><code>HashMap是 Map 接口 使用频率最高的实现类。</code></li><li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li><li><code>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()。</code></li><li>所有的value构成的集合是Collection:无序的、可以重复的。<code>所以，value所在的类要重写：equals()。</code></li><li>==一个key-value构成一个entry==</li><li>所有的entry构成的集合是Set:无序的、不可重复的</li><li>HashMap  <code>判断两个 key  相等的标准是</code>：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。<ul><li>因为key不允许有重复。</li></ul></li><li>HashMap  <code>判断两个 value 相等的标准是</code>：两个 value 通过 equals() 方法返回 true。</li></ol></blockquote><h5 id="HashMap源码中的重要常量☆"><a href="#HashMap源码中的重要常量☆" class="headerlink" title="HashMap源码中的重要常量☆"></a>HashMap源码中的重要常量☆</h5><blockquote><ol><li><p><code>DEFAULT_INITIAL_CAPACITY :</code> HashMap的默认容量，16</p></li><li><p><code>MAXIMUM_CAPACITY ：</code> HashMap的最大支持容量，2^30</p></li><li><p><code>DEFAULT_LOAD_FACTOR ：</code>HashMap的默认加载因子0.75</p></li><li><p><code>TREEIFY_THRESHOLD ：</code>Bucket中链表长度大于该默认值8，转化为红黑树</p></li><li><p><code>UNTREEIFY_THRESHOLD ：</code>Bucket中红黑树存储的Node小于该默认值6，转化为链表。</p></li><li><p><code>MIN_TREEIFY_CAPACITY ：</code>==桶中的Node被树化时最小的hash表容量==。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值<code>（默认为64）</code>至少是TREEIFY_THRESHOLD的4倍。）</p></li><li><p><code>table ：</code>存储元素的数组，总是2的n次幂</p></li><li><p><code>entrySet：</code> 存储具体元素的集</p></li><li><p><code>size ：</code>HashMap中存储的键值对的数量</p></li><li><p><code>modCount ：</code>HashMap扩容和结构改变的次数。</p></li><li><p><code>threshold ：</code>扩容的临界值（吞吐临界值）12=容量*填充因子</p></li><li><p><code>loadFactor：</code> 填充比（负载因子）。</p><ol><li><p>负载因子值的大小，对HashMap有什么影响？</p><ul><li><p>负载因子的大小决定了HashMap的数据密度。</p></li><li><p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</p></li><li><p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p></li><li><p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</p></li></ul></li></ol></li></ol></blockquote><h5 id="HashMap的储存结构☆☆"><a href="#HashMap的储存结构☆☆" class="headerlink" title="HashMap的储存结构☆☆"></a>HashMap的储存结构☆☆</h5><blockquote><ol><li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)。</li><li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</li></ol></blockquote><h6 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113211938573.png" alt="image-20201113211938573"></p><blockquote><ol><li><p>HashMap的内部存储结构其实是 数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p></li><li><p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</p></li><li><p>HashMap静态内部类Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==添加元素的过程：==</p><ol><li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要<code>存储的位置i</code>。</li><li>如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。</li><li>如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value<br>去替换equals为true的entry的value。</li><li>如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li></ol></li><li><p>==HashMap 的扩容：==</p><ol><li>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，<code>而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</code></li><li>那么HashMap 什么时候进行扩容呢 ？<ol><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</li><li>也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，<code>所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</code></li></ol></li></ol></li></ol></blockquote><h6 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113212003964.png" alt="image-20201113212003964"></p><blockquote><ol><li><p>HashMap的内部存储结构其实是 <code>数组+ 链表+ 树</code> 的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的<code>Node数组</code>，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为<br>“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p></li><li><p><code>每个bucket中存储一个元素，即一个Node对象，</code>但每一个Node对象可以带一个引用变量next，用于指向下一个元素，<code>因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，</code>每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。<code>而新添加的元素作为链表的last，或树的叶子结点。</code></p></li><li><p>HashMap的静态内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么HashMap 什么时候进行扩容和树形化呢 ？</p><ol><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</li><li><code>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</code><ul><li>如果不理解这段，可以看一下HashMap源码中的重要常量<code>MIN_TREEIFY_CAPACITY</code>。</li></ul></li></ol></li><li><p>关于映射关系的key 是否可以修改 ？</p><ul><li><p>答案是：不要修改！</p></li><li><p><code>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</code></p></li></ul></li></ol></blockquote><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><blockquote><p><code>JDK1.8相较于之前的变化：</code></p><ol><li>HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组。</li><li><code>当首次调用map.put()时，再创建长度为16的数组。</code></li><li><code>数组为Node类型，在jdk7中称为Entry类型。</code></li><li><code>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）。</code></li><li><code>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</code></li></ol></blockquote><h5 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h5><blockquote><ol><li>每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到<code>map</code>集合中。学生作为键, 家庭住址作为值。</li><li>注意，学生姓名相同并且年龄相同视为同一名学生。</li></ol></blockquote><h6 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试类HashMapTest"><a href="#测试类HashMapTest" class="headerlink" title="测试类HashMapTest"></a>测试类HashMapTest</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">"lisi"</span>,<span class="number">28</span>), <span class="string">"上海"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"wangwu"</span>,<span class="number">22</span>), <span class="string">"北京"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"zhaoliu"</span>,<span class="number">24</span>), <span class="string">"成都"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"zhouqi"</span>,<span class="number">25</span>),<span class="string">"广州"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"wangwu"</span>,<span class="number">22</span>), <span class="string">"南京"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">"....."</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>当给<code>HashMap</code>中存放自定义对象时，如果自定义对象作为<code>key</code>存在，这时要保证对象唯一，必须复写对象的<code>hashCode</code>和<code>equals</code>方法(如果忘记，请回顾<code>HashSet</code>存放自定义对象)。</p></li><li><p>如果要保证<code>map</code>中存放的<code>key</code>和取出的顺序一致，可以使用 <code>java.util.LinkedHashMap</code> 集合来存放。</p></li></ol></blockquote><h5 id="LinkedHashMap集合☆"><a href="#LinkedHashMap集合☆" class="headerlink" title="LinkedHashMap集合☆"></a>LinkedHashMap集合☆</h5><blockquote><ol><li>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</li><li>LinkedHashMap 是 HashMap 的子类，它是链表和哈希表组合的一个数据存储结构。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">        map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰"</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="string">"朱丽倩"</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">" "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邓超 孙俪</span><br><span class="line">李晨 范冰冰</span><br><span class="line">刘德华 朱丽倩</span><br></pre></td></tr></table></figure><h6 id="LinkedHashMap的静态内部类Entry"><a href="#LinkedHashMap的静态内部类Entry" class="headerlink" title="LinkedHashMap的静态内部类Entry"></a>LinkedHashMap的静态内部类Entry</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-TreeMap集合"><a href="#3-2-TreeMap集合" class="headerlink" title="3.2 TreeMap集合"></a>3.2 TreeMap集合</h3><blockquote><ol><li>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li><li>TreeSet底层使用 <a href="https://blog.csdn.net/weixin_45267102/article/details/108424364" target="_blank" rel="noopener">红黑树</a> 结构存储数据。</li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109678514" target="_blank" rel="noopener">TreeMap 的 Key 的排序：</a><ul><li><code>自然排序：</code>TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。</li><li><code>定制排序：</code>创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口</li></ul></li><li><code>TreeMap判断两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</code></li></ol></blockquote><h3 id="3-3-HashTable集合"><a href="#3-3-HashTable集合" class="headerlink" title="3.3 HashTable集合"></a>3.3 HashTable集合</h3><blockquote><ol><li>HashTable是个古老的 Map 实现类，JDK1.0就提供了。<code>不同于HashMap，Hashtable是线程安全的。</code></li><li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li><li><code>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</code></li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li><li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li></ol></blockquote><h5 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h5><blockquote><ol><li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型</p></li><li><p>存取数据时，建议使用<code>setProperty(String key,String value)方法</code>和<code>getProperty(String key)方法。</code></p></li><li><pre><code class="java">Properties pros = <span class="keyword">new</span> Properties();pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>));String user = pros.getProperty(<span class="string">"user"</span>);System.out.println(user);</code></pre></li></ol></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;黯相望。断鸿声里，立尽斜阳。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——柳永《玉蝴蝶》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/6.Set接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/6.Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/6.Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.923Z</published>
    <updated>2020-12-19T11:56:30.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可怜人意，薄于云水，佳会更难重。</p><p align="right">——晏几道《少年游》</p><a id="more"></a><h1 id="Set接口及其实现类"><a href="#Set接口及其实现类" class="headerlink" title="Set接口及其实现类"></a>Set接口及其实现类</h1><h2 id="1-Set接口介绍"><a href="#1-Set接口介绍" class="headerlink" title="1. Set接口介绍"></a>1. Set接口介绍</h2><blockquote><ol><li><code>java.util.Set</code> 接口和 <code>java.util.List</code> 接口一样，同样继承自 <code>Collection</code> 接口，它与<code>Collection</code> 接口中的方法基本一致，并没有对 <code>Collection</code> 接口进行功能上的扩充，只是比<code>Collection</code> 接口更加严格了。</li><li>与 <code>List</code> 接口不同的是， <code>Set</code> 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</li><li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法。</li><li>Set集合取出元素的方式可以采用：迭代器、增强for。</li><li><code>Set</code> 集合有多个子类，这里我们介绍其中的 <code>java.util.HashSet</code> 、 <code>java.util.LinkedHashSet</code>、<code>java.util.TreeSet</code> 这三个集合。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113163538117.png" alt="image-20201113163538117"></p><h2 id="2-Set接口的主要实现类"><a href="#2-Set接口的主要实现类" class="headerlink" title="2. Set接口的主要实现类"></a>2. Set接口的主要实现类</h2><h3 id="2-1-HashSet集合☆"><a href="#2-1-HashSet集合☆" class="headerlink" title="2.1 HashSet集合☆"></a>2.1 HashSet集合☆</h3><blockquote><ol><li><code>java.util.HashSet</code> 是 <code>Set</code> 接口的一个典型实现类，它所存储的<code>元素是不可重复</code>的，<code>集合元素可以为null</code>，<code>线程不安全</code>，并且元素都是<code>无序的</code>(即存取顺序不能保证不一致)。</li><li><code>HashSet</code> 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code> 与 <code>equals</code> 方法。即两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</li><li>对于存放在Set容器中的对象， <code>对应的类一定要重写equals() 和hashCode(Object obj) 方法</code>，以实现对象相等规则 。即： <code>“相等的对象必须具有相等的散列码”</code> 。</li><li><code>java.util.HashSet</code> 底层的实现其实是一个 <code>java.util.HashMap</code> 支持。</li></ol></blockquote><h5 id="哈希值和哈希表"><a href="#哈希值和哈希表" class="headerlink" title="哈希值和哈希表"></a>哈希值和哈希表</h5><blockquote><ol><li>哈希值简介：是JDK根据<code>对象的地址</code>或者<code>字符串</code>或者<code>数字</code>算出来的<code>int类型的数值</code>。</li><li>如何获取哈希值：<code>Object类中的public int hashCode()；返回对象的哈希码值。</code></li><li>哈希值的特点：<ul><li>同一个对象多次调用hashCode()方法返回的哈希值是相同的。</li><li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同。</li></ul></li><li>什么是哈希表呢？哈希表是HashSet集合存储数据的结构</li><li>在<code>JDK1.8</code>之前，哈希表底层采用<code>数组+链表</code>实现，即使用链表处理冲突，同一<code>hash</code>值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即<code>hash</code>值相等的元素较多时，通过<code>key</code>值依次查找的效率较低。<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/14_JKD8%E4%BB%A5%E5%89%8D%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="14_JKD8以前哈希表"></li></ul></li><li>而<code>JDK1.8</code>中，哈希表存储<code>采用数组+链表+红黑树</code>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/15_JKD8%E4%BB%A5%E5%90%8E%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="15_JKD8以后哈希表"></li></ul></li><li><code>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。</code>（16扩容为32，依次为64,128….等）。</li><li>简单的来说，哈希表是由数组+链表+红黑树（<code>JDK1.8</code>增加了红黑树部分）实现的，如下图所示：</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/1563700294020.png" alt="1563700294020"></p><h5 id="HashSet中添加元素的过程"><a href="#HashSet中添加元素的过程" class="headerlink" title="HashSet中添加元素的过程"></a>HashSet中添加元素的过程</h5><blockquote><ol><li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（<code>这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好</code>）</li><li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过<code>链表的方式</code>继续链接。</li></ol></blockquote><h5 id="重写-hashCode-方法的基本原则"><a href="#重写-hashCode-方法的基本原则" class="headerlink" title="重写 hashCode() 方法的基本原则"></a>重写 hashCode() 方法的基本原则</h5><blockquote><ol><li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li><li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</li><li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li></ol></blockquote><h5 id="重写-equals-方法的基本原则"><a href="#重写-equals-方法的基本原则" class="headerlink" title="重写 equals() 方法的基本原则"></a>重写 equals() 方法的基本原则</h5><blockquote><p>以自定义的Student类为例，何时需要重写equals()？</p><ol><li><code>当一个类有自己特有的“逻辑相等”概念,</code>当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li><li>因此，违反了<code>“相等的对象必须具有相等的散列码”</code>。</li><li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。<code>通常参与计算hashCode 的对象的属性也应该参与到equals()。</code></li></ol></blockquote><h5 id="HashSet存储自定义类型元素☆"><a href="#HashSet存储自定义类型元素☆" class="headerlink" title="HashSet存储自定义类型元素☆"></a>HashSet存储自定义类型元素☆</h5><blockquote><p>给<code>HashSet</code>中存放自定义类型元素时，需要重写对象中的<code>hashCode</code>和<code>equals</code>方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建自定义Student类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建集合对象 该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭德纲"</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭麒麟"</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student [name&#x3D;郭德纲, age&#x3D;44]</span><br><span class="line"></span><br><span class="line">Student [name&#x3D;于谦, age&#x3D;43]</span><br><span class="line"></span><br><span class="line">Student [name&#x3D;郭麒麟, age&#x3D;23]</span><br></pre></td></tr></table></figure><blockquote><p><code>Objects.hash(name, age);执行细节如下：</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Object element : a)</span><br><span class="line">           result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedHashSet集合☆"><a href="#LinkedHashSet集合☆" class="headerlink" title="LinkedHashSet集合☆"></a>LinkedHashSet集合☆</h5><blockquote><p>我们知道<code>HashSet</code>保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在<code>HashSet</code>下面有一个子类<code>java.util.LinkedHashSet</code> ，它是链表和哈希表组合的一个数据存储结构。</p><ol><li><code>LinkedHashSet 是 HashSet 的子类。</code></li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是<code>以插入顺序保存的</code>。</li><li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li><li>LinkedHashSet 不允许集合元素重复。</li></ol></blockquote><h3 id="2-2-TreeSet集合"><a href="#2-2-TreeSet集合" class="headerlink" title="2.2 TreeSet集合"></a>2.2 TreeSet集合</h3><blockquote><ol><li><code>TreeSet 是 SortedSet 接口的实现类</code>，TreeSet 可以确保集合元素处于排序状态。</li><li>TreeSet底层使用 <a href="https://blog.csdn.net/cyp331203/article/details/42677833" target="_blank" rel="noopener">红黑树结构存储数据。</a></li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109644829" target="_blank" rel="noopener">可以将元素按照规则进行排序</a>。<ul><li>TreeSet()：根据其元素的<code>自然排序进行排序。</code></li><li>TreeSet(Comparator comparator) ：根据指定的<code>比较器进行排序。</code></li></ul></li><li>特点：<ul><li>有序，查询速度比List快。</li></ul></li></ol></blockquote><h5 id="排序—自然排序"><a href="#排序—自然排序" class="headerlink" title="排序—自然排序"></a>排序—自然排序</h5><blockquote><ol><li><p>自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素<code>按升序(默认情况)排列</code>。</p></li><li><p><code>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口。</code></p></li><li><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</p></li><li><p>Comparable 的典型实现：</p><ul><li><code>BigDecimal、BigInteger</code> 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较。</li><li><code>Character：</code>按字符的 unicode值来进行比较。</li><li><code>Boolean：true</code> 对应的包装类实例大于 false 对应的包装类实例。</li><li><code>String：</code>按字符串中字符的 unicode 值进行比较。</li><li><code>Date、Time：</code>后边的时间、日期比前面的时间、日期大。</li></ul></li><li><p>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p></li><li><p>因为只有相同类的两个实例才会比较大小，所以向 TreeSet  中添加的应该是同一个类的对象。</p></li><li><p><code>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。</code></p></li><li><p>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与<code>compareTo(Object obj)</code> 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 <code>compareTo(Object obj)</code> 方法比较应返回 0。否则，让人难以理解。</p></li></ol></blockquote><h5 id="排序—定制排序"><a href="#排序—定制排序" class="headerlink" title="排序—定制排序"></a>排序—定制排序</h5><blockquote><ol><li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。<ul><li><code>定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</code></li></ul></li><li>利用<code>int compare(T o1,T o2)</code>方法，比较<code>o1</code>和<code>o2</code>的大小：<ul><li><code>如果方法返回正整数，则表示o1大于o2；</code></li><li><code>如果返回0，表示相等；</code></li><li><code>返回负整数，表示o1小于o2。</code></li></ul></li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li><li><code>此时，仍然只能向TreeSet中添加类型相同的对象，否则发生ClassCastException异常。</code></li><li>使用定制排序判断两个元素相等的标准是：通过Comparator比较<code>两个元素返回了0。</code></li></ol></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;可怜人意，薄于云水，佳会更难重。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《少年游》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/5.Collections包装类和Comparator比较器</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/5.Collections%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CComparator%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/5.Collections%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CComparator%E6%AF%94%E8%BE%83%E5%99%A8/</id>
    <published>2020-12-19T10:57:43.920Z</published>
    <updated>2020-12-19T11:56:30.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两情若是久长时，又岂在朝朝暮暮。</p><p align="right">——秦观《鹊桥仙》</p><a id="more"></a>## Collections包装类和Comparator比较器<h3 id="1-Collections包装类"><a href="#1-Collections包装类" class="headerlink" title="1. Collections包装类"></a>1. Collections包装类</h3><blockquote><ol><li>java.util.Collections 是一个包装类。它包含有各种有关集合操作的 <code>静态多态方法</code>。</li><li>此类 <code>不能实例化</code>，就像一 <code>个工具类</code>，服务于Java的Collection框架。 </li><li>他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ol></blockquote><h4 id="1-1-可变参数"><a href="#1-1-可变参数" class="headerlink" title="1.1 可变参数"></a>1.1 可变参数</h4><blockquote><ol><li><p>在<code>JDK1.5</code>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>其实这个书写完全等价与</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</code></p></li><li><p><code>JDK1.5</code>以后。出现了简化操作。==… 用在参数上，称之为可变参数。==</p></li><li><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.justwe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);<span class="comment">// 500</span></span><br><span class="line">        <span class="comment">// 6 7 2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6 7 2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);<span class="comment">// 2148</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成数组 所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">//    public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">//        int sum = 0;</span></span><br><span class="line"><span class="comment">//        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">//            sum += a;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return sum;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: </p><ol><li>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性。</li><li>如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</li></ol></blockquote><h4 id="1-2-Collections常用功能"><a href="#1-2-Collections常用功能" class="headerlink" title="1.2 Collections常用功能"></a>1.2 Collections常用功能</h4><blockquote><p>java.utils.Collections 是集合工具类，用来对集合进行操作。部分方法如下：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :</code>往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) :</code>打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list) :</code>将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) :</code>将集合中元素按照指定规则排序。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素</span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure><h3 id="2-Comparator比较器"><a href="#2-Comparator比较器" class="headerlink" title="2. Comparator比较器"></a>2. Comparator比较器</h3><blockquote><ol><li><p>我们还是先研究 <code>Collections</code>的<code>sort()</code>方法。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序，不过这次存储的是字符串类型。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><blockquote><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p></blockquote><h4 id="1-实现排序的两种方式"><a href="#1-实现排序的两种方式" class="headerlink" title="1. 实现排序的两种方式"></a>1. 实现排序的两种方式</h4><blockquote><p>说到排序了，简单的说就是两个对象之间比较大小，那么在<code>JAVA</code>中提供了两种比较实现的方式:</p><ol><li>一种是比较死板的采用 <code>java.lang.Comparable</code>接口去实现</li><li>一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code> 接口完成。</li></ol></blockquote><h6 id="实现Comparable接口"><a href="#实现Comparable接口" class="headerlink" title="实现Comparable接口"></a>实现Comparable接口</h6><blockquote><p>那么我们采用的 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现<code>Comparable</code>接口完成比较的功能，在<code>String</code>类型上如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class"> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class"> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">                                         </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="使用Comparator比较器"><a href="#使用Comparator比较器" class="headerlink" title="使用Comparator比较器"></a>使用Comparator比较器</h6><blockquote><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><ul><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code> 方法灵活的完成，这个里面就涉及到了<code>Comparator</code>这个接口，位于位于<code>java.util</code>包下，排序是<code>comparator</code>能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</li><li><code>public int compare(String o1, String o2)</code> ：比较其两个参数的顺序。</li><li>两个对象比较的结果有三种：大于，等于，小于。<ul><li><code>如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）</code> </li><li><code>如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</code></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序方法 按照第一个单词的降序</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) ‐ o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><blockquote><p>如果不想使用匿名对象，可以通过下述方式进行排序：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,<span class="keyword">new</span> CompareTwo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTwo</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(o1.getId())-Integer.parseInt(o2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Comparable和Comparator两个接口的区别"><a href="#2-Comparable和Comparator两个接口的区别" class="headerlink" title="2. Comparable和Comparator两个接口的区别"></a>2. Comparable和Comparator两个接口的区别</h4><blockquote><ol><li><code>Comparable：</code>强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，<code>类的compareTo方法被称为它的自然比较方法</code>。<code>只能在类中实现compareTo()一次</code>，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过<code>Collections.sort</code>（和<code>Arrays.sort</code>）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</li><li><code>Comparator：</code>强行对某个对象进行整体排序。可以将<code>Comparator</code> 传递给<code>sort</code>方法（<code>如Collections.sort或Arrays.sort</code>），从而允许在排序顺序上实现精确控制。还可以使用<code>Comparator</code>来控制某些数据结构（如有序<code>set</code>或有序映射）的顺序，或者为那些没有自然顺序的对象<code>collection</code>提供排序。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;两情若是久长时，又岂在朝朝暮暮。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——秦观《鹊桥仙》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/4.List接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/4.List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/4.List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.917Z</published>
    <updated>2020-12-19T11:56:29.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>凝碧旧池头，一听管弦凄切。多少梨园声在，总不堪华发。</p><p align="right">——韩元吉《好事近》</p><a id="more"></a><h1 id="List接口及其实现类"><a href="#List接口及其实现类" class="headerlink" title="List接口及其实现类"></a>List接口及其实现类</h1><h2 id="1-List接口介绍"><a href="#1-List接口介绍" class="headerlink" title="1. List接口介绍"></a>1. List接口介绍</h2><blockquote><ol><li><code>java.util.List</code> 接口继承自 <code>Collection</code> 接口，是单列集合的一个重要分支，习惯性地会将实现了 <code>List</code> 接口的对象称为<code>List</code>集合。</li><li>在<code>List</code>集合与set集合不同<code>允许出现重复的元素</code>，所有的元素是以一种线性方式进行存储的，在程序中可以<code>通过索引来访问集合中的指定元素</code>。另外，<code>List集合还有一个特点就是元素有序，</code>即元素的存入顺序和取出顺序一致。</li><li>JDK API中List接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>。</li></ol></blockquote><h2 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2. List接口中常用方法"></a>2. List接口中常用方法</h2><blockquote><p><code>List</code>作为<code>Collection</code>集合的子接口，不但继承了<a href="https://blog.csdn.net/weixin_45267102/article/details/107350539" target="_blank" rel="noopener">Collection接口</a>中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><p><code>public void add(int index, E element)</code> : 将指定的元素，添加到该集合中的指定位置上。 将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。</p></li><li><p><code>public E get(int index)</code> :返回集合中指定位置的元素。</p></li><li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p></li><li><p><code>public E set(int index, E element)</code> :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">        list.add(<span class="string">"图图"</span>);</span><br><span class="line">        list.add(<span class="string">"小美"</span>);</span><br><span class="line">        list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除指定位置元素 返回被删除元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置 进行 元素替代（改）</span></span><br><span class="line">        <span class="comment">// 修改指定位置元素</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跟size() 方法一起用来遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//还可以使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们学习Colletion体系的时候，<code>发现List集合下有很多集合</code>，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？</p></blockquote><h2 id="3-List的实现类"><a href="#3-List的实现类" class="headerlink" title="3. List的实现类"></a>3. List的实现类</h2><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/LinkedList.png" alt="LinkedList"></p><h3 id="3-1-ArrayList集合☆"><a href="#3-1-ArrayList集合☆" class="headerlink" title="3.1 ArrayList集合☆"></a>3.1 ArrayList集合☆</h3><blockquote><ol><li><code>java.util.ArrayList</code> 集合数据存储的结构是<code>数组结构。元素增删慢，查找快</code>，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 <code>ArrayList</code> 是最常用的集合。</li><li>但是<code>ArrayList</code>并不能完成任何需求，应结合着具体的应用场景和集合的特点进行使用。</li><li><code>ArrayList 的JDK1.8 之前与之后的实现区别？</code><ul><li><code>JDK1.7：ArrayList像饿汉式，</code>直接创建一个初始容量为10的数组。</li><li><code>JDK1.8：ArrayList像懒汉式，</code>一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组。</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/11 18:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        updateList(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[1, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h3><blockquote><ol><li><p><code>java.util.LinkedList</code> 集合数据存储的结构是<code>链表结构。查询慢、但是方便元素添加、删除的集合。</code></p></li><li><p>对于 频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。</p></li><li><p>LinkedList： 双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，<code>定义内部类Node，作为LinkedList中保存数据的基本结构</code>。Node除了保存数据，还定义了两个变量：</p><ul><li><p><code>prev变量</code>记录前一个元素的位置。</p></li><li><p><code>next变量</code>记录下一个元素的位置。</p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/linkedlist.jpg" alt="linkedlist"></p></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedList常用方法"><a href="#LinkedList常用方法" class="headerlink" title="LinkedList常用方法"></a>LinkedList常用方法</h5><blockquote><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而<code>LinkedList</code>提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code> :将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code> :返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code> :移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code> :将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p><code>LinkedList</code>是<code>List</code>的子类，<code>List</code>中的方法<code>LinkedList</code>都是可以使用，这里就不做详细介绍，我们只需要了解<code>LinkedList</code>的特有方法即可。<code>在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">"abc1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList和LinkedList的异同"><a href="#ArrayList和LinkedList的异同" class="headerlink" title="ArrayList和LinkedList的异同"></a>ArrayList和LinkedList的异同</h5><blockquote><p>二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p></blockquote><h3 id="3-2-Vector集合"><a href="#3-2-Vector集合" class="headerlink" title="3.2 Vector集合"></a>3.2 Vector集合</h3><blockquote><ol><li>Vector 是一个古老的集合，<code>JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</code></li><li>在各种List中，最好把ArrayList作为默认选择，当插入、删除频繁时，使用LinkedList。</li><li>Vector总是比ArrayList慢，所以尽量避免使用。</li><li>新增方法：<ul><li><code>void addElement(Object obj)</code></li><li><code>void insertElementAt(Object obj,int index)</code></li><li><code>void setElementAt(Object obj,int index)</code></li><li><code>void removeElement(Object obj)</code></li><li><code>void removeAllElements()</code></li></ul></li></ol></blockquote><h5 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h5><blockquote><p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。<code>正常情况下,大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制</code>。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;凝碧旧池头，一听管弦凄切。多少梨园声在，总不堪华发。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——韩元吉《好事近》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
</feed>
