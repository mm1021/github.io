<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>it❤ld</title>
  
  
  <link href="http://www.itbuild.cn/atom.xml" rel="self"/>
  
  <link href="http://www.itbuild.cn/"/>
  <updated>2020-12-19T11:56:30.536Z</updated>
  <id>http://www.itbuild.cn/</id>
  
  <author>
    <name>DuanChaojie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE-集合/8.JDK8新特性--Stream API</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/8.JDK8%E6%96%B0%E7%89%B9%E6%80%A7--Stream%20API/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/8.JDK8%E6%96%B0%E7%89%B9%E6%80%A7--Stream%20API/</id>
    <published>2020-12-19T10:57:43.927Z</published>
    <updated>2020-12-19T11:56:30.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欲将沉醉换悲凉。清歌莫断肠。</p><p align="right">——晏几道《阮郎归》</p><a id="more"></a><h2 id="JDK8新特性–Stream-API"><a href="#JDK8新特性–Stream-API" class="headerlink" title="JDK8新特性–Stream API"></a>JDK8新特性–Stream API</h2><h3 id="1-Stream简介"><a href="#1-Stream简介" class="headerlink" title="1. Stream简介"></a>1. Stream简介</h3><blockquote><ol><li>Java8中有两大最为重要的改变。<code>第一个是 Lambda  表达式</code>；另外一个则是 Stream API。</li><li><code>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中</code>。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li><li><code>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</code> 使用Stream API 对集合数据进行操作，就<code>类似于使用 SQL 执行的数据库查询</code>。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li><li><code>为什么要使用Stream API呢？</code><ol><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</li><li>==Stream 和 Collection 集合的区别：==<code>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</code></li></ol></li><li><code>什么是 Stream？</code><ol><li>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。==“集合讲的是数据，Stream讲的是计算！“==</li><li>==注意：==<ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol></li></ol></li></ol></blockquote><h3 id="2-Stream的操作三个步骤"><a href="#2-Stream的操作三个步骤" class="headerlink" title="2. Stream的操作三个步骤"></a>2. Stream的操作三个步骤</h3><blockquote><ol><li>==创建 Stream==<ul><li>一个数据源（如：集合、数组），获取一个流。</li></ul></li><li>==中间操作==<ul><li>一个中间操作链，对数据源的数据进行处理。</li></ul></li><li>==终止操作（终端操作）==<ul><li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用。</li></ul></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201114200719472.png" alt="image-20201114200719472"></p><blockquote><p>测试数据：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title">getEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"马化腾"</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">"马云"</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">"刘强东"</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">"雷军"</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">"李彦宏"</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1006</span>, <span class="string">"比尔盖茨"</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1007</span>, <span class="string">"任正非"</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Employee(<span class="number">1008</span>, <span class="string">"扎克伯格"</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Employee</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee&#123;"</span> + <span class="string">"id="</span> + id + <span class="string">", name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">", salary="</span> + salary + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Employee employee = (Employee) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != employee.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age != employee.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(employee.salary, salary) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(employee.name) : employee.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        temp = Double.doubleToLongBits(salary);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-创建Stream"><a href="#2-1-创建Stream" class="headerlink" title="2.1 创建Stream"></a>2.1 创建Stream</h4><h6 id="创建-Stream方式一：通过集合"><a href="#创建-Stream方式一：通过集合" class="headerlink" title="创建 Stream方式一：通过集合"></a>创建 Stream方式一：通过集合</h6><blockquote><p>JDK8中的 Collection 接口被扩展，提供了两个获取流的方法：</p><ul><li><code>default Stream&lt;E&gt; stream() :  返回一个顺序流。</code></li><li>default Stream<E> parallelStream() :  返回一个并行流。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建 Stream方式一：通过集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">       <span class="comment">// default Stream&lt;E&gt; stream() :  返回一个顺序流。</span></span><br><span class="line">       Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// default Stream&lt;E&gt; parallelStream() :  返回一个并行流。</span></span><br><span class="line">       Stream&lt;Employee&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式二：通过数组"><a href="#创建-Stream方式二：通过数组" class="headerlink" title="创建 Stream方式二：通过数组"></a>创建 Stream方式二：通过数组</h6><blockquote><p>JDK8中的 <code>Arrays 的静态方法 stream()</code> 可以获取数组流：<code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array):</code>  返回一个流重载形式，能够处理对应基本类型的数组：</p><ol><li><code>public static IntStream stream(int[] array)</code></li><li><code>public static LongStream stream(long[] array)</code></li><li><code>public static DoubleStream stream(double[] array)</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式二：通过数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">    Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">"Tom"</span>);</span><br><span class="line">    Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">"Jerry"</span>);</span><br><span class="line">    Employee[] emps = <span class="keyword">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class="line">    Stream&lt;Employee&gt; employeeStream = Arrays.stream(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式三：通过Stream的of"><a href="#创建-Stream方式三：通过Stream的of" class="headerlink" title="创建 Stream方式三：通过Stream的of()"></a>创建 Stream方式三：通过Stream的of()</h6><blockquote><ol><li><code>可以调用Stream类静态方法 of(), 通过显示值创建一个流</code>。它可<code>以接收任意数量的参数。</code></li><li>public static<T> Stream<T> of(T… values) : </li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式三：通过Stream的of()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-Stream方式四：创建无限流"><a href="#创建-Stream方式四：创建无限流" class="headerlink" title="创建 Stream方式四：创建无限流"></a>创建 Stream方式四：创建无限流</h6><blockquote><p>可以使用<code>静态方法 Stream.iterate() 和 Stream.generate()</code>,创建无限流。</p><ol><li>迭代<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li></ul></li><li>生成<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Stream方式四：创建无限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// generate遍历前十个偶数</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>,t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate生成十个随机数</span></span><br><span class="line">    Stream.generate(() -&gt; Math.random()).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-中间操作"><a href="#2-2-中间操作" class="headerlink" title="2.2 中间操作"></a>2.2 中间操作</h4><blockquote><p><code>多个 中间操作可以连接起来形成一个 流水线，除非流水线上触发终止操作，否则 中间操作不会执行任何的处理！而在 终止操作时一次性全部处理，称为“惰性求值”。</code></p></blockquote><h6 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201114203553549.png" alt="image-20201114203553549"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 筛选与切片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.filter()-----------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">// 练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">    stream.filter(e -&gt; e.getSalary()&gt;<span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.limit()-----------"</span>);</span><br><span class="line">    <span class="comment">// limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">    list.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.skip()-----------"</span>);</span><br><span class="line">    <span class="comment">// skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。</span></span><br><span class="line">    <span class="comment">// 若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">    list.stream().skip(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------stream.distinct()-----------"</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">"刘强东"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，<br>并将其映射成一个新的元素。</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，<br/>然后把所有流连接成一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------map()-------------------"</span>);</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">    <span class="comment">// map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">    namesStream.filter(e -&gt; e.length()&gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2：</span></span><br><span class="line">    <span class="comment">// list.stream().map(StreamAPITest2::fromStringToStream);</span></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(str -&gt; fromStringToStream(str));</span><br><span class="line">    streamStream.forEach(s -&gt; &#123;</span><br><span class="line">        s.forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------------flatMap()-------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">    Stream&lt;Character&gt; characterStream = list.stream().flatMap(str -&gt; fromStringToStream(str));</span><br><span class="line">    characterStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character c:str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了更好地理解map()和flatMap()</span></span><br><span class="line"><span class="comment"> *      map()更像add()</span></span><br><span class="line"><span class="comment"> *      flatMap()更像addAll()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list2.add(<span class="number">4</span>);</span><br><span class="line">    list2.add(<span class="number">5</span>);</span><br><span class="line">    list2.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list1.add(list2);</span></span><br><span class="line">    list1.addAll(list2);</span><br><span class="line">    System.out.println(list1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><table><thead><tr><th>方法</th><th>描述<br/></th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，其中按自然顺序排序<br/></td></tr><tr><td><code>sorted(Comparator com)</code></td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"--------sorted()——自然排序--------"</span>);</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">66</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">77</span>, -<span class="number">22</span>, <span class="number">7</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.lang.ClassCastException: cn.justweb.methody.Employee cannot be cast to java.lang.Comparable</span></span><br><span class="line">    <span class="comment">// 抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line">    <span class="comment">// List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line">    <span class="comment">// employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------sorted(Comparator com)——定制排序------"</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    employees.stream().sorted((e1, e2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> ageValue = Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">        <span class="keyword">if</span> (ageValue != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ageValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(e1.getSalary(), e2.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-终止操作"><a href="#2-3-终止操作" class="headerlink" title="2.3 终止操作"></a>2.3 终止操作</h4><blockquote><ol><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void </li><li>流进行了终止操作后，不能再次使用。</li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109700686" target="_blank" rel="noopener">Optional类</a></li></ol></blockquote><h6 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115085705510.png" alt="image-20201115085705510"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配与查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------allMatch(Predicate p)——检查是否匹配所有元素。-----------"</span>);</span><br><span class="line">    <span class="comment">//练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">    <span class="keyword">boolean</span> result1 = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">    System.out.println(<span class="string">"result1 = "</span> + result1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------anyMatch(Predicate p)——检查是否至少匹配一个元素。-----------"</span>);</span><br><span class="line">    <span class="comment">// 练习：是否存在员工的工资大于 8000</span></span><br><span class="line">    <span class="keyword">boolean</span> result2 = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">8000</span>);</span><br><span class="line">    System.out.println(<span class="string">"result2 = "</span> + result2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"----------noneMatch(Predicate p)——检查是否没有匹配的元素。-----------"</span>);</span><br><span class="line">    <span class="comment">//练习：是否存在员工姓“雷”</span></span><br><span class="line">    <span class="keyword">boolean</span> result3 = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">"雷"</span>));</span><br><span class="line">    System.out.println(<span class="string">"result3 = "</span> + result3);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"----------findFirst——返回第一个元素-----------"</span>);</span><br><span class="line">    Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">    <span class="comment">// any = Optional[Employee&#123;id=1006, name='比尔盖茨', age=42, salary=9500.43&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">"first = "</span> + first);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------findAny——返回当前流中的任意元素-----------"</span>);</span><br><span class="line">    Optional&lt;Employee&gt; any = employees.parallelStream().findAny();</span><br><span class="line">    <span class="comment">// any = Optional[Employee&#123;id=1001, name='马化腾', age=34, salary=6000.38&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">"any = "</span> + any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115091214399.png" alt="image-20201115091214399"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配与查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">    <span class="keyword">long</span> count = employees.stream().count();</span><br><span class="line">    System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max(Comparator c)——返回流中最大值</span></span><br><span class="line">    <span class="comment">// 练习：返回最高的工资：</span></span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; max = salaryStream.max((e1, e2) -&gt; Double.compare(e1, e2));</span></span><br><span class="line">    Optional&lt;Double&gt; max = salaryStream.max(Double::compare);</span><br><span class="line">    System.out.println(<span class="string">"max = "</span> + max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// min(Comparator c)——返回流中最小值</span></span><br><span class="line">    <span class="comment">// 练习：返回最低工资的员工</span></span><br><span class="line">    Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(<span class="string">"min = "</span> + min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forEach(Consumer c)——内部迭代</span></span><br><span class="line">    employees.parallelStream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h6><blockquote><p><code>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google用它来进行网络搜索而出名。</code></p></blockquote><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)<br/></td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td>reduce(BinaryOperator b)<br/></td><td>可以将流中元素反复结合起来，得到一个值。返回 <code>Optional&lt;T&gt;</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归约</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">    <span class="comment">// 练习1：计算1-10的自然数的和</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Integer result1 = list.stream().reduce(0, (e1, e2) -&gt; Integer.sum(e1, e2));</span></span><br><span class="line">    Integer result1 = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">// result1 = 55</span></span><br><span class="line">    System.out.println(<span class="string">"result1 = "</span> + result1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2：计算公司所有员工工资的总和</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line">    <span class="comment">// Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; result2 = salaryStream.reduce((e1, e2) -&gt; Double.sum(e1, e2));</span></span><br><span class="line">    Optional&lt;Double&gt; result2 = salaryStream.reduce((e1, e2) -&gt; e1 + e2);</span><br><span class="line">    System.out.println(<span class="string">"result2 = "</span> + result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h6><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td><code>collect(Collector c)</code></td><td>将流转换为其他形式。接收一个 Collector接口<br/>的实现，用于给Stream中元素做汇总的方法。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">// 练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Employee&gt; employeeStream1 = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>);</span><br><span class="line">    List&lt;Employee&gt; list = employeeStream1.collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">"list = "</span> + list);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Employee&gt; employeeStream2 = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>);</span><br><span class="line">    Set&lt;Employee&gt; set = employeeStream2.collect(Collectors.toSet());</span><br><span class="line">    System.out.println(<span class="string">"set = "</span> + set);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</li><li>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115094432477.png" alt="image-20201115094432477"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201115094451544.png" alt="image-20201115094451544"></p><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;欲将沉醉换悲凉。清歌莫断肠。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《阮郎归》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/7.Map接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.925Z</published>
    <updated>2020-12-19T11:56:30.441Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>黯相望。断鸿声里，立尽斜阳。</p><p align="right">——柳永《玉蝴蝶》</p><a id="more"></a><h1 id="Map接口及其实现类"><a href="#Map接口及其实现类" class="headerlink" title="Map接口及其实现类"></a>Map接口及其实现类</h1><h2 id="1-Map接口介绍"><a href="#1-Map接口介绍" class="headerlink" title="1. Map接口介绍"></a>1. Map接口介绍</h2><blockquote><ol><li>现实生活中，我们常会看到这样的一种集合：<code>IP</code>地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种<code>一一对应</code>的关系，就叫做映射。<code>Java</code>提供了专门的集合类用来存放这种对象关系的对象，即 <code>java.util.Map</code> 接口。</li><li>Map与Collection并列存在。用于保存具有<code>映射关系的数据:key-value。</code></li><li>Map 中的 key 和 value 都可以是任何引用类型的数据</li><li><code>Map 中的 key 用Set来存放， 不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</code><ul><li><code>常用String类作为Map的“键”。</code></li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113172115578.png" alt="image-20201113172115578"></li></ul></li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li><li>Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</li><li>Map接口的常用实现类：<code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code>和<code>Properties</code>。<code>其中HashMap是 Map 接口使用频率最高的实现类</code></li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/20201113230328581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI2NzEwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-Map接口中常用方法"><a href="#2-Map接口中常用方法" class="headerlink" title="2. Map接口中常用方法"></a>2. Map接口中常用方法</h2><h4 id="元素的添加-、-删除、修改操作"><a href="#元素的添加-、-删除、修改操作" class="headerlink" title="元素的添加 、 删除、修改操作"></a>元素的添加 、 删除、修改操作</h4><blockquote><p><code>Object put(Object key,Object value)：</code>将指定key-value<code>添加到(或修改)</code>当前map对象中。</p><p><code>void putAll(Map m):</code>将m中的所有key-value对存放到当前map中。</p><p><code>Object remove(Object key)：</code>移除指定key的key-value对，并返回value。</p><p><code>void clear()：</code>清空当前map中的所有数据。</p></blockquote><h4 id="元素查询的操作"><a href="#元素查询的操作" class="headerlink" title="元素查询的操作"></a>元素查询的操作</h4><blockquote><p><code>Object get(Object key)：</code>获取指定key对应的value。</p><p><code>boolean containsKey(Object key)：</code>是否包含指定的key。</p><p><code>boolean containsValue(Object value)：</code>是否包含指定的value。</p><p><code>int size()：</code>返回map中key-value对的个数。</p><p><code>boolean isEmpty()：</code>判断当前map是否为空。</p><p><code>boolean equals(Object obj)：</code>判断当前mp和参数对象obj是否相等。</p></blockquote><h4 id="遍历Map的三种方式☆"><a href="#遍历Map的三种方式☆" class="headerlink" title="遍历Map的三种方式☆"></a>遍历Map的三种方式☆</h4><blockquote><p><code>public Set&lt;K&gt; keySet()</code> : 获取Map集合中所有的键，存储到Set集合中。</p><ul><li><p>获取<code>Map</code>中所有的键，由于键是唯一的，所以返回一个<code>Set</code>集合存储所有的键。方法提示: <code>keyset()</code></p></li><li><p>遍历键的<code>Set</code>集合，得到每一个键。</p></li><li><p>根据键，获取键所对应的值。方法提示: <code>get(K key)</code></p></li></ul><p><code>Collection values()：</code>返回所有value构成的Collection集合</p><p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p><ul><li><p>我们已经知道， <code>Map</code> 中存放的是两种对象，一种称为key(键)，一种称为<code>value</code>(值)，它们在在 <code>Map</code> 中是一一对应关系，这一对对象又称做 <code>Map</code> 中的一个 <code>Entry</code>(项) 。 <code>Entry</code> 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 <code>Map</code> 集合时，就可以从每一个键值对（ <code>Entry</code> ）对象中获取对应的键与对应的值。既然<code>Entry</code>表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p></li><li><p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p><ul><li><p>public K getKey() ：获取Entry对象中的键。</p></li><li><p>public V getValue() ：获取Entry对象中的值。</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/13 17:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 集合初始化时，指定集合初始值大小</span></span><br><span class="line">        <span class="comment">// 说明:HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//map.put(..,..)省略</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map的所有key:"</span>);</span><br><span class="line">        <span class="comment">// HashSet</span></span><br><span class="line">        Set keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"-&gt;"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map的所有的value："</span>);</span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        Iterator iter = values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"map所有的映射关系："</span>);</span><br><span class="line">        <span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line">        Set mappings = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) mapping;</span><br><span class="line">            System.out.println(<span class="string">"key是："</span> + entry.getKey() + <span class="string">"，value是："</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Map接口的实现类"><a href="#3-Map接口的实现类" class="headerlink" title="3. Map接口的实现类"></a>3. Map接口的实现类</h2><h3 id="3-1-HashMap集合"><a href="#3-1-HashMap集合" class="headerlink" title="3.1 HashMap集合"></a>3.1 HashMap集合</h3><blockquote><ol><li><code>HashMap是 Map 接口 使用频率最高的实现类。</code></li><li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li><li><code>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()。</code></li><li>所有的value构成的集合是Collection:无序的、可以重复的。<code>所以，value所在的类要重写：equals()。</code></li><li>==一个key-value构成一个entry==</li><li>所有的entry构成的集合是Set:无序的、不可重复的</li><li>HashMap  <code>判断两个 key  相等的标准是</code>：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。<ul><li>因为key不允许有重复。</li></ul></li><li>HashMap  <code>判断两个 value 相等的标准是</code>：两个 value 通过 equals() 方法返回 true。</li></ol></blockquote><h5 id="HashMap源码中的重要常量☆"><a href="#HashMap源码中的重要常量☆" class="headerlink" title="HashMap源码中的重要常量☆"></a>HashMap源码中的重要常量☆</h5><blockquote><ol><li><p><code>DEFAULT_INITIAL_CAPACITY :</code> HashMap的默认容量，16</p></li><li><p><code>MAXIMUM_CAPACITY ：</code> HashMap的最大支持容量，2^30</p></li><li><p><code>DEFAULT_LOAD_FACTOR ：</code>HashMap的默认加载因子0.75</p></li><li><p><code>TREEIFY_THRESHOLD ：</code>Bucket中链表长度大于该默认值8，转化为红黑树</p></li><li><p><code>UNTREEIFY_THRESHOLD ：</code>Bucket中红黑树存储的Node小于该默认值6，转化为链表。</p></li><li><p><code>MIN_TREEIFY_CAPACITY ：</code>==桶中的Node被树化时最小的hash表容量==。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值<code>（默认为64）</code>至少是TREEIFY_THRESHOLD的4倍。）</p></li><li><p><code>table ：</code>存储元素的数组，总是2的n次幂</p></li><li><p><code>entrySet：</code> 存储具体元素的集</p></li><li><p><code>size ：</code>HashMap中存储的键值对的数量</p></li><li><p><code>modCount ：</code>HashMap扩容和结构改变的次数。</p></li><li><p><code>threshold ：</code>扩容的临界值（吞吐临界值）12=容量*填充因子</p></li><li><p><code>loadFactor：</code> 填充比（负载因子）。</p><ol><li><p>负载因子值的大小，对HashMap有什么影响？</p><ul><li><p>负载因子的大小决定了HashMap的数据密度。</p></li><li><p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</p></li><li><p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p></li><li><p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</p></li></ul></li></ol></li></ol></blockquote><h5 id="HashMap的储存结构☆☆"><a href="#HashMap的储存结构☆☆" class="headerlink" title="HashMap的储存结构☆☆"></a>HashMap的储存结构☆☆</h5><blockquote><ol><li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)。</li><li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</li></ol></blockquote><h6 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113211938573.png" alt="image-20201113211938573"></p><blockquote><ol><li><p>HashMap的内部存储结构其实是 数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p></li><li><p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</p></li><li><p>HashMap静态内部类Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==添加元素的过程：==</p><ol><li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要<code>存储的位置i</code>。</li><li>如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。</li><li>如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value<br>去替换equals为true的entry的value。</li><li>如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li></ol></li><li><p>==HashMap 的扩容：==</p><ol><li>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，<code>而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</code></li><li>那么HashMap 什么时候进行扩容呢 ？<ol><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</li><li>也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，<code>所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</code></li></ol></li></ol></li></ol></blockquote><h6 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113212003964.png" alt="image-20201113212003964"></p><blockquote><ol><li><p>HashMap的内部存储结构其实是 <code>数组+ 链表+ 树</code> 的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的<code>Node数组</code>，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为<br>“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p></li><li><p><code>每个bucket中存储一个元素，即一个Node对象，</code>但每一个Node对象可以带一个引用变量next，用于指向下一个元素，<code>因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，</code>每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。<code>而新添加的元素作为链表的last，或树的叶子结点。</code></p></li><li><p>HashMap的静态内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么HashMap 什么时候进行扩容和树形化呢 ？</p><ol><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</li><li><code>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</code><ul><li>如果不理解这段，可以看一下HashMap源码中的重要常量<code>MIN_TREEIFY_CAPACITY</code>。</li></ul></li></ol></li><li><p>关于映射关系的key 是否可以修改 ？</p><ul><li><p>答案是：不要修改！</p></li><li><p><code>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</code></p></li></ul></li></ol></blockquote><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><blockquote><p><code>JDK1.8相较于之前的变化：</code></p><ol><li>HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组。</li><li><code>当首次调用map.put()时，再创建长度为16的数组。</code></li><li><code>数组为Node类型，在jdk7中称为Entry类型。</code></li><li><code>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）。</code></li><li><code>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</code></li></ol></blockquote><h5 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h5><blockquote><ol><li>每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到<code>map</code>集合中。学生作为键, 家庭住址作为值。</li><li>注意，学生姓名相同并且年龄相同视为同一名学生。</li></ol></blockquote><h6 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试类HashMapTest"><a href="#测试类HashMapTest" class="headerlink" title="测试类HashMapTest"></a>测试类HashMapTest</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">"lisi"</span>,<span class="number">28</span>), <span class="string">"上海"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"wangwu"</span>,<span class="number">22</span>), <span class="string">"北京"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"zhaoliu"</span>,<span class="number">24</span>), <span class="string">"成都"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"zhouqi"</span>,<span class="number">25</span>),<span class="string">"广州"</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">"wangwu"</span>,<span class="number">22</span>), <span class="string">"南京"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">"....."</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>当给<code>HashMap</code>中存放自定义对象时，如果自定义对象作为<code>key</code>存在，这时要保证对象唯一，必须复写对象的<code>hashCode</code>和<code>equals</code>方法(如果忘记，请回顾<code>HashSet</code>存放自定义对象)。</p></li><li><p>如果要保证<code>map</code>中存放的<code>key</code>和取出的顺序一致，可以使用 <code>java.util.LinkedHashMap</code> 集合来存放。</p></li></ol></blockquote><h5 id="LinkedHashMap集合☆"><a href="#LinkedHashMap集合☆" class="headerlink" title="LinkedHashMap集合☆"></a>LinkedHashMap集合☆</h5><blockquote><ol><li>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</li><li>LinkedHashMap 是 HashMap 的子类，它是链表和哈希表组合的一个数据存储结构。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">        map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰"</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="string">"朱丽倩"</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">" "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邓超 孙俪</span><br><span class="line">李晨 范冰冰</span><br><span class="line">刘德华 朱丽倩</span><br></pre></td></tr></table></figure><h6 id="LinkedHashMap的静态内部类Entry"><a href="#LinkedHashMap的静态内部类Entry" class="headerlink" title="LinkedHashMap的静态内部类Entry"></a>LinkedHashMap的静态内部类Entry</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-TreeMap集合"><a href="#3-2-TreeMap集合" class="headerlink" title="3.2 TreeMap集合"></a>3.2 TreeMap集合</h3><blockquote><ol><li>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li><li>TreeSet底层使用 <a href="https://blog.csdn.net/weixin_45267102/article/details/108424364" target="_blank" rel="noopener">红黑树</a> 结构存储数据。</li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109678514" target="_blank" rel="noopener">TreeMap 的 Key 的排序：</a><ul><li><code>自然排序：</code>TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。</li><li><code>定制排序：</code>创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口</li></ul></li><li><code>TreeMap判断两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</code></li></ol></blockquote><h3 id="3-3-HashTable集合"><a href="#3-3-HashTable集合" class="headerlink" title="3.3 HashTable集合"></a>3.3 HashTable集合</h3><blockquote><ol><li>HashTable是个古老的 Map 实现类，JDK1.0就提供了。<code>不同于HashMap，Hashtable是线程安全的。</code></li><li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li><li><code>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</code></li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li><li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li></ol></blockquote><h5 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h5><blockquote><ol><li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型</p></li><li><p>存取数据时，建议使用<code>setProperty(String key,String value)方法</code>和<code>getProperty(String key)方法。</code></p></li><li><pre><code class="java">Properties pros = <span class="keyword">new</span> Properties();pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>));String user = pros.getProperty(<span class="string">"user"</span>);System.out.println(user);</code></pre></li></ol></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;黯相望。断鸿声里，立尽斜阳。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——柳永《玉蝴蝶》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/6.Set接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/6.Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/6.Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.923Z</published>
    <updated>2020-12-19T11:56:30.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可怜人意，薄于云水，佳会更难重。</p><p align="right">——晏几道《少年游》</p><a id="more"></a><h1 id="Set接口及其实现类"><a href="#Set接口及其实现类" class="headerlink" title="Set接口及其实现类"></a>Set接口及其实现类</h1><h2 id="1-Set接口介绍"><a href="#1-Set接口介绍" class="headerlink" title="1. Set接口介绍"></a>1. Set接口介绍</h2><blockquote><ol><li><code>java.util.Set</code> 接口和 <code>java.util.List</code> 接口一样，同样继承自 <code>Collection</code> 接口，它与<code>Collection</code> 接口中的方法基本一致，并没有对 <code>Collection</code> 接口进行功能上的扩充，只是比<code>Collection</code> 接口更加严格了。</li><li>与 <code>List</code> 接口不同的是， <code>Set</code> 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</li><li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法。</li><li>Set集合取出元素的方式可以采用：迭代器、增强for。</li><li><code>Set</code> 集合有多个子类，这里我们介绍其中的 <code>java.util.HashSet</code> 、 <code>java.util.LinkedHashSet</code>、<code>java.util.TreeSet</code> 这三个集合。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113163538117.png" alt="image-20201113163538117"></p><h2 id="2-Set接口的主要实现类"><a href="#2-Set接口的主要实现类" class="headerlink" title="2. Set接口的主要实现类"></a>2. Set接口的主要实现类</h2><h3 id="2-1-HashSet集合☆"><a href="#2-1-HashSet集合☆" class="headerlink" title="2.1 HashSet集合☆"></a>2.1 HashSet集合☆</h3><blockquote><ol><li><code>java.util.HashSet</code> 是 <code>Set</code> 接口的一个典型实现类，它所存储的<code>元素是不可重复</code>的，<code>集合元素可以为null</code>，<code>线程不安全</code>，并且元素都是<code>无序的</code>(即存取顺序不能保证不一致)。</li><li><code>HashSet</code> 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code> 与 <code>equals</code> 方法。即两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</li><li>对于存放在Set容器中的对象， <code>对应的类一定要重写equals() 和hashCode(Object obj) 方法</code>，以实现对象相等规则 。即： <code>“相等的对象必须具有相等的散列码”</code> 。</li><li><code>java.util.HashSet</code> 底层的实现其实是一个 <code>java.util.HashMap</code> 支持。</li></ol></blockquote><h5 id="哈希值和哈希表"><a href="#哈希值和哈希表" class="headerlink" title="哈希值和哈希表"></a>哈希值和哈希表</h5><blockquote><ol><li>哈希值简介：是JDK根据<code>对象的地址</code>或者<code>字符串</code>或者<code>数字</code>算出来的<code>int类型的数值</code>。</li><li>如何获取哈希值：<code>Object类中的public int hashCode()；返回对象的哈希码值。</code></li><li>哈希值的特点：<ul><li>同一个对象多次调用hashCode()方法返回的哈希值是相同的。</li><li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同。</li></ul></li><li>什么是哈希表呢？哈希表是HashSet集合存储数据的结构</li><li>在<code>JDK1.8</code>之前，哈希表底层采用<code>数组+链表</code>实现，即使用链表处理冲突，同一<code>hash</code>值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即<code>hash</code>值相等的元素较多时，通过<code>key</code>值依次查找的效率较低。<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/14_JKD8%E4%BB%A5%E5%89%8D%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="14_JKD8以前哈希表"></li></ul></li><li>而<code>JDK1.8</code>中，哈希表存储<code>采用数组+链表+红黑树</code>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/15_JKD8%E4%BB%A5%E5%90%8E%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="15_JKD8以后哈希表"></li></ul></li><li><code>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。</code>（16扩容为32，依次为64,128….等）。</li><li>简单的来说，哈希表是由数组+链表+红黑树（<code>JDK1.8</code>增加了红黑树部分）实现的，如下图所示：</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/1563700294020.png" alt="1563700294020"></p><h5 id="HashSet中添加元素的过程"><a href="#HashSet中添加元素的过程" class="headerlink" title="HashSet中添加元素的过程"></a>HashSet中添加元素的过程</h5><blockquote><ol><li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（<code>这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好</code>）</li><li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过<code>链表的方式</code>继续链接。</li></ol></blockquote><h5 id="重写-hashCode-方法的基本原则"><a href="#重写-hashCode-方法的基本原则" class="headerlink" title="重写 hashCode() 方法的基本原则"></a>重写 hashCode() 方法的基本原则</h5><blockquote><ol><li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li><li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</li><li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li></ol></blockquote><h5 id="重写-equals-方法的基本原则"><a href="#重写-equals-方法的基本原则" class="headerlink" title="重写 equals() 方法的基本原则"></a>重写 equals() 方法的基本原则</h5><blockquote><p>以自定义的Student类为例，何时需要重写equals()？</p><ol><li><code>当一个类有自己特有的“逻辑相等”概念,</code>当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li><li>因此，违反了<code>“相等的对象必须具有相等的散列码”</code>。</li><li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。<code>通常参与计算hashCode 的对象的属性也应该参与到equals()。</code></li></ol></blockquote><h5 id="HashSet存储自定义类型元素☆"><a href="#HashSet存储自定义类型元素☆" class="headerlink" title="HashSet存储自定义类型元素☆"></a>HashSet存储自定义类型元素☆</h5><blockquote><p>给<code>HashSet</code>中存放自定义类型元素时，需要重写对象中的<code>hashCode</code>和<code>equals</code>方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建自定义Student类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建集合对象 该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭德纲"</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭麒麟"</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student [name&#x3D;郭德纲, age&#x3D;44]</span><br><span class="line"></span><br><span class="line">Student [name&#x3D;于谦, age&#x3D;43]</span><br><span class="line"></span><br><span class="line">Student [name&#x3D;郭麒麟, age&#x3D;23]</span><br></pre></td></tr></table></figure><blockquote><p><code>Objects.hash(name, age);执行细节如下：</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Object element : a)</span><br><span class="line">           result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedHashSet集合☆"><a href="#LinkedHashSet集合☆" class="headerlink" title="LinkedHashSet集合☆"></a>LinkedHashSet集合☆</h5><blockquote><p>我们知道<code>HashSet</code>保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在<code>HashSet</code>下面有一个子类<code>java.util.LinkedHashSet</code> ，它是链表和哈希表组合的一个数据存储结构。</p><ol><li><code>LinkedHashSet 是 HashSet 的子类。</code></li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是<code>以插入顺序保存的</code>。</li><li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li><li>LinkedHashSet 不允许集合元素重复。</li></ol></blockquote><h3 id="2-2-TreeSet集合"><a href="#2-2-TreeSet集合" class="headerlink" title="2.2 TreeSet集合"></a>2.2 TreeSet集合</h3><blockquote><ol><li><code>TreeSet 是 SortedSet 接口的实现类</code>，TreeSet 可以确保集合元素处于排序状态。</li><li>TreeSet底层使用 <a href="https://blog.csdn.net/cyp331203/article/details/42677833" target="_blank" rel="noopener">红黑树结构存储数据。</a></li><li><a href="https://blog.csdn.net/weixin_45267102/article/details/109644829" target="_blank" rel="noopener">可以将元素按照规则进行排序</a>。<ul><li>TreeSet()：根据其元素的<code>自然排序进行排序。</code></li><li>TreeSet(Comparator comparator) ：根据指定的<code>比较器进行排序。</code></li></ul></li><li>特点：<ul><li>有序，查询速度比List快。</li></ul></li></ol></blockquote><h5 id="排序—自然排序"><a href="#排序—自然排序" class="headerlink" title="排序—自然排序"></a>排序—自然排序</h5><blockquote><ol><li><p>自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素<code>按升序(默认情况)排列</code>。</p></li><li><p><code>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口。</code></p></li><li><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</p></li><li><p>Comparable 的典型实现：</p><ul><li><code>BigDecimal、BigInteger</code> 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较。</li><li><code>Character：</code>按字符的 unicode值来进行比较。</li><li><code>Boolean：true</code> 对应的包装类实例大于 false 对应的包装类实例。</li><li><code>String：</code>按字符串中字符的 unicode 值进行比较。</li><li><code>Date、Time：</code>后边的时间、日期比前面的时间、日期大。</li></ul></li><li><p>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p></li><li><p>因为只有相同类的两个实例才会比较大小，所以向 TreeSet  中添加的应该是同一个类的对象。</p></li><li><p><code>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。</code></p></li><li><p>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与<code>compareTo(Object obj)</code> 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 <code>compareTo(Object obj)</code> 方法比较应返回 0。否则，让人难以理解。</p></li></ol></blockquote><h5 id="排序—定制排序"><a href="#排序—定制排序" class="headerlink" title="排序—定制排序"></a>排序—定制排序</h5><blockquote><ol><li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。<ul><li><code>定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</code></li></ul></li><li>利用<code>int compare(T o1,T o2)</code>方法，比较<code>o1</code>和<code>o2</code>的大小：<ul><li><code>如果方法返回正整数，则表示o1大于o2；</code></li><li><code>如果返回0，表示相等；</code></li><li><code>返回负整数，表示o1小于o2。</code></li></ul></li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li><li><code>此时，仍然只能向TreeSet中添加类型相同的对象，否则发生ClassCastException异常。</code></li><li>使用定制排序判断两个元素相等的标准是：通过Comparator比较<code>两个元素返回了0。</code></li></ol></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;可怜人意，薄于云水，佳会更难重。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——晏几道《少年游》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/5.Collections包装类和Comparator比较器</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/5.Collections%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CComparator%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/5.Collections%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CComparator%E6%AF%94%E8%BE%83%E5%99%A8/</id>
    <published>2020-12-19T10:57:43.920Z</published>
    <updated>2020-12-19T11:56:30.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两情若是久长时，又岂在朝朝暮暮。</p><p align="right">——秦观《鹊桥仙》</p><a id="more"></a>## Collections包装类和Comparator比较器<h3 id="1-Collections包装类"><a href="#1-Collections包装类" class="headerlink" title="1. Collections包装类"></a>1. Collections包装类</h3><blockquote><ol><li>java.util.Collections 是一个包装类。它包含有各种有关集合操作的 <code>静态多态方法</code>。</li><li>此类 <code>不能实例化</code>，就像一 <code>个工具类</code>，服务于Java的Collection框架。 </li><li>他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ol></blockquote><h4 id="1-1-可变参数"><a href="#1-1-可变参数" class="headerlink" title="1.1 可变参数"></a>1.1 可变参数</h4><blockquote><ol><li><p>在<code>JDK1.5</code>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>其实这个书写完全等价与</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</code></p></li><li><p><code>JDK1.5</code>以后。出现了简化操作。==… 用在参数上，称之为可变参数。==</p></li><li><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.justwe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);<span class="comment">// 500</span></span><br><span class="line">        <span class="comment">// 6 7 2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6 7 2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);<span class="comment">// 2148</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成数组 所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">//    public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">//        int sum = 0;</span></span><br><span class="line"><span class="comment">//        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">//            sum += a;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return sum;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: </p><ol><li>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性。</li><li>如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</li></ol></blockquote><h4 id="1-2-Collections常用功能"><a href="#1-2-Collections常用功能" class="headerlink" title="1.2 Collections常用功能"></a>1.2 Collections常用功能</h4><blockquote><p>java.utils.Collections 是集合工具类，用来对集合进行操作。部分方法如下：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :</code>往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) :</code>打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list) :</code>将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) :</code>将集合中元素按照指定规则排序。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素</span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure><h3 id="2-Comparator比较器"><a href="#2-Comparator比较器" class="headerlink" title="2. Comparator比较器"></a>2. Comparator比较器</h3><blockquote><ol><li><p>我们还是先研究 <code>Collections</code>的<code>sort()</code>方法。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序，不过这次存储的是字符串类型。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><blockquote><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p></blockquote><h4 id="1-实现排序的两种方式"><a href="#1-实现排序的两种方式" class="headerlink" title="1. 实现排序的两种方式"></a>1. 实现排序的两种方式</h4><blockquote><p>说到排序了，简单的说就是两个对象之间比较大小，那么在<code>JAVA</code>中提供了两种比较实现的方式:</p><ol><li>一种是比较死板的采用 <code>java.lang.Comparable</code>接口去实现</li><li>一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code> 接口完成。</li></ol></blockquote><h6 id="实现Comparable接口"><a href="#实现Comparable接口" class="headerlink" title="实现Comparable接口"></a>实现Comparable接口</h6><blockquote><p>那么我们采用的 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现<code>Comparable</code>接口完成比较的功能，在<code>String</code>类型上如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class"> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class"> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">                                         </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="使用Comparator比较器"><a href="#使用Comparator比较器" class="headerlink" title="使用Comparator比较器"></a>使用Comparator比较器</h6><blockquote><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><ul><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code> 方法灵活的完成，这个里面就涉及到了<code>Comparator</code>这个接口，位于位于<code>java.util</code>包下，排序是<code>comparator</code>能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</li><li><code>public int compare(String o1, String o2)</code> ：比较其两个参数的顺序。</li><li>两个对象比较的结果有三种：大于，等于，小于。<ul><li><code>如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）</code> </li><li><code>如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</code></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序方法 按照第一个单词的降序</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) ‐ o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><blockquote><p>如果不想使用匿名对象，可以通过下述方式进行排序：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,<span class="keyword">new</span> CompareTwo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTwo</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(o1.getId())-Integer.parseInt(o2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Comparable和Comparator两个接口的区别"><a href="#2-Comparable和Comparator两个接口的区别" class="headerlink" title="2. Comparable和Comparator两个接口的区别"></a>2. Comparable和Comparator两个接口的区别</h4><blockquote><ol><li><code>Comparable：</code>强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，<code>类的compareTo方法被称为它的自然比较方法</code>。<code>只能在类中实现compareTo()一次</code>，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过<code>Collections.sort</code>（和<code>Arrays.sort</code>）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</li><li><code>Comparator：</code>强行对某个对象进行整体排序。可以将<code>Comparator</code> 传递给<code>sort</code>方法（<code>如Collections.sort或Arrays.sort</code>），从而允许在排序顺序上实现精确控制。还可以使用<code>Comparator</code>来控制某些数据结构（如有序<code>set</code>或有序映射）的顺序，或者为那些没有自然顺序的对象<code>collection</code>提供排序。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;两情若是久长时，又岂在朝朝暮暮。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——秦观《鹊桥仙》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/4.List接口及其实现类</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/4.List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/4.List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</id>
    <published>2020-12-19T10:57:43.917Z</published>
    <updated>2020-12-19T11:56:29.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>凝碧旧池头，一听管弦凄切。多少梨园声在，总不堪华发。</p><p align="right">——韩元吉《好事近》</p><a id="more"></a><h1 id="List接口及其实现类"><a href="#List接口及其实现类" class="headerlink" title="List接口及其实现类"></a>List接口及其实现类</h1><h2 id="1-List接口介绍"><a href="#1-List接口介绍" class="headerlink" title="1. List接口介绍"></a>1. List接口介绍</h2><blockquote><ol><li><code>java.util.List</code> 接口继承自 <code>Collection</code> 接口，是单列集合的一个重要分支，习惯性地会将实现了 <code>List</code> 接口的对象称为<code>List</code>集合。</li><li>在<code>List</code>集合与set集合不同<code>允许出现重复的元素</code>，所有的元素是以一种线性方式进行存储的，在程序中可以<code>通过索引来访问集合中的指定元素</code>。另外，<code>List集合还有一个特点就是元素有序，</code>即元素的存入顺序和取出顺序一致。</li><li>JDK API中List接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>。</li></ol></blockquote><h2 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2. List接口中常用方法"></a>2. List接口中常用方法</h2><blockquote><p><code>List</code>作为<code>Collection</code>集合的子接口，不但继承了<a href="https://blog.csdn.net/weixin_45267102/article/details/107350539" target="_blank" rel="noopener">Collection接口</a>中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><p><code>public void add(int index, E element)</code> : 将指定的元素，添加到该集合中的指定位置上。 将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。</p></li><li><p><code>public E get(int index)</code> :返回集合中指定位置的元素。</p></li><li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p></li><li><p><code>public E set(int index, E element)</code> :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">        list.add(<span class="string">"图图"</span>);</span><br><span class="line">        list.add(<span class="string">"小美"</span>);</span><br><span class="line">        list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除指定位置元素 返回被删除元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置 进行 元素替代（改）</span></span><br><span class="line">        <span class="comment">// 修改指定位置元素</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跟size() 方法一起用来遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//还可以使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们学习Colletion体系的时候，<code>发现List集合下有很多集合</code>，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？</p></blockquote><h2 id="3-List的实现类"><a href="#3-List的实现类" class="headerlink" title="3. List的实现类"></a>3. List的实现类</h2><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/LinkedList.png" alt="LinkedList"></p><h3 id="3-1-ArrayList集合☆"><a href="#3-1-ArrayList集合☆" class="headerlink" title="3.1 ArrayList集合☆"></a>3.1 ArrayList集合☆</h3><blockquote><ol><li><code>java.util.ArrayList</code> 集合数据存储的结构是<code>数组结构。元素增删慢，查找快</code>，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 <code>ArrayList</code> 是最常用的集合。</li><li>但是<code>ArrayList</code>并不能完成任何需求，应结合着具体的应用场景和集合的特点进行使用。</li><li><code>ArrayList 的JDK1.8 之前与之后的实现区别？</code><ul><li><code>JDK1.7：ArrayList像饿汉式，</code>直接创建一个初始容量为10的数组。</li><li><code>JDK1.8：ArrayList像懒汉式，</code>一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组。</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/11 18:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        updateList(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[1, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h3><blockquote><ol><li><p><code>java.util.LinkedList</code> 集合数据存储的结构是<code>链表结构。查询慢、但是方便元素添加、删除的集合。</code></p></li><li><p>对于 频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。</p></li><li><p>LinkedList： 双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，<code>定义内部类Node，作为LinkedList中保存数据的基本结构</code>。Node除了保存数据，还定义了两个变量：</p><ul><li><p><code>prev变量</code>记录前一个元素的位置。</p></li><li><p><code>next变量</code>记录下一个元素的位置。</p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/linkedlist.jpg" alt="linkedlist"></p></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedList常用方法"><a href="#LinkedList常用方法" class="headerlink" title="LinkedList常用方法"></a>LinkedList常用方法</h5><blockquote><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而<code>LinkedList</code>提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code> :将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code> :返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code> :移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code> :将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p><code>LinkedList</code>是<code>List</code>的子类，<code>List</code>中的方法<code>LinkedList</code>都是可以使用，这里就不做详细介绍，我们只需要了解<code>LinkedList</code>的特有方法即可。<code>在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">"abc1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList和LinkedList的异同"><a href="#ArrayList和LinkedList的异同" class="headerlink" title="ArrayList和LinkedList的异同"></a>ArrayList和LinkedList的异同</h5><blockquote><p>二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p></blockquote><h3 id="3-2-Vector集合"><a href="#3-2-Vector集合" class="headerlink" title="3.2 Vector集合"></a>3.2 Vector集合</h3><blockquote><ol><li>Vector 是一个古老的集合，<code>JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</code></li><li>在各种List中，最好把ArrayList作为默认选择，当插入、删除频繁时，使用LinkedList。</li><li>Vector总是比ArrayList慢，所以尽量避免使用。</li><li>新增方法：<ul><li><code>void addElement(Object obj)</code></li><li><code>void insertElementAt(Object obj,int index)</code></li><li><code>void setElementAt(Object obj,int index)</code></li><li><code>void removeElement(Object obj)</code></li><li><code>void removeAllElements()</code></li></ul></li></ol></blockquote><h5 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h5><blockquote><p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。<code>正常情况下,大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制</code>。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p></blockquote><h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;凝碧旧池头，一听管弦凄切。多少梨园声在，总不堪华发。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——韩元吉《好事近》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/3.Java集合基础之泛型</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/3.Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/3.Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-12-19T10:57:43.914Z</published>
    <updated>2020-12-19T11:56:29.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>驿寄梅花，鱼传尺素。砌成此恨无重数。</p><p align="right">——秦观《踏莎行》</p><a id="more"></a>## Java集合基础之泛型<h4 id="1-泛型概述"><a href="#1-泛型概述" class="headerlink" title="1. 泛型概述"></a>1. 泛型概述</h4><p>我们都知道<code>集合中是可以存放任意对象的</code>，只要把对象存储集合后，那么这时他们都<code>会被提升成Object类型</code>。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><blockquote><p>观察下面代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">"abc"</span>);</span><br><span class="line">        coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// 由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">        coll.add(<span class="number">5</span>);</span><br><span class="line">        Iterator it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">            String str = (String) it.next();</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题  <code>java.lang.ClassCastException</code>  。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时<code>ClassCastException</code>。 怎么来解决这个问题呢？</p><p><strong>Collection</strong>虽然可以存储各种对象，但实际上通常<strong>Collection</strong>只存储同一类型对象。例如都是存储字符串对象。因此在<strong>JDK5</strong>之后，新增了<strong>泛型 (Generic)</strong>语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><code>泛型  :可以在类或方法中预支地使用未知的类型。</code></li><li>一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</li></ul><h4 id="2-使用泛型的好处"><a href="#2-使用泛型的好处" class="headerlink" title="2. 使用泛型的好处"></a>2. 使用泛型的好处</h4><ul><li><p><code>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</code></p></li><li><p><code>避免了类型强转的麻烦。</code></p></li></ul><p>通过如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// 当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// list.add(5);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</code></p></blockquote><h4 id="3-泛型的使用"><a href="#3-泛型的使用" class="headerlink" title="3. 泛型的使用"></a>3. 泛型的使用</h4><blockquote><p>因为我们在集合中会大量使用到泛型，所以这里来完整地学习泛型知识。</p><ul><li><code>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中，将数据类型作为参数进行传递。</code></li><li>泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; </span><br><span class="line">        /... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">        /... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>在创建对象的时候确定泛型</strong>  </p><p>例如， <code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，<code>变量E的值就是String类型</code>,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; </span><br><span class="line">        /... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">        /... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如， <code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量<strong>E</strong>的值就是<strong>Integer</strong>类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="含有泛型的方法、类和接口"><a href="#含有泛型的方法、类和接口" class="headerlink" title="含有泛型的方法、类和接口"></a>含有泛型的方法、类和接口</h5><h4 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h4><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过<code>通配符&lt;?&gt;</code>表示。但是一旦使用泛型的通配符后，只能使用<strong>Object</strong>类中的共性方法，集合中元素自身方法无法使用。</p><p><strong>通配符基本使用</strong>  </p><p>泛型的通配符:  <code>不知道使用什么类型来接收的时候，此时可以使用?，?表示未知通配符</code>。  </p><p>此时只能接受数据，不能往该集合中存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 因为，添加数据可以多次添加,每次添加的类型也不能保证，所以使用泛型通配符的时候不能存储数据</span></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// list.add(111); </span></span><br><span class="line"><span class="comment">// 如果在List上添加泛型通配符则不能使用add方法，在编译器就报错。</span></span><br></pre></td></tr></table></figure><h5 id="通配符高级使用–受限泛型"><a href="#通配符高级使用–受限泛型" class="headerlink" title="通配符高级使用–受限泛型"></a>通配符高级使用–受限泛型</h5><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><h6 id="泛型的上限"><a href="#泛型的上限" class="headerlink" title="泛型的上限"></a>泛型的上限</h6><ul><li><p><strong>格式</strong>  :<code>类型名称 &lt;? extends 类 &gt; 对象名称</code></p></li><li><p><strong>意义</strong>  ： 只能接收该类型及其子类</p></li><li><pre><code class="java"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>{}&lt;!--￼<span class="number">6</span>--&gt;</code></pre></li></ul><p>比如：现已知<strong>Object</strong>类，<strong>String</strong> 类，<strong>Number</strong>类，<strong>Integer</strong>类，其中<strong>Number</strong>是<strong>Integer</strong>的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;驿寄梅花，鱼传尺素。砌成此恨无重数。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——秦观《踏莎行》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/2.Java集合基础之Iterator迭代器</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/2.Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E4%B9%8BIterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/2.Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E4%B9%8BIterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2020-12-19T10:57:43.912Z</published>
    <updated>2020-12-19T11:56:29.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>往事悠悠君莫问，回头。槛外长江空自流。</p><p align="right">——王安石《南乡子》</p><a id="more"></a>## Java集合基础之Iterator迭代器<h4 id="1-Iterator-接口"><a href="#1-Iterator-接口" class="headerlink" title="1. Iterator 接口"></a>1. Iterator 接口</h4><blockquote><ol><li><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。</p></li><li><p><code>Iterator</code> 接口也是Java集合中的一员，但它与 <code>Collection</code> 、<code>Map</code> 接口有所不同，Collection<code>接口与</code>Map<code>接口主要用于存储元素，而</code> Iterator <code>主要用于迭代访问（即遍历）</code> Collection<code>中的元素，因此</code>Iterator对象也被称为迭代器。</p></li><li><p>想要遍历<code>Collection</code>集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p></li><li><pre><code class="java"><span class="comment">// 获取集合对应的迭代器，用来遍历集合中的元素的。</span><span class="comment">// Collection接口中的抽象方法</span><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">// 可以通过list.iterator()拿到list集合对应的迭代器。</span>&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol></blockquote><blockquote><p>使用Iterator迭代集合中元素：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历 每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">// 泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生<code>java.util.NoSuchElementException没有集合元素的错误</code>。</p></blockquote><h4 id="2-迭代器的实现原理"><a href="#2-迭代器的实现原理" class="headerlink" title="2. 迭代器的实现原理"></a>2. 迭代器的实现原理</h4><p>我们在之前案例已经完成了<strong>Iterator</strong>遍历集合的整个过程。当遍历集合时，首先通过调用集合的<strong>iterator()</strong>方法获得迭代器对象，然后使用<strong>hashNext()</strong>方法判断集合中是否存在下一个元素，如果存在，则调用<strong>next()</strong>方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p><strong>Iterator</strong>迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，通过一个图例来演示<strong>Iterator</strong>对象迭代元素的过程：</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/1563691923890.png" alt="1563691923890"></p><p>在调用<strong>Iterator</strong>的<strong>next</strong>方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的<strong>next</strong>方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用<strong>next</strong>方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到<strong>hasNext</strong>方法返回<strong>false</strong>，表示到达了集合的末尾，终止对元素的遍历。</p><h4 id="3-增强for循环"><a href="#3-增强for循环" class="headerlink" title="3. 增强for循环"></a>3. 增强for循环</h4><p>增强<strong>for</strong>循环(也称<code>for each循环</code>)是  <strong>JDK1.5</strong>  以后出来的一个高级<strong>for</strong>循环，<code>专门用来遍历数组和集合的</code>。它的内部原理其实是个<strong>Iterator</strong>迭代器，所以在遍历的过程中，<code>不能对集合中的元素进行增删操作</code>。</p><blockquote><p>增强<strong>for</strong>循环遍历数组和集合  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">        coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">        coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历集合</span></span><br><span class="line">        <span class="keyword">for</span>(String s :coll)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>目标只能是Collection或者是数组。</li><li>增强<strong>for</strong>循环仅仅作为遍历操作出现。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;往事悠悠君莫问，回头。槛外长江空自流。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——王安石《南乡子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-集合/1.Collection集合概述</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/1.Collection%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E9%9B%86%E5%90%88/1.Collection%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</id>
    <published>2020-12-19T10:57:43.910Z</published>
    <updated>2020-12-19T11:56:29.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>驿寄梅花，鱼传尺素。砌成此恨无重数。</p><p align="right">——秦观《踏莎行》</p><a id="more"></a>## Collection 集合<h4 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1. 集合概述"></a>1. 集合概述</h4><blockquote><p>集合是java中提供的一种容器，可以用来存储多个多种数据。</p><p>集合和数组既然都是容器，它们有啥区别呢？</p><ol><li><code>数组的长度是固定的。集合的长度是可变的。</code></li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值，集合存储的都是对象。而且对象的类型可以不一致。<code>在开发中一般当对象多的时候，使用集合进行存储。</code></li></ol></blockquote><h4 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2. 集合框架"></a>2. 集合框架</h4><blockquote><p>集合按照其存储结构可以分为两大类，分别是</p><ul><li>单列集合 <code>java.util.Collection</code> </li><li>双列集合 <code>java.util.Map</code> </li></ul><p><code>Collection</code>  ：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code> 和 <code>java.util.Set</code> 。其中：</p><ol><li><code>List</code> 的特点是<strong>元素有序、元素可重复</strong>。<ul><li><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code> 和<code>java.util.LinkedList</code> </li></ul></li><li><code>Set</code> 的特点是<strong>元素无序，而且不可重复</strong>。<ul><li><code>Set</code> 接口的主要实现类有<code>java.util.HashSet</code>和 <code>java.util.TreeSet</code> 。</li></ul></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/1563690476704.png" alt="1563690476704"></p><blockquote><p>集合本身是一个工具，它存放在<code>java.util</code>包中。在 <code>Collection</code>接口定义着<code>单列集合框架中最最共性的内容。</code></p></blockquote><h4 id="3-Collection-常用方法"><a href="#3-Collection-常用方法" class="headerlink" title="3. Collection 常用方法"></a>3. Collection 常用方法</h4><blockquote><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可</p><p>用于操作所有的单列集合。方法如下：</p><ul><li><p><code>public boolean add(E e)</code> ： 把给定的对象添加到当前集合中 。</p></li><li><p><code>public void clear()</code> :清空集合中所有的元素。</p></li><li><p><code>public boolean remove(E e)</code> : 把给定的对象在当前集合中删除。</p></li><li><p><code>public boolean contains(E e)</code> : 判断当前集合中是否包含给定的对象。</p></li><li><p><code>public boolean isEmpty()</code> : 判断当前集合是否为空。</p></li><li><p><code>public int size()</code> : 返回集合中元素的个数。</p></li><li><p><code>public Object[] toArray()</code> : 把集合中的元素，存储到数组中。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="comment">// 使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用方法</span></span><br><span class="line">        <span class="comment">// 添加功能 boolean add(String s)</span></span><br><span class="line">        coll.add(<span class="string">"小李广"</span>);</span><br><span class="line">        coll.add(<span class="string">"扫地僧"</span>);</span><br><span class="line">        coll.add(<span class="string">"石破天"</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">        System.out.println(<span class="string">"判断 扫地僧 是否在集合中 "</span>+coll.contains(<span class="string">"扫地僧"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除石破天："</span>+coll.remove(<span class="string">"石破天"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">        System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// void clear() 清空集合</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// boolean isEmpty() 判断是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;驿寄梅花，鱼传尺素。砌成此恨无重数。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——秦观《踏莎行》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-集合" scheme="http://www.itbuild.cn/categories/JavaSE-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-多线程/2.JavaSE-线程池详解</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.JavaSE-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.JavaSE-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-19T10:57:43.825Z</published>
    <updated>2020-12-19T11:56:29.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>了却君王天下事，赢得生前身后名。可怜白发生！</p><p align="right">——辛弃疾《破阵子》</p><a id="more"></a><h3 id="线程池☆"><a href="#线程池☆" class="headerlink" title="线程池☆"></a>线程池☆</h3><h4 id="1-1-线程池思想概述"><a href="#1-1-线程池思想概述" class="headerlink" title="1.1 线程池思想概述"></a>1.1 线程池思想概述</h4><blockquote><ol><li>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：<code>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</code></li><li>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。</li></ol></blockquote><h4 id="1-2-线程池概念"><a href="#1-2-线程池概念" class="headerlink" title="1.2 线程池概念"></a>1.2 线程池概念</h4><blockquote><ol><li><p>线程池：<code>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</code></p></li><li><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1564054291382.png" alt="1564054291382"></li></ul></li><li><p>合理利用线程池能够带来三个好处：</p><ol><li><p><code>降低资源消耗。</code>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p></li><li><p><code>提高响应速度。</code>当任务到达时，任务可以不需要的等待线程创建就能立即执行。</p></li><li><p><code>提高线程的可管理性。</code>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(<code>每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机</code>)。</p></li></ol></li></ol></blockquote><h4 id="1-3-线程池的使用"><a href="#1-3-线程池的使用" class="headerlink" title="1.3 线程池的使用"></a>1.3 线程池的使用</h4><h6 id="创建线程池对象"><a href="#创建线程池对象" class="headerlink" title="创建线程池对象"></a>创建线程池对象</h6><blockquote><ol><li>Java里面线程池的顶级接口是 <code>java.util.concurrent.Executor</code> ，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <code>java.util.concurrent.ExecutorService</code> 。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201022203352066.png" alt="image-20201022203352066"></li><li>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code> 线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。<code>官方建议使用Executors工程类来创建线程池对象。</code></li><li>Executors类中有个创建线程池的方法如下：<ul><li><code>Executors.newCachedThreadPool()：</code>创建一个可根据需要创建新线程的线程池</li><li><code>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池</code></li><li><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</li><li><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池，它可安排在给定延迟后运<br>行命令或者定期地执行。</li></ul></li></ol></blockquote><h6 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h6><blockquote><ol><li><p>获取到了一个线程池<code>ExecutorService</code> 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的<code>某一个线程对象，并执行。</code></p></li><li><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></li></ul></li></ol></blockquote><h6 id="使用线程池中线程对象的步骤："><a href="#使用线程池中线程对象的步骤：" class="headerlink" title="使用线程池中线程对象的步骤："></a>使用线程池中线程对象的步骤：</h6><blockquote><ol><li><p>创建线程池对象。</p></li><li><p>创建Runnable接口子类对象，即线程任务task。</p></li><li><p>提交Runnable接口子类对象,即提交执行线程任务task。</p></li><li><p>关闭线程池(一般不做)。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要一个教练"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"教练来了： "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"教我游泳,交完后，教练回到了游泳池"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程池测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ‐‐‐&gt; 调用MyRunnable中的run()</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;了却君王天下事，赢得生前身后名。可怜白发生！&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——辛弃疾《破阵子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-多线程" scheme="http://www.itbuild.cn/categories/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-多线程/1.JavaSE-多线程基础知识</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-12-19T10:57:43.822Z</published>
    <updated>2020-12-19T11:56:29.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>无奈夜长人不寐，数声和月到帘栊。</p><p align="right">——李煜《捣练子令》</p><a id="more"></a><h2 id="JavaSE-多线程基础知识"><a href="#JavaSE-多线程基础知识" class="headerlink" title="JavaSE-多线程基础知识"></a>JavaSE-多线程基础知识</h2><blockquote><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？要解决上述问题,咱们得使用多进程或者多线程来解决。</p></blockquote><h3 id="1-多线程知识储备"><a href="#1-多线程知识储备" class="headerlink" title="1. 多线程知识储备"></a>1. 多线程知识储备</h3><h4 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h4><blockquote><ol><li><p>并行：指两个或多个事件在<code>同一时刻</code>发生（同时发生）。</p></li><li><p>并发：指两个或多个事件在<code>同一个时间段内</code>发生。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563707140260.png" alt="1563707140260"></p><blockquote><ol><li>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 <code>CPU</code> 系统中，每一时刻只能有一道程序执行，<code>即微观上这些程序是分时的交替运行，</code>只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</li><li><code>而在多个 CPU 系统中</code>，则这些可以并发执行的程序便可以分配到多个处理器上（<code>cpu</code>），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。<code>目前电脑市场上说的多核CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</code></li><li><code>注意：</code>单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，<code>当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</code></li></ol></blockquote><h4 id="1-2-线程与进程"><a href="#1-2-线程与进程" class="headerlink" title="1.2 线程与进程"></a>1.2 线程与进程</h4><blockquote><ol><li><code>进程：</code>是指一个内存中运行的应用程序，<code>每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；</code>进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><code>线程：</code>进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为一个进程便相当于一个单 <code>CPU</code> 操作系统，而线程便是这个系统中运行的多个任务。</li><li>我们可以再电脑底部任务栏—-&gt;右键—–&gt;打开任务管理器，可以查看当前任务的进程和线程：<ol><li>进程<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563707304548.png" alt="1563707304548"></li></ul></li><li>线程<ul><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563707337257.png" alt="1563707337257"></li></ul></li></ol></li></ol></blockquote><h6 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h6><blockquote><ol><li><p><code>进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</code></p></li><li><p><code>线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</code></p></li><li><p><a href="https://blog.csdn.net/weixin_45267102/article/details/108550380" target="_blank" rel="noopener">有JVM相关基础之后理解起来好透彻哈哈哈</a></p></li><li><p>因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于CPU 的调度，程序员是干涉不了的。<code>而这也就造成的多线程的随机性。</code></p></li><li><p><code>Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。</code></p></li><li><p>由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p></li></ol></blockquote><h6 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h6><blockquote><p>计算机通常只有一个<code>CPU</code>时,在任意时刻只能执行一条计算机指令,每一个进程只有获得<code>CPU</code>的使用权才能执行指令。所谓多进程并发运行,从宏观上看,其实是各个进程轮流获得<code>CPU</code>的使用权,分别执行各自的任务。那么,在可运行池中,会有多个线程处于就绪状态等到<code>CPU</code>,<code>JVM</code>就负责了线程的调度。<code>JVM采用的是抢占式调度,没有采用分时调度,因此可以能造成多线程执行结果的的随机性。</code></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201022200132750.png" alt="image-20201022200132750"></p><p>线程的优先级等级：</p><ol><li><code>MAX_PRIORITY ：10</code></li><li><code>MIN _PRIORITY ：1</code></li><li><code>NORM_PRIORITY ：5</code></li></ol><p>涉及的方法：</p><ol><li><code>getPriority() ：</code>返回线程优先值；</li><li><code>setPriority(int newPriority) ：</code>改变线程的优先级；</li></ol><p>说明：</p><ol><li>线程创建时继承父线程的优先级；</li><li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用；</li></ol></blockquote><h4 id="1-3-创建线程类"><a href="#1-3-创建线程类" class="headerlink" title="1.3 创建线程类"></a>1.3 创建线程类</h4><blockquote><p>Java使用<code>java.lang.Thread</code> 类代表<code>线程</code>，<code>所有的线程对象都必须是Thread类或其子类的实例。</code>每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。<code>Java中通过继承Thread类来创建并启动多线程的步骤如下：</code></p><ol><li><p>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此<code>把run()方法称为线程执行体。</code></p></li><li><p>创建Thread子类的实例，即创建了线程对象。</p></li><li><p><code>调用线程对象的start()方法来启动该线程</code>。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"新的线程！"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启新线程</span></span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="comment">// 在主方法中执行for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程！"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义线程类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义指定线程名称的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写run方法，完成该线程执行的逻辑 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-线程☆"><a href="#2-线程☆" class="headerlink" title="2. 线程☆"></a>2. 线程☆</h3><h4 id="2-1-多线程原理☆"><a href="#2-1-多线程原理☆" class="headerlink" title="2.1 多线程原理☆"></a>2.1 多线程原理☆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 利用继承中的特点</span></span><br><span class="line">    <span class="comment">// 将线程名称传递 进行设置</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="comment">//定义线程要执行的代码    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//getName()方法 来自父亲</span></span><br><span class="line">            System.out.println(getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>测试类：</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里是main线程"</span>);</span><br><span class="line">        </span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"小强"</span>);</span><br><span class="line">        mt.start();<span class="comment">//开启了一个新的线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"旺财:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>流程图：</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563708833337.png" alt="1563708833337"></p><blockquote><ol><li><p>程序启动运行<code>main</code>时候，java虚拟机启动一个进程，<code>主线程main在main()调用时候被创建。</code>随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p></li><li><p><code>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</code></p></li><li><p><a href="https://blog.csdn.net/weixin_45267102/article/details/108606932" target="_blank" rel="noopener">多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</a></p></li><li><p>多线程执行时，在栈内存中，其实<code>每一个执行线程都有一片自己所属的栈内存空间</code>。进行方法的压栈和弹栈。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563709003007.png" alt="1563709003007"></p><blockquote><p><code>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</code></p></blockquote><h4 id="2-2-Thread类"><a href="#2-2-Thread类" class="headerlink" title="2.2 Thread类"></a>2.2 Thread类</h4><blockquote><ol><li>在前面我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了<code>java.lang.Thread</code> 类，API中该类中定义了有关线程的一些方法，具体如下：</li><li>构造方法：<ul><li><code>public Thread()</code> :分配一个新的线程对象。</li><li><code>public Thread(String name)</code> :分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</li></ul></li><li>常用方法：<ul><li><code>public String getName()</code> :获取当前线程名称。</li><li><code>public void start()</code> :导致此线程开始执行; <code>Java虚拟机调用此线程的run方法。</code></li><li><code>public void run()</code> :此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</li></ul></li><li>创建线程的方式总共有三种：<ul><li>第一种是继承<code>Thread类</code>方式，上面我们已经使用过了。</li><li>第二种是实现<code>Runnable接口</code>方式</li><li>第三种种是是实现<code>Callable接口</code>和<code>Future</code>创建线程。</li></ul></li></ol></blockquote><h4 id="2-3-实现Runnable接口创建线程"><a href="#2-3-实现Runnable接口创建线程" class="headerlink" title="2.3 实现Runnable接口创建线程"></a>2.3 实现Runnable接口创建线程</h4><blockquote><p>采用 <code>java.lang.Runnable</code> 也是非常常见的一种，<code>我们只需要重写run方法即可。</code></p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li><code>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</code></li><li><code>调用线程对象的start()方法来启动线程。</code></li><li>代码如下：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义类对象 线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">"小强"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"旺财 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>通过实现<code>Runnable</code>接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在<code>run</code>方法里面。<code>Thread</code>类实际上也是实现了<code>Runnable</code>接口的类。</p></li><li><p>在启动的多线程的时候，需要先通过<code>Thread</code>类的构造方法<code>Thread(Runnable target)</code> 构造出对象，然后调用<code>Thread</code>对象的<code>start()</code>方法来运行多线程代码。</p></li><li><p>实际上所有的多线程代码都是通过运行<code>Thread</code>的<code>start()</code>方法来运行的。因此，不管是继承<code>Thread</code>类还是实现<code>Runnable</code>接口来实现多线程，最终还是通过<code>Thread</code>的对象的<code>API</code>来控制线程的，熟悉<code>Thread</code>类的<code>API</code>是进行多线程编程的基础。</p></li><li><p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p></li><li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="comment">//....</span>}&lt;!--￼<span class="number">4</span>--&gt;</code></pre></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201020190433507.png" alt="image-20201020190433507"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/10/20 18:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableThread callableThread = <span class="keyword">new</span> CallableThread();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableThread);</span><br><span class="line">        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        </span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Callable不能直接获取返回值，需要用FutureTask&lt;V&gt;在外部封装一下再获取返回值</span></span><br><span class="line">            System.out.println( futureTask.get() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-Thread和Runnable的区别"><a href="#2-5-Thread和Runnable的区别" class="headerlink" title="2.5 Thread和Runnable的区别"></a>2.5 Thread和Runnable的区别</h4><blockquote><ol><li>如果一个类继承<code>Thread</code>，则不适合资源共享。但是如果实现了<code>Runnable</code>接口的话，则很容易的实现资源共享。</li><li>通过下面的例子就可以理解实现Runnable,很容易实现资源的共享。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/10/20 19:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadRunnable d = <span class="keyword">new</span> MyThreadRunnable();</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结果：</span></span><br><span class="line"><span class="comment">         * num = 5</span></span><br><span class="line"><span class="comment">         * num = 4</span></span><br><span class="line"><span class="comment">         * num = 3</span></span><br><span class="line"><span class="comment">         * num = 2</span></span><br><span class="line"><span class="comment">         * num = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"num = "</span> + num);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>实现Runnable接口比继承Thread类所具有的优势：</code></p><ol><li><code>适合多个相同的程序代码的线程去共享同一个资源。</code></li><li><code>可以避免java中的单继承的局限性。</code></li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li><code>线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类。</code></li><li>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</li></ol></blockquote><h4 id="2-6-匿名内部类方式实现线程的创建"><a href="#2-6-匿名内部类方式实现线程的创建" class="headerlink" title="2.6 匿名内部类方式实现线程的创建"></a>2.6 匿名内部类方式实现线程的创建</h4><blockquote><ol><li><code>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</code></li><li>使用匿名内部类的方式实现<code>Runnable</code>接口，重新<code>Runnable</code>接口中的<code>run</code>方法：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"张宇:"</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"费玉清:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-线程的分类"><a href="#2-7-线程的分类" class="headerlink" title="2.7 线程的分类"></a>2.7 线程的分类</h4><blockquote><ol><li><p>Java中的线程分为两类：<code>一种是守护线程，一种是用户线程。</code>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</p></li><li><p>==守护线程是用来服务用户线程的，通过在start()方法前调用==</p></li><li><p><code>thread.setDaemon(true)可以把一个用户线程变成一个守护线程。</code></p></li><li><p>Java垃圾回收就是一个典型的守护线程。</p></li><li><p>若JVM中都是守护线程，当前JVM将退出。</p></li><li><p>形象理解：兔死狗烹，鸟尽弓藏</p></li></ol></blockquote><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><h4 id="3-1-线程安全"><a href="#3-1-线程安全" class="headerlink" title="3.1 线程安全"></a>3.1 线程安全</h4><blockquote><ol><li><p><code>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</code></p></li><li><p>我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个，即本场电影只能卖100张票。</p></li><li><p>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)</p><ul><li><p>需要窗口，采用线程对象来模拟；</p></li><li><p>需要票，<code>Runnable</code>接口子类来模拟。</p></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 执行卖票操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作</span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖:"</span> + ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程任务对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个窗口对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">        <span class="comment">//同时卖票</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果中有一部分这样现象：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563709409456.png" alt="1563709409456"></p><blockquote><p>发现程序出现了两个问题：</p><ol><li><p><code>相同的票数,比如5这张票被卖了两回。</code></p></li><li><p><code>不存在的票，比如0票与-1票，是不存在的</code>。</p></li></ol><p><code>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</code></p><p>==线程安全问题都是由全局变量及静态变量引起的。==若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><h4 id="3-2-线程同步"><a href="#3-2-线程同步" class="headerlink" title="3.2 线程同步"></a>3.2 线程同步</h4><blockquote><ol><li><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p></li><li><p>要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制(<code>synchronized</code>)来解决。</p></li><li><p>根据案例简述：</p><ul><li>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</li></ul></li><li><p>为了保证每个线程都能正常执行原子操作，<code>Java引入了线程同步机制。那么怎么去使用呢？有三种方式完成同步操作：</code></p><ol><li><p><code>同步代码块。</code></p></li><li><p><code>同步方法。</code></p></li><li><p><code>锁机制。</code></p></li></ol></li></ol></blockquote><h6 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h6><blockquote><ol><li><p><code>同步代码块</code>： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p></li><li><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line"><span class="comment">// 需要同步操作的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>同步锁:</code>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。<ul><li>锁对象 可以是任意类型。</li><li><code>多个线程对象要使用同一把锁。</code></li></ul></li></ul></li><li><p><code>在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等(BLOCKED)</code>。</p></li><li><p>使用同步代码块解决买票出现的线程安全问题：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行卖票操作</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                    <span class="comment">//出票操作</span></span><br><span class="line">                    <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>当使用了同步代码块后，上述的线程的安全问题，解决了。</code></p></blockquote><h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h6><blockquote><ol><li><p><code>同步方法:使用synchronized修饰的方法,就叫做同步方法</code>。保证A线程执行该方法的时候,其他线程只能在方法外等着。</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 可能会产生线程安全问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步锁是谁?</p><ul><li><code>对于非static方法,同步锁就是this。</code></li><li><code>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</code></li></ul></li><li><p>使用同步方法解决买票出现的线程安全问题：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 执行卖票操作</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁对象 是 谁调用这个方法 就是谁</span></span><br><span class="line">    <span class="comment">//隐含 锁对象 就是 this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">            <span class="comment">//出票操作</span></span><br><span class="line">            <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h6><blockquote><ol><li><code>java.util.concurrent.locks.Lock</code> 机制提供了比<code>synchronized</code>代码块和<code>synchronized</code>方法更广泛的锁定操作,同步代码块/同步方法具有的功能<code>Lock</code>都有，除此之外更强大，更体现面向对象。</li><li><code>Lock</code>锁也称同步锁，加锁与释放锁方法化了，如下：<ul><li><code>public void lock()</code>：加同步锁。</li><li><code>public void unlock()</code> ：释放同步锁。</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//执行卖票操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作</span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h6><blockquote><ol><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li></ol></blockquote><h6 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h6><blockquote><ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</li><li>应尽量避免使用suspend()和resume()来控制线程</li></ol></blockquote><h6 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h6><blockquote><p><code>死锁：</code></p><ol><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li></ol><p><code>解决方法：</code></p><ol><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ol></blockquote><h3 id="4-线程状态☆"><a href="#4-线程状态☆" class="headerlink" title="4. 线程状态☆"></a>4. 线程状态☆</h3><h4 id="4-1-线程状态概述"><a href="#4-1-线程状态概述" class="headerlink" title="4.1 线程状态概述"></a>4.1 线程状态概述</h4><blockquote><ol><li>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。<code>在线程的生命周期中，有几种状态呢？</code></li><li>在<code>API</code>中<code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p></blockquote><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td>Runnable(可运行）</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，<code>必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</code></td></tr><tr><td><code>TimedWaiting(计时等待)</code></td><td><code>同waiting状态，有几个方法有超时参数，调用他们将进入TimedWaiting状态</code>。这一状态将一直保持到超时期满或者接收到唤醒通知。<code>带有超时参数的常用方法有Thread.sleep 、Object.wait。</code></td></tr><tr><td><code>Teminated(被终止)</code></td><td><code>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</code></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200303194713985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6cGJyaWdodA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><code>线程创建之后它将处于 NEW（新建） 状态，调用  start() 方法后开始运行，线程这时候处于 READY（可运行）状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。</code></p><ul><li>操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为RUNNABLE（运行中） 状态 。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201020205507332.png" alt="image-20201020205507332"></li></ul></blockquote><h6 id="TimedWaiting（计时等待）"><a href="#TimedWaiting（计时等待）" class="headerlink" title="TimedWaiting（计时等待）"></a>TimedWaiting（计时等待）</h6><blockquote><ol><li><code>Timed Waiting</code>在<code>API</code>中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。</li><li>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)。</li></ol></blockquote><h6 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h6><blockquote><ol><li><code>Blocked</code>状态在<code>API</code>中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</li><li>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程<code>A</code>与线程<code>B</code>代码中使用同一锁，如果线程<code>A</code>获取到锁，线程<code>A</code>进入到<code>Runnable</code>状态，那么线程<code>B</code>就进入到<code>Blocked</code>锁阻塞状态。</li></ol></blockquote><h6 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h6><blockquote><ol><li><code>Wating</code>状态在<code>API</code>中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</li><li>一个调用了某个对象的 <code>Object.wait</code> 方法的线程会等待另一个线程调用此对象的<code>Object.notify()</code>方法 或 <code>Object.notifyAll()</code>方法。</li></ol></blockquote><h3 id="5-等待唤醒机制"><a href="#5-等待唤醒机制" class="headerlink" title="5. 等待唤醒机制"></a>5. 等待唤醒机制</h3><h4 id="5-1-线程间通信"><a href="#5-1-线程间通信" class="headerlink" title="5.1 线程间通信"></a>5.1 线程间通信</h4><blockquote><ol><li><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</li><li>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1564054028536.png" alt="1564054028536"></li><li>为什么要处理线程间通信？<ul><li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</li></ul></li><li>如何保证线程间通信有效利用资源？<ul><li>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。<code>而这种手段即——等待唤醒机制。</code></li></ul></li></ol></blockquote><h4 id="5-2-等待唤醒机制"><a href="#5-2-等待唤醒机制" class="headerlink" title="5.2 等待唤醒机制"></a>5.2 等待唤醒机制</h4><blockquote><ol><li><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p></li><li><p>就是在一个线程进行了规定操作后，就进入等待状态wait()， 等待其他线程执行完他们的指定代码过后再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p></li><li><p><code>wait/notify 就是线程间的一种协作机制。</code></p></li><li><p>等待唤醒中的方法：</p><ol><li><code>wait：</code>线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<code>特别的动作</code>，也即是<code>“通知（notify）”</code>在这个对象上等待的线程从wait set 中释放出来，<code>重新进入到调度队列（ready queue）中。</code></li><li><code>notify：</code>则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li><code>notifyAll：</code>则释放所通知对象的 wait set 上的全部线程。、</li></ol></li><li><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p></li><li><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态;</li></ul></li><li><p><code>调用wait和notify方法需要注意的细节</code></p><ol><li><p><strong>wait</strong>方法与<strong>notify</strong>方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过<strong>notify</strong>唤醒使用同一个锁对象调用的wait方法后的线程。</p></li><li><p><strong>wait</strong>方法与<strong>notify</strong>方法是属于<strong>Object</strong>类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了<strong>Object</strong>类的。</p></li><li><p><strong>wait</strong>方法与<strong>notify</strong>方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过<strong>锁</strong>对象调用这2个方法。 </p></li></ol></li></ol></blockquote><h4 id="5-3-生产者与消费者问题"><a href="#5-3-生产者与消费者问题" class="headerlink" title="5.3 生产者与消费者问题"></a>5.3 生产者与消费者问题</h4><blockquote><ol><li><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p></li><li><p><code>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</code>包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</p></li><li><p>代码演示：</p></li></ol></blockquote><h6 id="包子资源类"><a href="#包子资源类" class="headerlink" title="包子资源类"></a>包子资源类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pier;</span><br><span class="line">    </span><br><span class="line">    String xianer;</span><br><span class="line">    <span class="comment">//包子资源 是否存在 包子资源状态</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="吃货线程类"><a href="#吃货线程类" class="headerlink" title="吃货线程类"></a>吃货线程类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃"</span>+bz.pier+bz.xianer+<span class="string">"包子"</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="包子铺线程类"><a href="#包子铺线程类" class="headerlink" title="包子铺线程类"></a>包子铺线程类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源 存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有包子 造包子</span></span><br><span class="line">                System.out.println(<span class="string">"包子铺开始做包子"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮 五仁</span></span><br><span class="line">                    bz.pier = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"五仁"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮 牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"牛肉大葱"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">"包子造好了："</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">"吃货来吃吧"</span>);</span><br><span class="line">                <span class="comment">// 唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">"吃货"</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">"包子铺"</span>,bz);</span><br><span class="line">        </span><br><span class="line">        ch.start();</span><br><span class="line">        </span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行效果：</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;无奈夜长人不寐，数声和月到帘栊。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——李煜《捣练子令》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-多线程" scheme="http://www.itbuild.cn/categories/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/9.JVM之深入理解堆</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/9.JVM%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/9.JVM%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86/</id>
    <published>2020-12-19T10:57:42.736Z</published>
    <updated>2020-12-19T11:56:29.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年花胜去年红。可惜明年花更好，知与谁同？</p><p align="right">——欧阳修《浪淘沙》</p><a id="more"></a><h2 id="JVM之深入理解堆"><a href="#JVM之深入理解堆" class="headerlink" title="JVM之深入理解堆"></a>JVM之深入理解堆</h2><h3 id="1-堆的核心概念"><a href="#1-堆的核心概念" class="headerlink" title="1. 堆的核心概念"></a>1. 堆的核心概念</h3><blockquote><p><code>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706195127740.png" alt="image-20200706195127740"></p><blockquote><ol><li><p>一个JVM实例只存在一个堆内存，<code>堆也是Java内存管理的核心区域。</code></p></li><li><p><code>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</code></p><ul><li><p>堆内存的大小是可以调节的。</p></li><li><pre><code class="java"><span class="comment">// 如果设置最小堆内存和最大堆内存，建议设置成相同值</span>-Xms10m：最小堆内存-Xmx10m：最大堆内存&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li><li><p><code>针对下面的代码</code></p></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>{    StringBuffer sb = <span class="keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    <span class="keyword">return</span> sb;}&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li></ul></li></ol></blockquote><h6 id="逃逸分析代码举例"><a href="#逃逸分析代码举例" class="headerlink" title="逃逸分析代码举例"></a>逃逸分析代码举例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="逃逸分析参数设置"><a href="#逃逸分析参数设置" class="headerlink" title="逃逸分析参数设置"></a>逃逸分析参数设置</h6><blockquote><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析。</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果。</li></ul></blockquote><h6 id="逃逸分析的结论"><a href="#逃逸分析的结论" class="headerlink" title="逃逸分析的结论"></a>逃逸分析的结论</h6><blockquote><p><code>开发中能使用局部变量的，就不要使用在方法外定义。</code></p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li><code>栈上分配：</code>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。</li><li><code>同步省略：</code>如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><code>分离对象或标量替换：</code>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul></blockquote><h4 id="11-2-栈上分配"><a href="#11-2-栈上分配" class="headerlink" title="11.2 栈上分配"></a>11.2 栈上分配</h4><blockquote><ol><li><code>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</code></li><li>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol></blockquote><h6 id="栈上分配举例"><a href="#栈上分配举例" class="headerlink" title="栈上分配举例"></a>栈上分配举例</h6><blockquote><ol><li>我们通过举例来<code>说明 开启逃逸分析 和 未开启逃逸分析时候的情况。</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未发生逃逸</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>设置JVM参数，表示<code>未开启逃逸分析</code>。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>运行结果，同时还触发了GC操作</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：116 ms</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>然后查看内存的情况，发现有大量的User存储在堆中。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200927154516893.png" alt="image-20200927154516893"></p><blockquote><ol start="5"><li>我们在开启逃逸分析。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li><code>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作。</code></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：8 ms</span><br></pre></td></tr></table></figure><blockquote><ol start="7"><li>然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200927154651113.png" alt="image-20200927154651113"></p><h4 id="11-3-同步省略"><a href="#11-3-同步省略" class="headerlink" title="11.3 同步省略"></a>11.3 同步省略</h4><blockquote><ol><li><code>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</code></li><li><code>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。☆</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如下面的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>我们将其转换成字节码</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200707205634266.png" alt="image-20200707205634266"></p><h4 id="11-4-分离对象和标量替换"><a href="#11-4-分离对象和标量替换" class="headerlink" title="11.4 分离对象和标量替换"></a>11.4 分离对象和标量替换</h4><blockquote><ol><li><p><code>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</code></p></li><li><p>相对的，那些<code>还可以分解的数据叫做聚合量（Aggregate）</code>，Java中的对象就是聚合量，因为他可以<code>分解成其他聚合量和标量。</code></p></li><li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>以上代码，经过标量替换后，就会变成</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。<code>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</code></li><li>标量替换为栈上分配提供了很好的基础。</li></ol></blockquote><h6 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h6><blockquote><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure><p>这里设置参数如下：</p><ol><li>参数<code>-server</code>：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析。</li><li>参数<code>-Xmx10m</code>：指定了堆空间最大为10MB。</li><li>参数<code>-XX:+PrintGC</code>：将打印Gc日志。</li><li>参数<code>-xx:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol></blockquote><h4 id="11-5-逃逸分析的不足"><a href="#11-5-逃逸分析的不足" class="headerlink" title="11.5 逃逸分析的不足"></a>11.5 逃逸分析的不足</h4><blockquote><ol><li><p><code>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，</code>而且这项技术到如今也并不是十分成熟的。</p></li><li><p><code>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</code></p><ul><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li></ul></li><li><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。<code>据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</code></p></li><li><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，<code>intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。</code>但是，<code>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</code>，所以这一点同样符合前面一点的结论：<code>对象实例都是分配在堆上。</code></p></li></ol></blockquote><h3 id="12-堆小结"><a href="#12-堆小结" class="headerlink" title="12. 堆小结"></a>12. 堆小结</h3><blockquote><ol><li><code>年轻代</code>是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li><li><code>老年代</code>放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。<ul><li>当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；</li><li>如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</li></ul></li><li><code>当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</code>        </li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年花胜去年红。可惜明年花更好，知与谁同？&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——欧阳修《浪淘沙》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/8.JVM本地方法栈和本地方法接口</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/8.JVM%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/8.JVM%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-12-19T10:57:42.734Z</published>
    <updated>2020-12-19T11:56:29.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>何日请缨提锐旅，一鞭直渡清河洛。却归来、再续汉阳游，骑黄鹤。</p><p align="right">——岳飞《满江红》</p><a id="more"></a><h2 id="JVM本地方法栈和本地方法接口"><a href="#JVM本地方法栈和本地方法接口" class="headerlink" title="JVM本地方法栈和本地方法接口"></a>JVM本地方法栈和本地方法接口</h2><h3 id="1-本地方法接口"><a href="#1-本地方法接口" class="headerlink" title="1. 本地方法接口"></a>1. 本地方法接口</h3><h4 id="1-1-什么是本地方法"><a href="#1-1-什么是本地方法" class="headerlink" title="1.1 什么是本地方法"></a>1.1 什么是本地方法</h4><blockquote><ol><li><p>简单地讲，<code>一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。</code>这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C” 告知 C++ 编译器去调用一个C的函数。</p><ul><li><code>&quot;A native method is a Java method whose implementation is provided by non-java code.&quot;</code>–本地方法是一个非Java的方法，它的具体实现是非Java代码的实现。</li></ul></li><li><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p></li><li><p><code>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706164139252.png" alt="image-20200706164139252"></p><h4 id="1-2-代码举例说明Native方法是如何编写"><a href="#1-2-代码举例说明Native方法是如何编写" class="headerlink" title="1.2 代码举例说明Native方法是如何编写"></a>1.2 代码举例说明Native方法是如何编写</h4><blockquote><p>需要注意的是：<code>标识符native可以与其它java标识符连用，但是abstract除外。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-为什么使用Native-Method？"><a href="#1-3-为什么使用Native-Method？" class="headerlink" title="1.3 为什么使用Native Method？"></a>1.3 为什么使用Native Method？</h4><blockquote><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p></blockquote><h5 id="与Java环境的交互"><a href="#与Java环境的交互" class="headerlink" title="与Java环境的交互"></a>与Java环境的交互</h5><blockquote><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p></blockquote><h5 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h5><blockquote><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了<code>jre</code>的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p></blockquote><h5 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h5><blockquote><p><code>Sun的解释器是用C实现的</code>，这使得它能像一些普通的C一样与外部交互。<code>jre大部分是用Java实现的</code>，它也通过一些本地方法与外界交互。<code>例如：类java.lang.Thread的setPriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority（）。</code>这个本地方法是用C实现的，并被植入JVM内部，<code>在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority（）ApI。</code>这是一个本地方法的具体实现由JVM直接提供，更多的情况是<code>本地方法由外部的动态链接库（external dynamic link library）提供</code>，然后被JVM调用。</p></blockquote><h5 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h5><blockquote><p><code>目前该方法使用的越来越少了，除非是与硬件有关的应用，</code>比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p></blockquote><h3 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2. 本地方法栈"></a>2. 本地方法栈</h3><blockquote><ol><li><p><code>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</code></p></li><li><p>本地方法栈，也是线程私有的。</p></li><li><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 <code>StackOverflowError 异常。</code></p></li><li><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个<code>OutoOfMemoryError异常。</code></p></li></ul></li><li><p><code>本地方法是使用C语言实现的。</code></p></li><li><p><code>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706174708418.png" alt="image-20200706174708418"></p><blockquote><ol><li><p><code>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</code></p><ul><li><p><code>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</code></p></li><li><p>它甚至可以直接使用本地处理器中的寄存器。</p></li><li><p>直接从本地内存的堆中分配任意数量的内存。</p></li></ul></li><li><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p></li><li><p><code>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</code></p></li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;何日请缨提锐旅，一鞭直渡清河洛。却归来、再续汉阳游，骑黄鹤。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——岳飞《满江红》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/7.JVM虚拟机栈</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/7.JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/7.JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2020-12-19T10:57:42.732Z</published>
    <updated>2020-12-19T11:56:29.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切。</p><p align="right">——岳飞《满江红》</p><a id="more"></a><h2 id="JVM虚拟机栈"><a href="#JVM虚拟机栈" class="headerlink" title="JVM虚拟机栈"></a>JVM虚拟机栈</h2><h3 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1. 虚拟机栈概述"></a>1. 虚拟机栈概述</h3><blockquote><ol><li><code>由于跨平台性的设计，Java的指令都是根据栈来设计的。</code>不同平台CPU架构不同，所以不能设计为基于寄存器的。<ul><li>优点是跨平台，指令集小，编译器容易实现；</li><li>缺点是性能下降，实现同样的功能需要更多的指令。</li></ul></li><li>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？</li><li><code>☆栈是运行时的单位，而堆是存储的单位☆</code><ul><li><code>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</code>    </li><li><code>堆解决的是数据存储的问题，即数据怎么放，放哪里</code></li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705163928652.png" alt="image-20200705163928652"></li></ul></li></ol></blockquote><h3 id="2-Java虚拟机栈是什么？"><a href="#2-Java虚拟机栈是什么？" class="headerlink" title="2. Java虚拟机栈是什么？"></a>2. Java虚拟机栈是什么？</h3><blockquote><ol><li><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。<code>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</code></p></li><li><p>Java虚拟机栈是线程私有的，生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。</p></li><li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        StackTest test = <span class="keyword">new</span> StackTest();        test.methodA();    }    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>{        <span class="keyword">int</span> i = <span class="number">10</span>;        <span class="keyword">int</span> j = <span class="number">20</span>;        methodB();    }    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>{        <span class="keyword">int</span> k = <span class="number">30</span>;        <span class="keyword">int</span> m = <span class="number">40</span>;    }}&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200912200645805.png" alt="image-20200912200645805"></p><h5 id="变量Slot的理解"><a href="#变量Slot的理解" class="headerlink" title="变量Slot的理解"></a>变量Slot的理解</h5><blockquote><ol><li><code>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</code></li><li><code>局部变量表，最基本的存储单元是Slot（变量槽）</code>局部变量表中存放编译期可知的各种<code>基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</code></li><li>在局部变量表里<ul><li><code>32位以内的类型只占用一个slot（包括returnAddress类型）</code></li><li><code>64位的类型（1ong和double）占用两个slot</code>。</li><li><code>1byte = 8bit位</code>    <code>byte--short--int--long(1,2,4,8)</code></li></ul></li><li><code>byte、short、char 在存储前被转换为int</code>，boolean也被转换为int，0表示false，非0表示true。</li><li>JVM会为局部变量表中的每一个变量槽Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个变量槽slot上。</li><li><code>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</code></li><li>如果当前帧是由构造方法或者实例方法创建的，那么<code>该对象引用this将会存放在index为0的变量槽Slot处，</code>其余的参数按照参数表顺序继续排列。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705212454445.png" alt="image-20200705212454445"></p><h5 id="变量槽Slot的重复利用"><a href="#变量槽Slot的重复利用" class="headerlink" title="变量槽Slot的重复利用"></a>变量槽Slot的重复利用</h5><blockquote><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200913152041479.png" alt="image-20200913152041479"></p></blockquote><h5 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h5><blockquote><p>变量的分类：</p><ul><li>按数据类型分：<ul><li>基本数据类型</li><li>引用数据类型</li></ul></li><li>按类中声明的位置分：<ul><li>成员变量（类变量，实例变量）<ul><li><code>类变量：linking的paper阶段，给类变量默认赋值，initial阶段给类变量显示赋值即静态代码块赋值。</code></li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值。</li></ul></li><li><code>局部变量：在使用前必须进行显式赋值，不然编译不通过。</code></li></ul></li></ul></blockquote><p><code>进一步了解...</code></p><blockquote><ol><li><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p></li><li><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p></li><li><p><code>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</code></p></li><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。。。</p></li></ol></blockquote><h4 id="4-2-操作数栈-Operand-Stack"><a href="#4-2-操作数栈-Operand-Stack" class="headerlink" title="4.2 操作数栈 Operand Stack"></a>4.2 操作数栈 Operand Stack</h4><blockquote><ol><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的 <strong>操作数栈</strong>。</li><li>操作数栈，<code>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</code><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li><li>比如：执行复制、交换、求和等操作。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706090618332.png" alt="image-20200706090618332"></li></ul></li></ol></blockquote><h5 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h5><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706090833697.png" alt="image-20200706090833697"></p><blockquote><ol><li><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p></li><li><p><code>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的（数组是空的，但是不能表示数组没有创建）。</code></p></li><li><p><code>☆每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</code></p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p><ul><li><p>32bit的类型占用一个栈单位深度；</p></li><li><p>64bit的类型占用两个栈单位深度；</p></li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令。</p></li><li><p><code>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</code></p></li><li><p><code>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</code></p></li></ol></blockquote><h5 id="执行流程如下所示"><a href="#执行流程如下所示" class="headerlink" title="执行流程如下所示"></a>执行流程如下所示</h5><blockquote><ol><li>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为 0，然后<code>使用bipush让操作数15入栈。</code></li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093131621.png" alt="image-20200706093131621"></p><ol start="2"><li><code>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</code></li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093251302.png" alt="image-20200706093251302"></p><ol start="3"><li>为什么局部变量表不是从0开始的呢？<ul><li><code>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了。</code></li><li>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中。</li></ul></li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093751711.png" alt="image-20200706093751711"></p><ol start="4"><li>从局部变量表中，依次将数据放在操作数栈中</li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706093921573.png" alt="image-20200706093921573"></p><ol start="5"><li>然后将操作数栈中的两个元素取出执行相加操作，并存储在局部变量表3的位置。</li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706094109629.png" alt="image-20200706094109629"></p><ol start="6"><li>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</li></ol></blockquote><h5 id="栈顶缓存技术–了解"><a href="#栈顶缓存技术–了解" class="headerlink" title="栈顶缓存技术–了解"></a>栈顶缓存技术–了解</h5><blockquote><ol><li><code>Top Of Stack Cashing</code></li><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了<code>栈顶缓存（Tos，Top-of-Stack Cashing）技术</code>，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</li><li>寄存器：指令更少，执行速度快</li></ol></blockquote><h4 id="4-3-动态链接"><a href="#4-3-动态链接" class="headerlink" title="4.3 动态链接"></a>4.3 动态链接</h4><blockquote><p><code>动态链接：Dynamic Linking</code>（指向运行时常量池的方法引用）、方法返回地址、附加信息 – 有些地方被称为<code>帧数据区</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><ol><li><p>每一个栈帧内部都包含一个指向<code>运行时常量池</code>中该栈帧所属方法的引用。</p></li><li><p>包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：<code>invokedynamic 指令</code>。</p></li><li><p><code>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</code></p></li><li><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的<code>，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</code></p></li><li><p>下图NB，</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要<code>运行时常量池</code>？</p><ul><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ul></blockquote><h4 id="4-4-方法返回地址"><a href="#4-4-方法返回地址" class="headerlink" title="4.4 方法返回地址"></a>4.4 方法返回地址</h4><blockquote><ol><li><p><code>存放调用该方法的pc寄存器的值</code>。一个方法的结束，有两种方式：</p><ul><li>正常执行完成。</li><li>出现未处理的异常，非正常退出。</li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p><ul><li><code>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</code></li><li>而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li></ul></li><li><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；<ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，<code>返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。</code>另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。<ul><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706154554604.png" alt="image-20200706154554604"></li></ul></li></ul></li></ol><ol start="4"><li><code>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</code>。</li><li>正常完成出口和异常完成出口的区别在于：<code>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</code></li></ol></blockquote><h4 id="4-5-一些附加信息"><a href="#4-5-一些附加信息" class="headerlink" title="4.5 一些附加信息"></a>4.5 一些附加信息</h4><blockquote><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：<code>对程序调试提供支持的信息。</code></p></blockquote><h3 id="5-方法调用原理"><a href="#5-方法调用原理" class="headerlink" title="5. 方法调用原理"></a>5. 方法调用原理</h3><blockquote><ol><li><p>在JVM中，将<code>符号引用</code>转换为调用方法的<code>直接引用</code>与方法的绑定机制相关。</p></li><li><p>静态链接</p><ul><li>当一个字节码文件被装载进JVM内部时，如果被<code>调用的目标方法在编译期可知</code>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li></ul></li><li><p>动态链接</p><ul><li>如果被调用的方法<code>在编译期无法被确定下来</code>，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</li></ul></li></ol></blockquote><h4 id="5-1-早-晚期绑定"><a href="#5-1-早-晚期绑定" class="headerlink" title="5.1 早/晚期绑定"></a>5.1 早/晚期绑定</h4><blockquote><ol><li><p>方法的绑定机制–对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<code>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</code></p><ul><li><p>早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></li><li><p>晚期绑定：<code>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</code></p></li></ul></li><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备<code>虚函数</code>的特征，它们相当于<code>C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）</code>。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明早期绑定和晚期绑定的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物进食"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，多管闲事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，天经地义"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-虚-非虚方法"><a href="#5-2-虚-非虚方法" class="headerlink" title="5.2 虚/非虚方法"></a>5.2 虚/非虚方法</h4><blockquote><ol><li><p>子类对象的多态的使用前提：</p><ul><li><code>类的继承关系</code></li><li><code>方法的重写</code></li></ul></li><li><p>非需方法</p><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li><code>静态方法、私有方法、final方法、实例构造器、父类方法（super.method()）都是非虚方法。（不能被重写）</code></li><li>其他方法称为虚方法。</li></ul></li><li><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li><code>invokestatic：调用静态方法，解析阶段确定唯一方法版本</code></li><li><code>invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</code></li><li><code>invokevirtual</code>：调用所有虚方法</li><li><code>invokeinterface</code>：调用接口方法</li><li><code>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</code></li></ul></li><li><p>动态调用指令：</p><ul><li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行。</li><li>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而<code>invokedynamic</code>指令则支持由用户确定方法版本。</li><li>JVM字节码指令集一直比较稳定，<code>一直到Java7中才增加了一个invokedynamic指令</code>，这是Java为了实现动态类型语言支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<code>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</code></li><li><code>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</code></li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析调用中非虚方法、虚方法的测试</span></span><br><span class="line"><span class="comment"> * invokestatic指令和invokespecial指令调用的方法称为非虚方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father show final"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father 普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son private"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">"atguigu.com"</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">"good!"</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">"hello!"</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Father f)</span> </span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son so = <span class="keyword">new</span> Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-动态-静态类型语言"><a href="#5-3-动态-静态类型语言" class="headerlink" title="5.3 动态/静态类型语言"></a>5.3 动态/静态类型语言</h4><blockquote><ol><li><p>动态类型语言和静态类型语言两者的区<code>别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</code></p></li><li><p>说的再直白一点就是，<code>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</code>，这是动态语言的一个重要特征。</p><ul><li><code>Java：String info = &quot;atguigu&quot;;     Java是静态类型语言的，会先编译就进行类型检查</code></li><li><code>JS：var name = &quot;mm&quot;;    var name = 10;    （运行时才进行检查）</code></li></ul></li></ol></blockquote><h4 id="5-4-方法重写的本质"><a href="#5-4-方法重写的本质" class="headerlink" title="5.4 方法重写的本质"></a>5.4 方法重写的本质</h4><blockquote><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回<code>java.lang.IllegalAccessError 异常</code>。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError异常</code>。</li><li><code>IllegalAccessError介绍</code><ul><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li></ul></li></ol></blockquote><h5 id="方法的调用–虚方法表"><a href="#方法的调用–虚方法表" class="headerlink" title="方法的调用–虚方法表"></a>方法的调用–虚方法表</h5><blockquote><ol><li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p></li><li><p><code>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</code></p></li><li><p>虚方法表是什么时候被创建的呢？</p></li><li><p><code>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200706144954070.png" alt="image-20200706144954070"></p><p><code>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</code></p><h3 id="6-栈的相关面试题"><a href="#6-栈的相关面试题" class="headerlink" title="6. 栈的相关面试题"></a>6. 栈的相关面试题</h3><blockquote><ol><li><code>举例栈溢出的情况？（StackOverflowError）</code><ul><li>通过 <code>-Xss</code>设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li><code>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间</code>是有限的。</li></ul></li><li><code>垃圾回收是否涉及到虚拟机栈？</code><ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>分析如下：</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1 的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</code></p></blockquote><h4 id="6-1-运行时数据区是否存在Error和GC？"><a href="#6-1-运行时数据区是否存在Error和GC？" class="headerlink" title="6.1 运行时数据区是否存在Error和GC？"></a>6.1 运行时数据区是否存在Error和GC？</h4><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——岳飞《满江红》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/6.JVM程序计数器</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/6.JVM%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/6.JVM%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2020-12-19T10:57:42.729Z</published>
    <updated>2020-12-19T11:56:29.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>悲欢离合总无情。一任阶前、点滴到天明。</p><p align="right">——蒋捷《虞美人》</p><a id="more"></a><h2 id="JVM-程序计数器"><a href="#JVM-程序计数器" class="headerlink" title="JVM-程序计数器"></a>JVM-程序计数器</h2><blockquote><ol><li><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p></li><li><p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<code>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</code></p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705155551919-1599890568498.png" alt="image-20200705155551919"></p></li><li><p><code>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</code></p></li><li><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p></li><li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。</p></li><li><p><code>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</code></p></li><li><p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p></li></ol></blockquote><h3 id="1-程序计数器作用"><a href="#1-程序计数器作用" class="headerlink" title="1. 程序计数器作用"></a>1. 程序计数器作用</h3><blockquote><p><code>程序计数器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</code>。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705155728557-1599890568499.png" alt="image-20200705155728557"></p><h3 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2. 代码演示"></a>2. 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>javap -v PCRegisterTest.class</code></li><li>然后将代码进行编译成字节码文件，我们再次查看 ，<code>发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</code></li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: ldc           <span class="comment">#2      // String abc</span></span><br><span class="line">12: astore        4</span><br><span class="line">14: getstatic     <span class="comment">#3      // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">17: iload_1</span><br><span class="line">18: invokevirtual <span class="comment">#4      // Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">21: getstatic     <span class="comment">#3      // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">24: iload_3</span><br><span class="line">25: invokevirtual <span class="comment">#4      // Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">28: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><blockquote><p><code>通过程序计数器，我们就可以知道当前程序执行到哪一步了</code> <img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705161007423-1599890568499.png" alt="image-20200705161007423"></p></blockquote><h3 id="3-程序计数器两个常见问题？"><a href="#3-程序计数器两个常见问题？" class="headerlink" title="3. 程序计数器两个常见问题？"></a>3. 程序计数器两个常见问题？</h3><h4 id="3-1-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#3-1-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="3.1 使用PC寄存器存储字节码指令地址有什么用呢？"></a>3.1 使用PC寄存器存储字节码指令地址有什么用呢？</h4><blockquote><ol><li><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p></li><li><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705161409533-1599890568499.png" alt="image-20200705161409533"></p><h4 id="3-2-PC寄存器为什么被设定为线程私有的？"><a href="#3-2-PC寄存器为什么被设定为线程私有的？" class="headerlink" title="3.2 PC寄存器为什么被设定为线程私有的？"></a>3.2 PC寄存器为什么被设定为线程私有的？</h4><blockquote><ol><li><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<code>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</code></p></li><li><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p></li><li><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705161812542-1599890568500.png" alt="image-20200705161812542"></p><h3 id="4-CPU时间片"><a href="#4-CPU时间片" class="headerlink" title="4. CPU时间片"></a>4. CPU时间片</h3><blockquote><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><ul><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p>在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，<code>一种方法就是引入时间片，每个程序轮流执行。</code></p></li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705161849557.png" alt="image-20200705161849557"></p><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;悲欢离合总无情。一任阶前、点滴到天明。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——蒋捷《虞美人》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/5.JVM运行时数据区概述</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/5.JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/5.JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/</id>
    <published>2020-12-19T10:57:42.728Z</published>
    <updated>2020-12-19T11:56:25.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>道是梨花不是。道是杏花不是。白白与红红，别是东风情味。</p><p align="right">——严蕊《如梦令》</p><a id="more"></a><h2 id="JVM运行时数据区概述"><a href="#JVM运行时数据区概述" class="headerlink" title="JVM运行时数据区概述"></a>JVM运行时数据区概述</h2><blockquote><ol><li>本文主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705111640511.png" alt="image-20200705111640511"></li><li>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，<code>就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</code></li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705111843003.png" alt="image-20200705111843003"></li><li><code>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，</code>将通过准备的东西进行制作成精美的菜品。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705112036630.png" alt="image-20200705112036630"></li></ol></blockquote><h3 id="1-运行时数据区的完整图"><a href="#1-运行时数据区的完整图" class="headerlink" title="1. 运行时数据区的完整图"></a>1. 运行时数据区的完整图</h3><blockquote><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行<code>JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</code>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705112416101.png" alt="image-20200705112416101"></p><blockquote><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：</p><ul><li>其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。</li><li>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705112601211.png" alt="image-20200705112601211"></p><blockquote><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li><code>每个线程：独立包括程序计数器、栈、本地栈。</code></li><li><code>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</code></li></ul></blockquote><h3 id="2-系统线程与JVM线程☆"><a href="#2-系统线程与JVM线程☆" class="headerlink" title="2. 系统线程与JVM线程☆"></a>2. 系统线程与JVM线程☆</h3><blockquote><ol><li>线程是一个程序里的运行单元。<code>JVM允许一个应用有多个线程并行的执行。</code></li><li><code>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</code><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul></li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，<code>它就会调用Java线程中的run（）方法。</code></li></ol></blockquote><h4 id="2-1-JVM系统线程"><a href="#2-1-JVM系统线程" class="headerlink" title="2.1 JVM系统线程"></a>2.1 JVM系统线程</h4><blockquote><p>如果你使用<code>jconsole</code>或者是任何一个调试工具，都能看到在后台有许多线程在运行。<code>这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</code></p><ol><li><code>虚拟机线程：</code>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li><code>周期任务线程：</code>这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li><code>GC线程：</code>这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li><code>编译线程：</code>这种线程在运行时会将字节码编译成到本地代码。</li><li><code>信号调度线程：</code>这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ol></blockquote><h4 id="2-2-RunTime类和Thread类"><a href="#2-2-RunTime类和Thread类" class="headerlink" title="2.2 RunTime类和Thread类"></a>2.2 RunTime类和Thread类</h4><blockquote><ol><li><code>java.lang.RunTime</code><ul><li>每个Java应用程序都有一个Runtime类的Runtime ，允许应用程序与运行应用程序的环境进行接口。 </li><li>当前运行时可以从<code>getRuntime方法</code>获得。 </li><li>应用程序无法创建自己的此类的实例。 </li></ul></li><li><code>java.lang.Thread</code><ul><li>线程是程序中执行的线程。 Java虚拟机允许应用程序同时执行多个执行线程。 </li><li>每个线程都有优先权。 具有较高优先级的线程优先于优先级较低的线程执行。 </li><li>每个线程可能也可能不会被标记为守护程序。 </li><li><code>当在某个线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。</code> </li><li>当Java虚拟机启动时，通常有一个非守护进程线程（通常调用某些指定类的名为main的方法）。Java虚拟机将继续执行线程，直到发生以下任一情况： <ul><li>已经调用了Runtime类的exit方法，并且安全管理器已经允许进行退出操作。 </li><li>所有不是守护进程线程的线程都已经死亡，无论是从调用返回到run方法还是抛出超出run方法的run 。</li></ul></li></ul></li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;道是梨花不是。道是杏花不是。白白与红红，别是东风情味。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——严蕊《如梦令》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/4.JVM-类加载子系统</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/4.JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/4.JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-12-19T10:57:42.726Z</published>
    <updated>2020-12-19T11:56:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>薄悻不来门半掩，斜阳。负你残春泪几行。</p><p align="right">——冯延巳《南乡子》</p><a id="more"></a><h2 id="JVM-类加载子系统"><a href="#JVM-类加载子系统" class="headerlink" title="JVM-类加载子系统"></a>JVM-类加载子系统</h2><h3 id="1-JVM整体架构"><a href="#1-JVM整体架构" class="headerlink" title="1. JVM整体架构"></a>1. JVM整体架构</h3><blockquote><p>这个详细版，与J<a href="https://blog.csdn.net/weixin_45267102/article/details/108504237" target="_blank" rel="noopener">VM架构及其生命周期</a>中的第一个图对应。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/mm-1599745342900.png" alt="mm"></p><h3 id="2-类加载子系统的作用"><a href="#2-类加载子系统的作用" class="headerlink" title="2. 类加载子系统的作用"></a>2. 类加载子系统的作用</h3><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200910214534853.png" alt="image-20200910214534853"></p><blockquote><ol><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li><code>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</code></li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li></ol></blockquote><h4 id="2-1-举例说明"><a href="#2-1-举例说明" class="headerlink" title="2.1 举例说明"></a>2.1 举例说明</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705081913538.png" alt="image-20200705081913538"></p><blockquote><ol><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出<code>n</code>个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件–&gt; JVM–&gt;最终成为元数据模板，此过程就要一个运输工具(类装载器Class Loader)，扮演一个快递员的角色。</li></ol></blockquote><h3 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3. 类加载的过程"></a>3. 类加载的过程</h3><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705082601441.png" alt="image-20200705082601441"></p><h4 id="3-1-举例说明"><a href="#3-1-举例说明" class="headerlink" title="3.1 举例说明"></a>3.1 举例说明</h4><blockquote><p>HelloLoader</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"谢谢ClassLoader加载我...."</span>);</span><br><span class="line">        System.out.println(<span class="string">"你的大恩大德，我下辈子再报！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如图：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200910221552142.png" alt="image-20200910221552142"></p><blockquote><p>加载流程：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705082255746.png" alt="image-20200705082255746"></p><h4 id="3-2-加载阶段"><a href="#3-2-加载阶段" class="headerlink" title="3.2 加载阶段"></a>3.2 加载阶段</h4><blockquote><ol><li><code>通过一个类的全限定名获取定义此类的二进制字节流。</code></li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口。</li></ol></blockquote><h6 id="加载-class-文件的方式"><a href="#加载-class-文件的方式" class="headerlink" title="加载 .class 文件的方式"></a>加载 .class 文件的方式</h6><blockquote><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li><code>从zip压缩包中读取，成为日后jar、war格式的基础</code></li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取 .class 文件，比较少见</li><li><code>从加密文件中获取，典型的防Class文件被反编译的保护措施</code></li></ol></blockquote><h4 id="3-3-链接阶段"><a href="#3-3-链接阶段" class="headerlink" title="3.3 链接阶段"></a>3.3 链接阶段</h4><h6 id="验证Verify"><a href="#验证Verify" class="headerlink" title="验证Verify"></a>验证Verify</h6><blockquote><ol><li><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p></li><li><p>主要包括四种验证，<code>文件格式验证，元数据验证，字节码验证，符号引用验证。</code></p></li><li><p>工具：<a href="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/JVM/PXBinaryViewerSetup.exe" target="_blank" rel="noopener">Binary Viewer</a>查看</p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200911170943094.png" alt="image-20200911170943094"></p></li><li><p>如果出现不合法的字节码文件，那么将会验证不通过，同时我们可以通过安装IDEA的插件，来查看我们的Class文件。</p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200911171817613.png" alt="image-20200911171817613"></p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200911171713770.png" alt="image-20200911171713770"></p></li><li><p>当然也可以下载<a href="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/JVM/jclasslib_win64_5_6.exe" target="_blank" rel="noopener">jclasslib_win64_5_6.exe</a>，安装后进行查看。</p></li></ol></blockquote><h6 id="准备Prepare"><a href="#准备Prepare" class="headerlink" title="准备Prepare"></a>准备Prepare</h6><blockquote><ol><li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>{    <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        System.out.println(a);    }}&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li></ol><p><code>我们输出结果为 2，也就是说首先加载ClinitTest的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被赋值成2，最后返回。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载Father类，其次加载Son类。</span></span><br><span class="line">        System.out.println(Son.B);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</p></li><li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        Runnable r = () -&gt; {            System.out.println(Thread.currentThread().getName() + <span class="string">"开始"</span>);            DeadThread dead = <span class="keyword">new</span> DeadThread();            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);        };        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"线程1"</span>);        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"线程2"</span>);        t1.start();        t2.start();    }}<span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>{    <span class="keyword">static</span>{        <span class="keyword">if</span>(<span class="keyword">true</span>){            System.out.println(Thread.currentThread().getName() + <span class="string">"初始化当前类"</span>);            <span class="keyword">while</span>(<span class="keyword">true</span>){            }        }    }}&lt;!--￼<span class="number">3</span>--&gt;</code></pre></li></ol></blockquote><h4 id="4-1-虚拟机自带的加载器"><a href="#4-1-虚拟机自带的加载器" class="headerlink" title="4.1 虚拟机自带的加载器"></a>4.1 虚拟机自带的加载器</h4><h6 id="启动类加载器（引导类加载器-Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器-Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器 Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器 Bootstrap ClassLoader）</h6><blockquote><ol><li>这个类加载<code>使用C/C++语言实现的</code>，嵌套在JVM内部。</li><li>它用来加载<code>Java的核心库</code>（JAVA_HOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，<code>Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。</code></li></ol></blockquote><h6 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h6><blockquote><ol><li>Java语言编写， 由sun.misc.Launcher$ExtClassLoader实现。</li><li><code>派生于ClassLoader类。</code></li><li>父类加载器为启动类加载器</li><li><code>从java.ext.dirs系统属性所指定的目录中加载类库或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</code></li></ol></blockquote><h6 id="应用程序类加载器（系统类加载器-AppClassLoader）"><a href="#应用程序类加载器（系统类加载器-AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器 AppClassLoader）"></a>应用程序类加载器（系统类加载器 AppClassLoader）</h6><blockquote><ol><li>java 语言编写，由sun.misc.LaunchersAppClassLoader实现。</li><li>派生于ClassLoader类。</li><li>父类加载器为扩展类加载器。</li><li><code>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。</code></li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载。</li><li>通过classLoader#getSystemClassLoader（）方法可以获取到该类加载器。</li></ol></blockquote><h6 id="查看加载器所能加载的目录"><a href="#查看加载器所能加载的目录" class="headerlink" title="查看加载器所能加载的目录"></a>查看加载器所能加载的目录</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********启动类加载器**************"</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***********扩展类加载器*************"</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">";"</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/resources.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/rt.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/jsse.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/jce.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/charsets.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/lib/jfr.jar</span><br><span class="line">file:/D:/soft/jdk1<span class="number">.8</span>/jre/classes</span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">D:\soft\jdk1<span class="number">.8</span>\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure><h4 id="4-2-用户自定义类加载器"><a href="#4-2-用户自定义类加载器" class="headerlink" title="4.2 用户自定义类加载器"></a>4.2 用户自定义类加载器</h4><blockquote><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p></blockquote><h6 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h6><blockquote><ol><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ol></blockquote><h6 id="用户自定义类加载器实现步骤："><a href="#用户自定义类加载器实现步骤：" class="headerlink" title="用户自定义类加载器实现步骤："></a>用户自定义类加载器实现步骤：</h6><blockquote><ol><li>开发人员可以通过<code>继承抽象类ava.lang.ClassLoader类</code>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li><code>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中。</code></li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol></blockquote><h4 id="4-3-抽象类ClassLoader"><a href="#4-3-抽象类ClassLoader" class="headerlink" title="4.3 抽象类ClassLoader"></a>4.3 抽象类ClassLoader</h4><blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200911185010408.png" alt="image-20200911185010408"></p><blockquote><p><code>sun.misc.Launcher</code> 它是一个java虚拟机的入口应用。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705103636003.png" alt="image-20200705103636003"></p><h4 id="4-4-获取ClassLoader的途径"><a href="#4-4-获取ClassLoader的途径" class="headerlink" title="4.4 获取ClassLoader的途径"></a>4.4 获取ClassLoader的途径</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200911185255731.png" alt="image-20200911185255731"></p><h3 id="5-☆双亲委派机制☆"><a href="#5-☆双亲委派机制☆" class="headerlink" title="5. ☆双亲委派机制☆"></a>5. ☆双亲委派机制☆</h3><blockquote><p>Java虚拟机对class文件采用的是<code>按需加载的方式</code>，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。<code>而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时加载的不是我们自定义的String类，体现了双亲委派机制。</span></span><br><span class="line">        java.lang.String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">"hello,atguigu.com"</span>);</span><br><span class="line"></span><br><span class="line">        StringTest test = <span class="keyword">new</span> StringTest();</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的String类的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println("hello,String");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-1-工作原理"><a href="#5-1-工作原理" class="headerlink" title="5.1 工作原理"></a>5.1 工作原理</h4><blockquote><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705105151258.png" alt="image-20200705105151258"></p><h4 id="5-2-双亲委派机制举例"><a href="#5-2-双亲委派机制举例" class="headerlink" title="5.2 双亲委派机制举例"></a>5.2 双亲委派机制举例</h4><blockquote><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200705105810107.png" alt="image-20200705105810107"></p><h4 id="5-3-沙箱安全机制"><a href="#5-3-沙箱安全机制" class="headerlink" title="5.3 沙箱安全机制"></a>5.3 沙箱安全机制</h4><blockquote><p><code>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</code></p></blockquote><h4 id="5-4-双亲委派机制的优势"><a href="#5-4-双亲委派机制的优势" class="headerlink" title="5.4 双亲委派机制的优势"></a>5.4 双亲委派机制的优势</h4><blockquote><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li><code>避免类的重复加载</code></li><li><code>保护程序安全，防止核心API被随意篡改</code><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）；</li></ul></li></ul></blockquote><h4 id="5-6-其它"><a href="#5-6-其它" class="headerlink" title="5.6 其它"></a>5.6 其它</h4><h6 id="☆☆如何判断两个class对象是否相同？？"><a href="#☆☆如何判断两个class对象是否相同？？" class="headerlink" title="☆☆如何判断两个class对象是否相同？？"></a>☆☆如何判断两个class对象是否相同？？</h6><blockquote><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li><code>类的完整类名必须一致，包括包名。</code></li><li><code>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</code></li></ul><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么<code>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</code>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p></blockquote><h6 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h6><blockquote><p><code>Java程序对类的使用方式分为：王动使用和被动使用。</code><br>主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p><code>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</code></p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;薄悻不来门半掩，斜阳。负你残春泪几行。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——冯延巳《南乡子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/3.JVM发展历程</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/3.JVM%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/3.JVM%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</id>
    <published>2020-12-19T10:57:42.724Z</published>
    <updated>2020-12-19T11:56:22.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>黯相望。断鸿声里，立尽斜阳。</p><p align="right">——柳永《玉蝴蝶》</p><a id="more"></a><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><blockquote><ol><li>早在1996年Java 1.0 版本的时候，Sun公司发布了一款名为sun Classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。</li><li>如果使用<code>JIT编译器</code>，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ol></blockquote><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><blockquote><ol><li>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<code>Exact Memory Management：准确式内存管理</code></li><li><code>也可以叫Non-Conservative/Accurate Memory Management</code></li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li><code>编译器与解释器混合工作模式</code></li></ul></li><li>只在Solaris平台短暂使用，其他平台上还是classic vm<ul><li>英雄气短，终被Hotspot虚拟机替换</li></ul></li></ol></blockquote><h3 id="HotSpot-VM-☆☆"><a href="#HotSpot-VM-☆☆" class="headerlink" title="HotSpot VM ☆☆"></a>HotSpot VM ☆☆</h3><h4 id="HotSpot-历史"><a href="#HotSpot-历史" class="headerlink" title="HotSpot 历史"></a>HotSpot 历史</h4><blockquote><ol><li>最初由一家名为<code>“Longview Technologies&quot;</code>的小公司设计。</li><li>1997年，此公司被sun收购; </li><li>2009年，sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机。</li></ol></blockquote><h4 id="HostSpot-简介☆"><a href="#HostSpot-简介☆" class="headerlink" title="HostSpot 简介☆"></a>HostSpot 简介☆</h4><blockquote><ol><li><p>目前Hotspot占有绝对的市场地位，称霸武林。</p></li><li><p>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是HotSpot</p></li><li><p>Sun/Oracle JDK 和openJDK的默认虚拟机。</p></li><li><p>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指Hotspot的GC机制。(比如其他两个商用虚拟机都没有方法区的概念）</p></li><li><p><code>从服务器、桌面到移动端、嵌入式都有应用。</code></p></li><li><p><code>名称中的HotSpot指的就是它的热点代码探测技术。</code></p><ul><li><p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p></li><li><p>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p></li></ul></li></ol></blockquote><h3 id="JRockit-VM"><a href="#JRockit-VM" class="headerlink" title="JRockit VM"></a>JRockit VM</h3><blockquote><ol><li>BEA 的 JRockit专注于服务器端应用。</li><li>它可以不太关注程序启动速度，因此<code>JRockit</code>内部不包含解析器实现，<code>全部代码都靠即时编译器编译后执行。</code></li><li><code>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</code><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成木的减少（达50%）。</li></ul></li><li><code>优势:全面的Java运行时解决方案组合。</code></li><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要Missioncontrol服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li><li><code>2008年，BEA被oracle收购。</code></li><li><code>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</code></li></ol></blockquote><h3 id="J9-VM"><a href="#J9-VM" class="headerlink" title="J9 VM"></a>J9 VM</h3><blockquote><ol><li>全称:IBM Technology for Java Virtual Machine，<code>简称IT4J</code>，<code>内部代号:J9</code>。</li><li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM、</li><li><code>广泛用于IBM的各种Java产品。</code></li><li>目前，有影响力的三大商用服务器之一，<code>也号称是世界上最快的Java虚拟机。（在自己公司的产品）</code></li><li><code>2017年左右，IBM发布了开源J9 VM</code>，命名为openJ9，交给Eclipse基金会管理，也称为Ecilpse openJ9</li></ol></blockquote><h3 id="KVM-和-CDC-CLDC-Hotspot"><a href="#KVM-和-CDC-CLDC-Hotspot" class="headerlink" title="KVM 和 CDC/CLDC Hotspot"></a>KVM 和 CDC/CLDC Hotspot</h3><blockquote><ol><li><p><code>Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM</code></p></li><li><p>KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能手机被Android 和 IOS二分天下。KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li><p>智能控制器、传感器。</p></li><li><p>老人手机、经济欠发达地区的功能手机。</p></li></ul></li><li><p>所有的虚拟机的原则:一次编译，到处运行。</p></li></ol></blockquote><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><blockquote><ol><li><code>前面三大“高性能Java虚拟机”使用在通用硬件平台上。</code></li><li>这里Azul VM和 BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机。<ul><li><code>高性能Java虚拟机中的战斗机。</code></li></ul></li><li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul systems公司的专有硬件Vega系统上的Java虚拟机。</li><li><code>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的cc时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</code></li><li>2010年，Azul systems公司开始从硬件转向软件，发布了自己的<a href="https://blog.csdn.net/21aspnet/article/details/88667880" target="_blank" rel="noopener">Zing JVM</a>，可以在通用x86平台上提供接近于Vega系统的特性。</li></ol></blockquote><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><blockquote><ol><li>高性能 Java 虚拟机中的战斗机。</li><li>BEA公司开发的，直接运行在自家Hypervisor系统上</li><li>Liquid VM即是现在的<code>JRockit VE (Virtual Edition)</code>,Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li><li>随着JRockit虚拟机终止开发，Liquid VM项目也停止了。</li></ol></blockquote><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><blockquote><ol><li>Apache也曾经推出过与JDK 1.5和JDK 1.6兼容的Java运行平台Apache Harmony。</li><li><code>它是IBM和Intel联合开发的开源JVM，受到同样开源的openJDK的压制，sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与openJDK</code></li><li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li></ol></blockquote><h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><blockquote><ol><li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li><li>只能在window平台下运行。但确是当时windows下性能最好的Java VM。</li><li>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在Windows XP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</li></ol></blockquote><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><blockquote><ol><li><p><code>由AliJVM团队发布。</code>阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p>基于openJDK开发了自己的定制版木Alibaba JDK，简称AJDK。是整个阿里Java体系的基石。</p></li><li><p><code>基于openJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</code></p><ul><li><p>创新的GCIH (GC invisible heap）技术实现了off-heap ，<code>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</code></p></li><li><p><code>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</code></p></li><li><p>使用crc32指令实现JVM intrinsic降低JN工的调用开销</p></li><li><p>PMU hardware的Java profiling tool 和诊断协助功能</p></li><li><p>针对大数据场景的ZenGC</p></li></ul></li><li><p>taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu，损失了兼容性，但提高了性能</p><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JVM版木全部替换了。</li></ul></li></ol></blockquote><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><blockquote><ol><li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li><li><code>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</code>，它没有遵循Java虚拟机规范。</li><li>不能直接执行Java的class文件。</li><li><code>基于寄存器架构，不是jvm的栈架构。</code></li><li><code>执行的是编译以后的dex (Dalvik Executable）文件。</code>执行效率比较高。</li><li>它执行的dex(Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li><li><code>Android 5.o使用支持提前编译(Ahead of Time Compilation，AOT)的 ART VM替换Dalvik VM。</code></li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200910213405652.png" alt="image-20200910213405652"></p></blockquote><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><blockquote><ol><li>2018年4月，oracle Labs公开了Graal VM，号称 <code>&quot;Run Programs Faster Anywhere&quot;</code>，勃勃野心。与1995年java的 <code>”write once，run anywhere&quot;</code> 遥相呼应。</li><li>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括: Java、scala、Groovy、Kotlin、C、C++、Javascript、Ruby、Python、R等。</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li><code>如果说HotSpot有一天真的被取代，Graal VM希望最大</code>。但是Java的软件生态没有丝毫变化。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;黯相望。断鸿声里，立尽斜阳。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——柳永《玉蝴蝶》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/2.JVM架构及其生命周期</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/2.JVM%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/2.JVM%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-12-19T10:57:42.722Z</published>
    <updated>2020-12-19T11:56:22.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>汗血盐车无人顾，千里空收骏骨。</p><p align="right">——辛弃疾《贺新郎》</p><a id="more"></a><h2 id="JVM架构及其生命周期"><a href="#JVM架构及其生命周期" class="headerlink" title="JVM架构及其生命周期"></a>JVM架构及其生命周期</h2><h3 id="1-JVM的整体架构"><a href="#1-JVM的整体架构" class="headerlink" title="1. JVM的整体架构"></a>1. JVM的整体架构</h3><blockquote><ol><li><code>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</code></li><li>它采用<code>解释器与即时编译器并存</code>的架构。</li><li>在今天，Java程序的运行性能早己脱胎换骨，已经达到了可以和c/C++程序一较高下的地步。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/mmm.png" alt="mmm"></p><h3 id="2-Java代码执行流程"><a href="#2-Java代码执行流程" class="headerlink" title="2. Java代码执行流程"></a>2. Java代码执行流程</h3><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200909223153642.png" alt="image-20200909223153642"></p><h3 id="3-JVM的架构模型"><a href="#3-JVM的架构模型" class="headerlink" title="3. JVM的架构模型"></a>3. JVM的架构模型</h3><blockquote><p>Java编译器输入的指令流基本上是一种<code>基于栈的指令集架构</code>，另外一种指令集架构则是<code>基于寄存器的指令集架构</code>。<br>这两种架构之间的区别：</p><ol><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统;</li><li>避开了寄存器的分配难题–使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。<code>指令集更小,编译器容易实现。</code></li><li><code>不需要硬件支持，可移植性更好，更好实现跨平台</code></li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是x86的二进制指令集：<code>比如传统的PC以及Android的Davlik虚拟机。</code></li><li><code>指令集架构则完全依赖硬件，可移植性差;</code></li><li><code>性能优秀和执行更高效;</code></li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ol><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200909224139560.png" alt="image-20200909224139560"></p></blockquote><h4 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h4><blockquote><ol><li><code>由于跨平台性的设计，Java的指令都是根据栈来设计的。</code>不同平台CPU架构不同，所以不能设计为基于寄存器的。</li><li><code>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</code></li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢?</li></ol></blockquote><h3 id="4-JVM生命周期"><a href="#4-JVM生命周期" class="headerlink" title="4. JVM生命周期"></a>4. JVM生命周期</h3><h4 id="4-1-虚拟机的启动"><a href="#4-1-虚拟机的启动" class="headerlink" title="4.1 虚拟机的启动"></a>4.1 虚拟机的启动</h4><blockquote><p>Java虚拟机的启动是通过<code>引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的</code>，这个类是由虚拟机的具体实现指定的。</p></blockquote><h4 id="4-2-虚拟机的执行"><a href="#4-2-虚拟机的执行" class="headerlink" title="4.2 虚拟机的执行"></a>4.2 虚拟机的执行</h4><blockquote><ol><li>一个运行中的Java虚拟机有着一个清晰的任务–执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li><code>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</code></li></ol></blockquote><h4 id="4-3-虚拟机的退出"><a href="#4-3-虚拟机的退出" class="headerlink" title="4.3 虚拟机的退出"></a>4.3 虚拟机的退出</h4><blockquote><p>有以下几种情况：</p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java 安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI ( Java Native Interface)规范描述了用<code>JNI</code>  Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;汗血盐车无人顾，千里空收骏骨。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——辛弃疾《贺新郎》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/18.JVM之垃圾回收器</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/18.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/18.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2020-12-19T10:57:42.719Z</published>
    <updated>2020-12-19T11:56:22.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>往事悠悠君莫问，回头。槛外长江空自流。</p><p align="right">——王安石《南乡子》</p><a id="more"></a><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1. GC分类与性能指标"></a>1. GC分类与性能指标</h3><h4 id="1-1-垃圾回收器概述"><a href="#1-1-垃圾回收器概述" class="headerlink" title="1.1 垃圾回收器概述"></a>1.1 垃圾回收器概述</h4><blockquote><ol><li><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p></li><li><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p></li><li><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p></li><li><p>==怎么学习Java不同版本新特性？==</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum。</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架。</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化。</li></ul></li></ol></blockquote><h4 id="1-2-垃圾回收器分类"><a href="#1-2-垃圾回收器分类" class="headerlink" title="1.2 垃圾回收器分类"></a>1.2 垃圾回收器分类</h4><h6 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h6><blockquote><p><code>按线程数分（垃圾回收线程数）</code>，可以分为<code>串行垃圾回收器</code>和<code>并行垃圾回收器</code>。</p><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713083030867.png" alt="image-20200713083030867"></p><ol><li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。<code>所以，串行回收默认被应用在客户端的Client模式下的JVM中。</code></li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul></li><li><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，<code>采用独占式，使用了“stop-the-world”机制。</code></p></li></ol></blockquote><h6 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h6><blockquote><p>按照工作模式分，可以分为<code>独占式垃圾回收器</code>和<code>并发式垃圾回收器</code>。</p><ul><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713083443486.png" alt="image-20200713083443486"></p><h6 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h6><blockquote><p>按碎片处理方式分，可分为<code>压缩式垃圾回收器</code>和<code>非压缩式垃圾回收器</code>。</p><ol><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ol></blockquote><h6 id="按工作的内存区间分"><a href="#按工作的内存区间分" class="headerlink" title="按工作的内存区间分"></a>按工作的内存区间分</h6><blockquote><p>又可分为<code>年轻代垃圾回收器</code>和<code>老年代垃圾回收器。</code></p></blockquote><h4 id="1-3-评估GC的性能指标"><a href="#1-3-评估GC的性能指标" class="headerlink" title="1.3 评估GC的性能指标"></a>1.3 评估GC的性能指标</h4><blockquote><ol><li>==吞吐量☆==：<code>运行用户代码的时间占总运行时间的比例。</code><ul><li>总运行时间 = 程序的运行时间 + 内存回收的时间</li></ul></li><li><code>垃圾收集开销</code>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li>==暂停时间==：<code>执行垃圾收集时，程序的工作线程被暂停的时间。</code></li><li><code>收集频率</code>：相对于应用程序的执行，收集操作发生的频率。</li><li>==内存占用==：<code>Java堆区所占的内存大小。</code></li><li><code>快速</code>：一个对象从诞生到被回收所经历的时间。</li><li>==吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”==。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li><li>这三项里，暂停时间STW的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li><li>简单来说，主要抓住两点：<ul><li>吞吐量。</li><li>暂停时间。</li></ul></li></ol></blockquote><h6 id="性能指标—吞吐量"><a href="#性能指标—吞吐量" class="headerlink" title="性能指标—吞吐量"></a>性能指标—吞吐量</h6><blockquote><ol><li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，<code>即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间</code>）</p></li><li><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></li><li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p></li><li><p>吞吐量优先，意味着在单位时间内，<code>STW的时间最短：0.2+0.2=0.4s</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713084726176.png" alt="image-20200713084726176"></p><h6 id="性能指标—暂停时间"><a href="#性能指标—暂停时间" class="headerlink" title="性能指标—暂停时间"></a>性能指标—暂停时间</h6><blockquote><ol><li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p></li><li><p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p></li><li><p><code>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713085306400.png" alt="image-20200713085306400"></p><h6 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h6><blockquote><ol><li><p><code>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</code></p></li><li><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<code>交互式应用程序。</code></p></li><li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li><p>因为如果选择以吞吐量优先，<code>那么必然需要降低内存回收的执行频率</code>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p></li><li><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，<code>也只能频繁地执行内存回收</code>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p></li></ul></li><li><p>在设计（或使用）GC算法时，我们必须确定我们的目标：<code>一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</code></p></li><li><p>==现在标准：在最大吞吐量优先的情况下，降低停顿时间==</p></li></ol></blockquote><h3 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2. 不同的垃圾回收器概述"></a>2. 不同的垃圾回收器概述</h3><blockquote><ol><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li><li><code>那么，Java常见的垃圾收集器有哪些？</code></li><li><code>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别。</code></li></ol></blockquote><h4 id="2-1-垃圾回收器发展史"><a href="#2-1-垃圾回收器发展史" class="headerlink" title="2.1 垃圾回收器发展史"></a>2.1 垃圾回收器发展史</h4><blockquote><p>有了虚拟机，<code>就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</code></p><ul><li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布。</li><li><code>Parallel GC在JDK6之后成为HotSpot默认GC。</code></li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li><code>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</code></li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li><code>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</code></li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入<code>Shenandoah GC</code>：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用。</li></ul></blockquote><h4 id="2-2-7种经典的垃圾收集器"><a href="#2-2-7种经典的垃圾收集器" class="headerlink" title="2.2 7种经典的垃圾收集器"></a>2.2 7种经典的垃圾收集器</h4><blockquote><ul><li>串行回收器：<code>Serial、Serial old</code></li><li>并行回收器：<code>ParNew、Parallel Scavenge、Parallel old</code></li><li>并发回收器：<code>CMS、G1</code></li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713093551365.png" alt="image-20200713093551365"></p><h4 id="2-3-7款经典收集器与垃圾分代之间的关系"><a href="#2-3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="2.3 7款经典收集器与垃圾分代之间的关系"></a>2.3 7款经典收集器与垃圾分代之间的关系</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713093757644.png" alt="image-20200713093757644"></p><blockquote><ol><li><p>新生代收集器：Serial、ParNew、Paralle  Scavenge；</p></li><li><p>老年代收集器：Serial old、CMS、Parallel old；</p></li><li><p>整堆收集器：G1；</p></li></ol></blockquote><h4 id="2-4-垃圾收集器的组合关系☆"><a href="#2-4-垃圾收集器的组合关系☆" class="headerlink" title="2.4 垃圾收集器的组合关系☆"></a>2.4 垃圾收集器的组合关系☆</h4><blockquote><ol><li>两个收集器间有连线，表明它们可以搭配使用：<ul><li>Serial/Serial old</li><li>Serial/CMS</li><li>ParNew/Serial old</li><li>ParNew/CMS</li><li>Parallel Scavenge/Serial 0ld</li><li>Parallel Scavenge/Parallel 0ld</li><li>G1</li></ul></li><li><code>其中Serial old作为CMS出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</code></li><li>（红色虚线）由于维护和兼容性测试的成本，<code>在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</code></li><li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713094745366.png" alt="image-20200713094745366"></p><blockquote><ol><li>为什么要有很多收集器，一个不够吗？<code>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</code></li><li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<code>我们选择的只是对具体应用最合适的收集器。</code></li></ol></blockquote><h4 id="2-5-如何查看默认垃圾收集器"><a href="#2-5-如何查看默认垃圾收集器" class="headerlink" title="2.5 如何查看默认垃圾收集器"></a>2.5 如何查看默认垃圾收集器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看命令行相关参数（包含使用的垃圾收集器）</span></span><br><span class="line">-XX:+PrintcommandLineFlags</span><br><span class="line">    </span><br><span class="line"><span class="comment">// JDK8结果：-XX:+UseParallelGC </span></span><br><span class="line"><span class="comment">// JDK9结果：-XX:+UseG1GC</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用命令行指令：</span></span><br><span class="line">jinfo -flag  相关垃圾回收器参数  进程ID</span><br></pre></td></tr></table></figure><h3 id="3-Serial回收器—串行回收"><a href="#3-Serial回收器—串行回收" class="headerlink" title="3. Serial回收器—串行回收"></a>3. Serial回收器—串行回收</h3><blockquote><ol><li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></li><li><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p></li><li><p><code>Serial收集器采用复制算法、串行回收和&quot;stop-the-World&quot;机制的方式执行内存回收。</code></p></li><li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。<code>Serial old收集器同样也采用了串行回收和&quot;stop the World&quot;机制，只不过内存回收算法使用的是标记-压缩算法。</code></p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器。</li><li>Serial old在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用。</li><li>作为老年代CMS收集器的后备垃圾收集方案。</li></ul></li></ul></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713100703799.png" alt="image-20200713100703799"></p><h4 id="3-1-Serial回收器小结"><a href="#3-1-Serial回收器小结" class="headerlink" title="3.1 Serial回收器小结"></a>3.1 Serial回收器小结</h4><blockquote><ol><li><p>这个收集器是一个单线程的收集器，<code>但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</code></p></li><li><p>优势：</p><ul><li>简单而高效（与其他收集器的单线程比），对于限定单个XPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li></ul></li><li><p><code>运行在client模式下的虚拟机是个不错的选择。</code>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p></li><li><p>在HotSpot虚拟机中，==使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。==等价于新生代用Serial GC，且老年代用Serial old GC。</p></li><li><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p></li><li><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p></li></ol></blockquote><h3 id="4-ParNew回收器—并行回收"><a href="#4-ParNew回收器—并行回收" class="headerlink" title="4. ParNew回收器—并行回收"></a>4. ParNew回收器—并行回收</h3><blockquote><ol><li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代。</li></ul></li><li><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p></li><li><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713102030127.png" alt="image-20200713102030127"></p><blockquote><ol><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li><li>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？<ul><li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul></li><li>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</li><li>在程序中，开发人员可以==通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。==</li><li><code>-XX:ParallelGCThreads</code>限制线程数量，==默认开启和CPU数据相同的线程数。==</li></ol></blockquote><h3 id="5-Parallel回收器—吞吐量优先"><a href="#5-Parallel回收器—吞吐量优先" class="headerlink" title="5. Parallel回收器—吞吐量优先"></a>5. Parallel回收器—吞吐量优先</h3><blockquote><ol><li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，<code>Parallel Scavenge收集器</code>同样也采用了复制算法、并行回收和”Stop the World”机制。</p></li><li><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<code>可控制的吞吐量（Throughput）</code>，它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</li></ul></li><li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<code>主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</code></p></li><li><p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel old收集器，用来代替老年代的Serial old收集器。</p></li><li><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713110359441.png" alt="image-20200713110359441"></p><blockquote><ol><li>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。</li><li>在Java6/7/8中，默认是此垃圾收集器。</li></ol></blockquote><h4 id="5-1-Parallel-参数配置"><a href="#5-1-Parallel-参数配置" class="headerlink" title="5.1 Parallel 参数配置"></a>5.1 Parallel 参数配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</span></span><br><span class="line">-XX：+UseParallelGC </span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定老年代都是使用并行回收收集器。</span></span><br><span class="line">-XX：+UseParalleloldcc</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>分别适用于新生代和老年代。默认jdk8是开启的。</code></li><li><code>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span></span><br><span class="line">-XX:ParallelGCThreads</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于 CPU 数量。</p></li><li><p><code>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]</code></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</span></span><br><span class="line">-XX:MaxGCPauseMillis</span><br></pre></td></tr></table></figure><blockquote><ol><li>为了尽可能地<code>把停顿时间控制在MaxGCPauseMills以内</code>，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li><code>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</code></li><li><code>该参数使用需谨慎。</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</span></span><br><span class="line">-XX:GCTimeRatio</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%。</p></li><li><p><code>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性</code>。暂停时间越长，Radio参数就容易超过设定的比例。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Parallel scavenge收集器具有自适应调节策略</span></span><br><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</p></li></ol></blockquote><h3 id="6-CMS回收器—低延迟"><a href="#6-CMS回收器—低延迟" class="headerlink" title="6. CMS回收器—低延迟"></a>6. CMS回收器—低延迟</h3><blockquote><ol><li><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：<code>CMS（Concurrent-Mark-Sweep）收集器，</code>这款收集器是HotSpot虚拟机中<code>第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</code></p></li><li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul></li><li><p><code>CMS的垃圾收集算法采用标记-清除算法，并且也会&quot;stop-the-world&quot;。</code></p></li><li><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p></li><li><p><code>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</code></p></li></ol></blockquote><h4 id="6-1-CMS工作原理"><a href="#6-1-CMS工作原理" class="headerlink" title="6.1 CMS工作原理"></a>6.1 CMS工作原理</h4><blockquote><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即<code>初始标记阶段</code>、<code>并发标记阶段</code>、<code>重新标记阶段</code>和<code>并发清除阶段</code>。涉及STW的阶段主要是：<code>初始标记 和 重新标记。</code></p><ol><li><code>初始标记</code>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<code>标记出GCRoots能直接关联到的对象</code>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。<code>由于直接关联对象比较小，所以这里的速度非常快。</code></li><li><code>并发标记</code>（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><code>重新标记</code>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><code>并发清除</code>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713205154007.png" alt="image-20200713205154007"></p><blockquote><ol><li>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</li><li><code>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</code></li><li>另外，由于在垃圾收集阶段用户线程没有中断，所以<code>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。</code>因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<code>当堆内存使用率达到某一阈值时，便开始进行回收</code>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<code>“Concurrent Mode Failure”</code>失败，<code>这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</code></li><li>CMS收集器的垃圾收集算法采用的是<code>标记清除算法</code>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将<code>会产生一些内存碎片</code>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713212230352.png" alt="image-20200713212230352"></p><h4 id="6-2-CMS为什么不使用标记整理算法？"><a href="#6-2-CMS为什么不使用标记整理算法？" class="headerlink" title="6.2 CMS为什么不使用标记整理算法？"></a>6.2 CMS为什么不使用标记整理算法？</h4><blockquote><ol><li>答案其实很简答，因为当并发清除的时候，<code>用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？</code></li><li>要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”<br>这种场景下使用。</li></ol></blockquote><h4 id="6-3-CMS优缺点"><a href="#6-3-CMS优缺点" class="headerlink" title="6.3 CMS优缺点"></a>6.3 CMS优缺点</h4><blockquote><p>优点：</p><ol><li>并发收集</li><li>低延迟</li></ol><p>缺点：</p><ol><li><p><code>会产生内存碎片，</code>导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p></li><li><p><code>CMS收集器对CPU资源非常敏感。</code>在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></li><li><p><code>CMS收集器无法处理浮动垃圾</code>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<code>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</code>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p></li></ol></blockquote><h4 id="6-4-CMS参数的设置"><a href="#6-4-CMS参数的设置" class="headerlink" title="6.4 CMS参数的设置"></a>6.4 CMS参数的设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动指定使用CMS收集器执行内存回收任务。</span></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><blockquote><p>开启该参数后会<code>自动将-XX:+UseParNewGC打开。即：ParNew（Young区用）+CMS（old区用）+Serial old的组合。</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</span></span><br><span class="line">-XX:CMSInitiatingOccupanyFraction</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%。</p></li><li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<code>因此通过该选项便可以有效降低Full GC的执行次数。</code></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span></span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置在执行多少次Full GC后对内存空间进行压缩整理。</span></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction </span><br><span class="line"><span class="comment">// 设置CMS的线程数量。</span></span><br><span class="line">-XX:ParallelCMSThreads</span><br></pre></td></tr></table></figure><blockquote><p><code>CMS默认启动的线程数是（ParallelGCThreads+3）/4</code>，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p></blockquote><h4 id="6-5-CMS小结"><a href="#6-5-CMS小结" class="headerlink" title="6.5 CMS小结"></a>6.5 CMS小结</h4><blockquote><p>HotSpot有这么多的垃圾回收器，那么如果有人问，<code>Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</code>请记住以下口令：</p><ol><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ol><p><code>JDK后续版本中CMS的变化：</code></p><ol><li><code>JDK9新特性</code>：CMS被标记为Deprecate了（JEP291）<ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用<code>参数-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性：删除CMs垃圾回收器（JEP363）<ul><li>移除了CMS垃圾收集器，如果<code>在JDK14中使用-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。<code>JVM会自动回退以默认GC方式启动JVM</code>。</li></ul></li></ol></blockquote><h3 id="7-G1回收器—区域化分代式"><a href="#7-G1回收器—区域化分代式" class="headerlink" title="7. G1回收器—区域化分代式"></a>7. G1回收器—区域化分代式</h3><h4 id="7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h4><blockquote><ol><li><p>原因就在于应用程序所应对的<code>业务越来越庞大、复杂，用户越来越多</code>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p></li><li><p>与此同时，为了适应现在<code>不断扩大的内存和不断增加的处理器数量</code>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p></li><li><p><code>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</code>。</p></li></ol></blockquote><h4 id="7-2-为什么名字叫-Garbage-First-G1-呢？"><a href="#7-2-为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="7.2 为什么名字叫 Garbage First(G1)呢？"></a>7.2 为什么名字叫 Garbage First(G1)呢？</h4><blockquote><ol><li><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p></li><li><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<code>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</code></p></li><li><p><code>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）</code>。</p></li><li><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<code>主要针对配备多核CPU及大容量内存的机器</code>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p></li><li><p><code>在JDK1.7版本正式启用，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel old组合。被oracle官方称为“全功能的垃圾收集器”。</code></p></li><li><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。G1在jdk8中还不是默认的垃圾回收器，需要使用<code>-xx:+UseG1GC</code>来启用。</p></li></ol></blockquote><h4 id="7-3-G1垃圾收集器的优点"><a href="#7-3-G1垃圾收集器的优点" class="headerlink" title="7.3 G1垃圾收集器的优点"></a>7.3 G1垃圾收集器的优点</h4><blockquote><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><code>并行与并发</code></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul><p><code>分代收集</code></p><ul><li>从分代上看，<code>G1依然属于分代型垃圾回收器</code>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<code>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</code></li><li>和之前的各类回收器不同，它同时<code>兼顾年轻代和老年代</code>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713215105293.png" alt="image-20200713215105293"></p><blockquote><p><code>而是这样的一个区域</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713215133839.png" alt="image-20200713215133839"></p><h6 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h6><blockquote><ol><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理。</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<code>Region之间是复制算法</code>，但整体上实际可看作是<code>标记-压缩（Mark-Compact）算法</code>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ol></blockquote><h6 id="可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时soft real-time）"></a>可预测的停顿时间模型（即：软实时soft real-time）</h6><blockquote><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<code>每次根据允许的收集时间，优先回收价值最大的Region</code>。保证了G1收集器在有限的时间内可以<code>获取尽可能高的收集效率。</code></li><li><code>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</code></li></ul></blockquote><h4 id="7-4-G1垃圾收集器的缺点"><a href="#7-4-G1垃圾收集器的缺点" class="headerlink" title="7.4 G1垃圾收集器的缺点"></a>7.4 G1垃圾收集器的缺点</h4><blockquote><ol><li><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p></li><li><p>从经验上来说，<code>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</code></p></li></ol></blockquote><h4 id="7-5-G1参数设置"><a href="#7-5-G1参数设置" class="headerlink" title="7.5 G1参数设置"></a>7.5 G1参数设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动指定使用G1垃圾收集器执行内存回收任务</span></span><br><span class="line">-XX:+UseG1GC</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span></span><br><span class="line">-XX:G1HeapRegionSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span></span><br><span class="line">-XX:MaxGCPauseMillis</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置STW工作线程数的值。最多设置为8</span></span><br><span class="line">-XX:+ParallelGcThread </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。  </span></span><br><span class="line">-XX:ConcGCThreads </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span></span><br><span class="line">-XX:InitiatingHeapOccupancyPercent</span><br></pre></td></tr></table></figure><h4 id="7-6-G1收集器的常见操作步骤"><a href="#7-6-G1收集器的常见操作步骤" class="headerlink" title="7.6 G1收集器的常见操作步骤"></a>7.6 G1收集器的常见操作步骤</h4><blockquote><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p><code>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</code></p></blockquote><h4 id="7-7-G1收集器的适用场景"><a href="#7-7-G1收集器的适用场景" class="headerlink" title="7.7 G1收集器的适用场景"></a>7.7 G1收集器的适用场景</h4><blockquote><ol><li><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p></li><li><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><ul><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。用来替换掉JDK1.5中的CMS收集器；</li></ul></li><li><p>在下面的情况时，使用G1可能比CMS好：</p><ul><li><p>超过50%的Java堆被活动数据占用；</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长（长于0.5至1秒）。</p></li></ul></li><li><p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p></li></ol></blockquote><h4 id="7-8-分区Region—化整为零"><a href="#7-8-分区Region—化整为零" class="headerlink" title="7.8 分区Region—化整为零"></a>7.8 分区Region—化整为零</h4><blockquote><ol><li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<code>所有的Region大小相同，且在JVM生命周期内不会被改变。</code></p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713223244886.png" alt="image-20200713223244886"></p><blockquote><ol><li><p><code>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于old内存区域。图中空白的表示未使用的内存空间。</code></p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p></li><li><p><code>设置H的原因：</code></p><ul><li>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li></ul></li><li><p><code>每个Region都是通过指针碰撞来分配空间:</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713223509993.png" alt="image-20200713223509993"></p><h4 id="7-9-G1垃圾回收器的回收过程"><a href="#7-9-G1垃圾回收器的回收过程" class="headerlink" title="7.9 G1垃圾回收器的回收过程"></a>7.9 G1垃圾回收器的回收过程</h4><blockquote><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ol><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ol><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713224113996.png" alt="image-20200713224113996"></p><blockquote><ol><li><p><code>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序</code>，进行垃圾回收。</p></li><li><p>应用程序分配内存，<code>当年轻代的Eden区用尽时开始年轻代回收过程</code>；G1的年轻代收集阶段是一个<code>并行的独占式收集器</code>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<code>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</code></p></li><li><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p></li><li><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<code>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</code>。同时，这个老年代Region是和年轻代一起被回收的。</p></li><li><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p></li></ol></blockquote><h6 id="Remembered-Set（记忆集）解决的具体问题"><a href="#Remembered-Set（记忆集）解决的具体问题" class="headerlink" title="Remembered Set（记忆集）解决的具体问题"></a>Remembered Set（记忆集）解决的具体问题</h6><blockquote><ol><li><p>一个对象被不同区域引用的问题</p></li><li><p><code>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</code></p></li><li><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率；</p></li><li><p><code>解决方法：</code></p><ul><li>无论G1还是其他分代收集器，<code>JVM都是使用Remembered Set来避免全局扫描;</code></li><li><code>每个Region都有一个对应的Remembered Set；</code></li><li>每次Reference类型数据写操作时，都会产生一个<code>Write Barrier</code>暂时中断操作；</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li><li>如果不同，通过<code>CardTable</code>把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li><li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li></ul></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713224716715.png" alt="image-20200713224716715"></p><h6 id="G1回收过程—年轻代GC"><a href="#G1回收过程—年轻代GC" class="headerlink" title="G1回收过程—年轻代GC"></a>G1回收过程—年轻代GC</h6><blockquote><ol><li><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p></li><li><p>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713225100632.png" alt="image-20200713225100632"></p><blockquote><p>然后开始如下回收过程：</p><p><code>第一阶段，扫描根</code></p><ul><li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li></ul><p><code>第二阶段，更新RSet</code></p><ul><li>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，<code>RSet可以准确的反映老年代对所在的内存分段中对象的引用。</code></li></ul><p><code>第三阶段，处理RSet</code></p><ul><li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li></ul><p><code>第四阶段，复制对象。</code></p><ul><li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul><p><code>第五阶段，处理引用</code></p><ul><li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul></blockquote><h6 id="G1回收过程—并发标记过程"><a href="#G1回收过程—并发标记过程" class="headerlink" title="G1回收过程—并发标记过程"></a>G1回收过程—并发标记过程</h6><blockquote><p><code>初始标记阶段：</code></p><ul><li>标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li></ul><p><code>根区域扫描（Root Region Scanning）：</code></p><ul><li>G1 GC扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</li></ul><p><code>并发标记（Concurrent Marking）：</code></p><ul><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，<code>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</code>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li></ul><p><code>再次标记（Remark）：</code></p><ul><li>由于应用程序持续进行，需要修正上一次的标记结果。是STW的。<code>G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</code></li></ul><p><code>独占清理（cleanup，STW）：</code></p><ul><li>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li></ul><p><code>并发清理阶段：</code></p><ul><li>识别并清理完全空闲的区域。</li></ul></blockquote><h6 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h6><blockquote><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<code>是一部分老年代，而不是全部老年代</code>。可以选择哪些old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。<code>也要注意的是Mixed GC并不是Full GC。</code></p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200713225810871.png" alt="image-20200713225810871"></p><blockquote><ol><li><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget设置</code>）被回收。</p></li><li><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p></li><li><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p></li><li><p><code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p></li><li><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p></li></ol></blockquote><h6 id="G1回收可选的过程-Full-GC"><a href="#G1回收可选的过程-Full-GC" class="headerlink" title="G1回收可选的过程 - Full GC"></a>G1回收可选的过程 - Full GC</h6><blockquote><ol><li><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，<code>G1会停止应用程序的执行（Stop-The-world）</code>，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p></li><li><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p></li><li><p>导致G1 Full GC的原因可能有两个：</p><ul><li><p>Evacuation的时候没有足够的to-space来存放晋升的对象；</p></li><li><p>并发处理过程完成之前空间耗尽。</p></li></ul></li><li><p>从Oracle官方透露出来的信息可获知，<code>回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中</code>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p></li></ol></blockquote><h4 id="7-10-G1回收的优化建议"><a href="#7-10-G1回收的优化建议" class="headerlink" title="7.10 G1回收的优化建议"></a>7.10 G1回收的优化建议</h4><blockquote><p><code>年轻代大小：</code></p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小。</li><li>固定年轻代的大小会覆盖。</li></ul><p><code>暂停时间目标暂停时间目标不要太过严苛：</code></p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></blockquote><h3 id="8-垃圾回收器总结☆"><a href="#8-垃圾回收器总结☆" class="headerlink" title="8. 垃圾回收器总结☆"></a>8. 垃圾回收器总结☆</h3><blockquote><ol><li><code>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</code></li><li>==GC发展阶段：Serial=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC==</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714075738203.png" alt="image-20200714075738203"></p><blockquote><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图:</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714080151020.png" alt="image-20200714080151020"></p><h4 id="8-1-怎么选择垃圾回收器"><a href="#8-1-怎么选择垃圾回收器" class="headerlink" title="8.1 怎么选择垃圾回收器"></a>8.1 怎么选择垃圾回收器</h4><blockquote><p>J<code>ava垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</code></p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li><code>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</code></li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集。</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。</li></ul></blockquote><h4 id="8-2-垃圾收集器面试"><a href="#8-2-垃圾收集器面试" class="headerlink" title="8.2 垃圾收集器面试"></a>8.2 垃圾收集器面试</h4><blockquote><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：</p><ol><li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p></li><li><p>垃圾收集器工作的基本流程。</p></li></ol><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p></blockquote><h3 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9. GC日志分析"></a>9. GC日志分析</h3><blockquote><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">内存分配与垃圾回收的参数列表</span><br><span class="line"><span class="comment">// 输出GC日志。类似：-verbose:gc</span></span><br><span class="line">-XX:+PrintGC</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出Gc的详细日志</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出Gc的时间戳（以基准时间的形式）</span></span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）    </span></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在进行GC的前后打印出堆的信息    </span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment">// 日志文件的输出路径</span></span><br><span class="line">-Xloggc:../logs/gc<span class="number">.1</span>og</span><br></pre></td></tr></table></figure><h4 id="9-1-verbose-gc"><a href="#9-1-verbose-gc" class="headerlink" title="9.1 verbose:gc"></a>9.1 verbose:gc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开GC日志</span><br><span class="line">-verbose:gc</span><br></pre></td></tr></table></figure><blockquote><p>这个只会显示总的GC堆的变化，如下：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714081610474.png" alt="image-20200714081610474"></p><blockquote><p>参数解析：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714081622526.png" alt="image-20200714081622526"></p><h4 id="9-2-PrintGCDetails"><a href="#9-2-PrintGCDetails" class="headerlink" title="9.2 PrintGCDetails"></a>9.2 PrintGCDetails</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开GC日志</span><br><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><blockquote><p>输入信息如下</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714081909309.png" alt="image-20200714081909309"></p><blockquote><p>参数解析</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714081925767.png" alt="image-20200714081925767"></p><blockquote><p>如果想把GC日志存到文件的话，是下面这个参数：<code>-Xloggc: /path/to/ gc.log</code></p></blockquote><h4 id="9-3-日志补充说明："><a href="#9-3-日志补充说明：" class="headerlink" title="9.3 日志补充说明："></a>9.3 日志补充说明：</h4><blockquote><ul><li><code>&quot;[GC&quot;</code>和<code>&quot;[Full GC&quot;</code>说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li><li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是<code>&quot;[DefNew&quot;</code></li><li>使用ParNew收集器在新生代的名字会变成<code>&quot;[ParNew&quot;</code>，意思是<code>&quot;Parallel New Generation&quot;</code></li><li>使用Parallel Scavenge收集器在新生代的名字是<code>”[PSYoungGen&quot;</code></li><li>老年代的收集和新生代道理一样，名字也是收集器决定的。</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li><li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li><code>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）</code><ul><li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间。</li></ul></blockquote><h4 id="9-4-Minor-GC-日志"><a href="#9-4-Minor-GC-日志" class="headerlink" title="9.4 Minor GC 日志"></a>9.4 Minor GC 日志</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714082555688.png" alt="image-20200714082555688"></p><h4 id="9-5-Full-GC日志"><a href="#9-5-Full-GC日志" class="headerlink" title="9.5 Full GC日志"></a>9.5 Full GC日志</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714082714690.png" alt="image-20200714082714690"></p><h4 id="9-6-GC回收举例"><a href="#9-6-GC回收举例" class="headerlink" title="9.6 GC回收举例"></a>9.6 GC回收举例</h4><blockquote><p>我们编写一个程序，用来说明GC收集的过程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在jdk7 和 jdk8中分别执行</span></span><br><span class="line"><span class="comment"> *-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCLogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们设置JVM启动参数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><blockquote><p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714083332238.png" alt="image-20200714083332238"></p><blockquote><p>然后我们将4M对象存入到Eden区中</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714083526790.png" alt="image-20200714083526790"></p><h4 id="9-7-GC日志分析工具"><a href="#9-7-GC日志分析工具" class="headerlink" title="9.7 GC日志分析工具"></a>9.7 GC日志分析工具</h4><blockquote><ol><li>可以用一些工具去分析这些GC日志</li><li>常用的日志分析工具有：<code>GCViewer</code>、<code>GCEasy</code>、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</li></ol></blockquote><h6 id="GCViewer"><a href="#GCViewer" class="headerlink" title="GCViewer"></a>GCViewer</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714084921184.png" alt="image-20200714084921184"></p><h6 id="GC-easy"><a href="#GC-easy" class="headerlink" title="GC easy"></a>GC easy</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714084726824-1604045135029.png" alt="image-20200714084726824"></p><h3 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10. 垃圾回收器的新发展"></a>10. 垃圾回收器的新发展</h3><blockquote><ol><li><p>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，<code>例如，JDK10以后，Full GC已经是并行运行</code>，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p></li><li><p>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<code>在Serverless等新的应用场景下，Serial GC找到了新的舞台。</code></p></li><li><p>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，<code>但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</code></p></li><li><p><a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">http://openjdk.java.net/jeps/318</a></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201029225720718.png" alt="image-20201029225720718"></p><h4 id="10-1-Open-JDK12的Shenandoash-GC"><a href="#10-1-Open-JDK12的Shenandoash-GC" class="headerlink" title="10.1 Open JDK12的Shenandoash GC"></a>10.1 Open JDK12的Shenandoash GC</h4><blockquote><ol><li>现在G1回收器已成为默认回收器好几年了。</li><li>我们还看到了引入了两个新的收集器:==ZGC (JDK11出现）和shenandoah(open JDK12)。==<ul><li>主打特点:低停顿时间。</li></ul></li><li>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</li><li>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的<code>受到官方的排挤</code>。比如号称OpenJDK和OracleJDk没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</li><li>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<code>旨在针对JVM上的内存回收实现低停顿的需求</code>。在2014年贡献给OpenJDK。</li><li>Red Hat研发Shenandoah团队对外宣称<code>，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</code>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714090608807.png" alt="image-20200714090608807"></p><blockquote><ol start="7"><li>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：<ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul></li><li>总结<ul><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项：低延迟时间。</li></ul></li></ol></blockquote><h4 id="10-2-令人震惊—革命性的ZGC"><a href="#10-2-令人震惊—革命性的ZGC" class="headerlink" title="10.2 令人震惊—革命性的ZGC"></a>10.2 令人震惊—革命性的ZGC</h4><blockquote><ol><li><p>ZGC与Shenandoah目标高度相似，<code>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</code></p></li><li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<code>可并发的标记-压缩算法</code>的，<code>以低延迟为首要目标的一款垃圾收集器。</code></p></li><li><p>ZGC的工作过程可以分为4个阶段：<code>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</code> 等。</p></li><li><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714091201073.png" alt="image-20200714091201073"></p><blockquote><p>停顿时间对比</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714091401511.png" alt="image-20200714091401511"></p><blockquote><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、99%停顿、99.9%停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714093243028.png" alt="image-20200714093243028"></p><blockquote><ol><li>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用<code>“令人震惊、革命性”</code>来形容，不为过。<br>==未来将在服务端、大内存、低延迟应用的首选垃圾收集器。==</li><li>JDK14之前，ZGC仅Linux才支持。</li><li>尽管许多使用ZGc的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</li><li>现在mac或Windows上也能使用ZGC了，示例如下：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure><h4 id="10-3-AliGC"><a href="#10-3-AliGC" class="headerlink" title="10.3 AliGC"></a>10.3 AliGC</h4><blockquote><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200714093604012.png" alt="image-20200714093604012"></p><blockquote><p><a href="https://www.infoq.com/articles/azul_gc_in_detail" target="_blank" rel="noopener">当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing。</a></p></blockquote><h4 id="10-4-最后寄语"><a href="#10-4-最后寄语" class="headerlink" title="10.4 最后寄语"></a>10.4 最后寄语</h4><blockquote><p>无论怎样做一个勤奋的人！</p></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;往事悠悠君莫问，回头。槛外长江空自流。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——王安石《南乡子》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE-JVM/17.JVM之垃圾回收相关概念</title>
    <link href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/17.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.itbuild.cn/2020/12/19/JavaSE-JVM/17.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2020-12-19T10:57:42.718Z</published>
    <updated>2020-12-19T11:56:22.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>千里水天一色，看孤鸿明灭。</p><p align="right">——朱郭儒《好事近》</p><a id="more"></a><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1. System.gc() 的理解"></a>1. System.gc() 的理解</h3><blockquote><ol><li><p>在默认情况下，<code>通过system.gc()者Runtime.getRuntime().gc() 的调用，会显式触发Full GC</code>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p></li><li><pre><code class="java">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>{        Runtime.getRuntime().gc();    }&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol></blockquote><blockquote><p>结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">1.8</span></span><br><span class="line"><span class="number">2.13</span></span><br><span class="line"><span class="number">3.18</span></span><br><span class="line"><span class="number">4.23</span></span><br><span class="line"><span class="number">5.27</span></span><br><span class="line"><span class="number">6.33</span></span><br><span class="line"><span class="number">7.39</span></span><br><span class="line"><span class="number">8.49</span></span><br><span class="line"><span class="number">9.55</span></span><br></pre></td></tr></table></figure><h3 id="4-垃圾回收的并行与并发"><a href="#4-垃圾回收的并行与并发" class="headerlink" title="4. 垃圾回收的并行与并发"></a>4. 垃圾回收的并行与并发</h3><h4 id="4-1-并发"><a href="#4-1-并发" class="headerlink" title="4.1 并发"></a>4.1 并发</h4><blockquote><ol><li><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p></li><li><p><code>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</code></p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712202522051.png" alt="image-20200712202522051"></p><h4 id="4-2-并行"><a href="#4-2-并行" class="headerlink" title="4.2 并行"></a>4.2 并行</h4><blockquote><ol><li><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。</p></li><li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p></li><li><p>适合科学计算，后台处理等弱交互场景。</p></li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712202822129.png" alt="image-20200712202822129"></p><h4 id="4-3-并发和并行对比"><a href="#4-3-并发和并行对比" class="headerlink" title="4.3 并发和并行对比"></a>4.3 并发和并行对比</h4><blockquote><ol><li><code>并发</code>，指的是多个事情，在同一时间段内同时发生了。并发的多个任务之间是互相抢占资源的。</li><li><code>并行</code>，指的是多个事情，在同一时间点上同时发生了。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ol></blockquote><h4 id="4-4-垃圾回收的并行与并发"><a href="#4-4-垃圾回收的并行与并发" class="headerlink" title="4.4 垃圾回收的并行与并发"></a>4.4 垃圾回收的并行与并发</h4><blockquote><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li><code>如ParNew、Parallel Scavenge、Parallel old；</code></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712203607845.png" alt="image-20200712203607845"></p><blockquote><ul><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li><li><code>如：CMS、G1；</code></li></ul></li></ul></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712203815517.png" alt="image-20200712203815517"></p><h3 id="5-安全点与安全区域"><a href="#5-安全点与安全区域" class="headerlink" title="5. 安全点与安全区域"></a>5. 安全点与安全区域</h3><h4 id="5-1-安全点"><a href="#5-1-安全点" class="headerlink" title="5.1 安全点"></a>5.1 安全点</h4><blockquote><ol><li>==程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。==</li><li>Safe Point的选择很重要，<code>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</code>。大部分指令的执行时间都非常短暂，<code>通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</code></li><li>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？<ul><li><code>抢先式中断：</code>（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>==主动式中断：==设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul></li></ol></blockquote><h4 id="5-2-安全区域"><a href="#5-2-安全区域" class="headerlink" title="5.2 安全区域"></a>5.2 安全区域</h4><blockquote><ol><li><p>Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，<code>程序“不执行”的时候呢？例如线程处于sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</code></p></li><li><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safe Point。</p></li><li><p>执行流程：</p><ol><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol></li></ol></blockquote><h3 id="6-再谈引用☆"><a href="#6-再谈引用☆" class="headerlink" title="6. 再谈引用☆"></a>6. 再谈引用☆</h3><blockquote><ol><li><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p></li><li><p>既偏门又非常高频的面试题：</p><ol><li>强引用、软引用、弱引用、虚引用有什么区别？</li><li>具体使用场景是什么？</li></ol></li><li><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ol><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ol></li><li><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p></li><li><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201025211529361.png" alt="image-20201025211529361"></p></li><li><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为Public，可以在应用程序中直接使用</p><ul><li><code>强引用（StrongReference）：</code>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li><li><code>软引用（SoftReference）：</code>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li><code>弱引用（WeakReference）：</code>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><code>虚引用（PhantomReference）：</code>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li><li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201025222516440.png" alt="image-20201025222516440"></li></ul></li></ol></blockquote><h4 id="5-1-强引用"><a href="#5-1-强引用" class="headerlink" title="5.1 强引用"></a>5.1 强引用</h4><blockquote><ol><li><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p></li><li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p></li><li><p><code>强引用的对象是可触及的</code>，垃圾收集器就永远不会回收掉被引用的对象。</p></li><li><p>对于一个普通的对象，如果没有其他的引用关系，<code>只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略</code>。</p></li><li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<code>强引用是造成Java内存泄漏的主要原因之一。</code></p></li></ol></blockquote><h6 id="举例—强引用-不回收"><a href="#举例—强引用-不回收" class="headerlink" title="举例—强引用-不回收"></a>举例—强引用-不回收</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">"Hello,尚硅谷"</span>);</span><br><span class="line">        StringBuffer str1 = str;</span><br><span class="line"></span><br><span class="line">        str = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用对应内存结构：</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712211501377.png" alt="image-20200712211501377"></p><blockquote><ol start="2"><li>如果此时，在运行一个<code>赋值语句StringBuffer str1 = str;</code>对应的内存结构为:</li></ol></blockquote><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712211732976.png" alt="image-20200712211732976"></p><blockquote><p>那么我们将 <code>str = null;</code> 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域。</p><p>所以结果为：Hello,尚硅谷</p></blockquote><h6 id="总结—强引用"><a href="#总结—强引用" class="headerlink" title="总结—强引用"></a>总结—强引用</h6><blockquote><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul></blockquote><h4 id="5-2-软引用"><a href="#5-2-软引用" class="headerlink" title="5.2 软引用"></a>5.2 软引用</h4><blockquote><ol><li><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p></li><li><p>注意，这里的第一次回收是不可达的对象</p></li><li><p><code>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</code></p></li><li><p><code>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</code></p></li><li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p></li><li><p>==一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象==</p></li><li><p>在JDK1.2版之后提供了SoftReference类来实现软引用：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用的测试：内存不足即回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"] "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, "songhk"));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"songhk"</span>);</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="keyword">null</span>;<span class="comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line"><span class="comment">//        //垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">635</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-弱引用—发现即回收"><a href="#5-3-弱引用—发现即回收" class="headerlink" title="5.3 弱引用—发现即回收"></a>5.3 弱引用—发现即回收</h4><blockquote><ol><li><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p></li><li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p></li><li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p></li><li><p><code>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</code></p></li><li><p><code>在JDK1.2版之后提供了WeakReference类来实现弱引用。</code></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"] "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"songhk"</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p></li><li><p><code>面试题：你开发中使用过WeakHashMap吗？</code></p><ul><li><code>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM。</code></li></ul></li></ol></blockquote><h4 id="5-4-虚引用"><a href="#5-4-虚引用" class="headerlink" title="5.4 虚引用"></a>5.4 虚引用</h4><blockquote><ol><li><p>也称为<code>“幽灵引用”或者“幻影引用”</code>，是所有引用类型中最弱的一个。</p></li><li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p></li><li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null。</p></li><li><p><code>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</code></p></li><li><p><code>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</code></p></li><li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p></li><li><p>虚引用无法获取到我们的数据</p></li><li><p><code>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</code></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h6 id="举例—虚引用"><a href="#举例—虚引用" class="headerlink" title="举例—虚引用"></a>举例—虚引用</h6><blockquote><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"追踪垃圾回收过程：PhantomReferenceTest实例被GC了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类的finalize()方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.out.println(<span class="string">"第 1 次 gc"</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第 2 次 gc"</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后运行结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">第 <span class="number">1</span> 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，<code>同时将会触发第二个操作就是将回收的值存入到引用队列中。</code></p></blockquote><h4 id="5-5-终结器引用"><a href="#5-5-终结器引用" class="headerlink" title="5.5 终结器引用"></a>5.5 终结器引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Final references, used to implement finalization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p><code>它用于实现对象的finalize() 方法，也可以称为终结器引用。</code></p></li><li><p>无需手动编码，其内部配合引用队列使用。</p></li><li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p></li></ol></blockquote><h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;千里水天一色，看孤鸿明灭。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;——朱郭儒《好事近》&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE-JVM" scheme="http://www.itbuild.cn/categories/JavaSE-JVM/"/>
    
    
  </entry>
  
</feed>
