<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaSE-JVM/16.JVM之垃圾回收相关算法"><meta name="keywords" content=""><meta name="author" content="DuanChaojie,undefined"><meta name="copyright" content="DuanChaojie"><title>JavaSE-JVM/16.JVM之垃圾回收相关算法【it❤ld】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/images/itbui.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="it❤ld" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收相关算法"><span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-标记阶段—引用计数算法"><span class="toc-text">1. 标记阶段—引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-循环引用"><span class="toc-text">1.1 循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-循环引用举例"><span class="toc-text">1.2 循环引用举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-小结"><span class="toc-text">1.3 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-标记阶段—可达性分析算法"><span class="toc-text">2. 标记阶段—可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-GC-Roots可以是哪些？"><span class="toc-text">2.1 GC Roots可以是哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-对象的finalization机制"><span class="toc-text">3. 对象的finalization机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-具体过程"><span class="toc-text">3.1 具体过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-代码演示"><span class="toc-text">3.2 代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MAT与JProfiler的GC-Roots溯源"><span class="toc-text">4. MAT与JProfiler的GC Roots溯源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-MAT是什么？"><span class="toc-text">4.1 MAT是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-命令行使用-jmap"><span class="toc-text">4.2 命令行使用 jmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-使用JVisualVM"><span class="toc-text">4.3 使用JVisualVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-使用MAT打开Dump文件"><span class="toc-text">4.4 使用MAT打开Dump文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-JProfiler的GC-Roots溯源"><span class="toc-text">4.5 JProfiler的GC Roots溯源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-如何判断什么原因造成OOM"><span class="toc-text">4.6 如何判断什么原因造成OOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-清除阶段—标记-清除算法"><span class="toc-text">5. 清除阶段—标记-清除算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-标记-清除算法的执行过程"><span class="toc-text">5.1 标记-清除算法的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-什么是清除？"><span class="toc-text">5.2 什么是清除？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-标记—清除算法的缺点"><span class="toc-text">5.3 标记—清除算法的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-清除阶段—复制算法"><span class="toc-text">6. 清除阶段—复制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-核心思想"><span class="toc-text">6.1 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-优缺点"><span class="toc-text">6.2 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-应用场景"><span class="toc-text">6.3 应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-清除阶段—标记-整理算法"><span class="toc-text">7. 清除阶段—标记-整理算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-执行过程"><span class="toc-text">7.1 执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-标记整理算法的优缺点"><span class="toc-text">7.2 标记整理算法的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-小结"><span class="toc-text">8. 小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-分代收集算法"><span class="toc-text">8.1 分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-增量收集算法"><span class="toc-text">8.2 增量收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-分区算法"><span class="toc-text">8.3 分区算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-写到最后"><span class="toc-text">8.3 写到最后</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#☆"><span class="toc-text">☆</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/images/qad.jpg"></div><div class="author-info-name">DuanChaojie</div><div class="author-info-description">DuanChaojie的个人博客</div><div class="links-buttons"><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">QQ: 1585636331<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">手机：17351015389<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">星星</span><span class="pull-bottom">74</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">6</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.cyc2018.xyz/" target="_blank">算法训练</a><a class="friend-link-text" href="https://www.bilibili.com/" target="_blank">相约B站</a><a class="friend-link-text" href="https://account.aliyun.com/" target="_blank">图床地址</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">it❤ld</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JavaSE-JVM/16.JVM之垃圾回收相关算法</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-12-19 | 更新于 2020-12-19</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/JavaSE-JVM/">JavaSE-JVM</a></div><div class="button-hover tags"></div></div></div><div class="main-content"><p>胡未灭，鬓先秋，泪空流。此生谁料，心在天山，身老沧洲。</p>
<p align="right">——陆游《诉衷情》</p>
<a id="more"></a>


<h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><blockquote>
<ol>
<li>在==堆里存放着几乎所有的Java对象实例==，在<code>GC执行垃圾回收</code>之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。<code>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</code></li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：<code>引用计数算法</code>和<code>可达性分析算法。</code></li>
</ol>
</blockquote>
<h3 id="1-标记阶段—引用计数算法"><a href="#1-标记阶段—引用计数算法" class="headerlink" title="1. 标记阶段—引用计数算法"></a>1. 标记阶段—引用计数算法</h3><blockquote>
<ol>
<li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个<code>整型的引用计数器属性。用于记录对象被引用的情况。</code></li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。<code>只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</code></li>
<li>优点：<code>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</code></li>
<li>缺点：<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有一个严重的问题，即==无法处理循环引用的情况==。这是一条致命缺陷，<code>导致在Java的垃圾回收器中没有使用这类算法。</code></li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="1-1-循环引用"><a href="#1-1-循环引用" class="headerlink" title="1.1 循环引用"></a>1.1 循环引用</h4><blockquote>
<p><code>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</code>；</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712102205795.png" alt="image-20200712102205795"></p>
<h4 id="1-2-循环引用举例"><a href="#1-2-循环引用举例" class="headerlink" title="1.2 循环引用举例"></a>1.2 循环引用举例</h4><blockquote>
<ol>
<li><code>我们使用一个案例来测试Java中是否采用的是引用计数算法</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用计数算法测试</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li><code>运行结果：</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">14148</span>K-&gt;<span class="number">712</span>K(<span class="number">75776</span>K)] <span class="number">14148</span>K-&gt;<span class="number">720</span>K(<span class="number">249344</span>K), <span class="number">0.0023576</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 712K-&gt;0<span class="title">K</span><span class="params">(<span class="number">75776</span>K)</span>] [ParOldGen: 8K-&gt;639<span class="title">K</span><span class="params">(<span class="number">173568</span>K)</span>] 720K-&gt;639<span class="title">K</span><span class="params">(<span class="number">249344</span>K)</span>, [Metaspace: 3437K-&gt;3437<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0060505 secs] [Times: user</span>=<span class="number">0.03</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">75776</span>K, used <span class="number">650</span>K [<span class="number">0x000000076b780000</span>, <span class="number">0x0000000770c00000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">65024</span>K, <span class="number">1</span>% used [<span class="number">0x000000076b780000</span>,<span class="number">0x000000076b822a68</span>,<span class="number">0x000000076f700000</span>)</span><br><span class="line">  from space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x000000076f700000</span>,<span class="number">0x000000076f700000</span>,<span class="number">0x0000000770180000</span>)</span><br><span class="line">  to   space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x0000000770180000</span>,<span class="number">0x0000000770180000</span>,<span class="number">0x0000000770c00000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">173568</span>K, used <span class="number">639</span>K [<span class="number">0x00000006c2600000</span>, <span class="number">0x00000006ccf80000</span>, <span class="number">0x000000076b780000</span>)</span><br><span class="line">  object space <span class="number">173568</span>K, <span class="number">0</span>% used [<span class="number">0x00000006c2600000</span>,<span class="number">0x00000006c269fce8</span>,<span class="number">0x00000006ccf80000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3444</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>我们能够看到，<code>上述进行了GC收集的行为</code>，将上述的新生代中的两个对象都进行回收了</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYoungGen: <span class="number">15490</span>K-&gt;<span class="number">808</span>K(<span class="number">76288</span>K)] <span class="number">15490</span>K-&gt;<span class="number">816</span>K(<span class="number">251392</span>K)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li><code>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</code></li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712103230349.png" alt="image-20200712103230349"></p>
<h4 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h4><blockquote>
<ol>
<li><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>
</li>
<li><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，<code>以提高吞吐量的尝试。</code></p>
</li>
<li><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
</li>
<li><p>Python如何解决循环引用？</p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li><code>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</code></li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="2-标记阶段—可达性分析算法"><a href="#2-标记阶段—可达性分析算法" class="headerlink" title="2. 标记阶段—可达性分析算法"></a>2. 标记阶段—可达性分析算法</h3><blockquote>
<ol>
<li><p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集。</p>
</li>
<li><p><code>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</code></p>
</li>
<li><p>相较于引用计数算法，<code>这里的可达性分析就是Java、C#选择的</code>。这种类型的垃圾收集通常也叫<code>作追踪性垃圾收集（Tracing Garbage Collection）。</code></p>
</li>
<li><p>==所谓”GC Roots”根集合就是一组必须活跃的引用。==</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以==根对象集合（GCRoots）==为起始点，<code>按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</code></li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为==引用链（Reference Chain）。==</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712104149246.png" alt="image-20200712104149246"></p>
<h4 id="2-1-GC-Roots可以是哪些？"><a href="#2-1-GC-Roots可以是哪些？" class="headerlink" title="2.1 GC Roots可以是哪些？"></a>2.1 GC Roots可以是哪些？</h4><blockquote>
<ul>
<li>虚拟机栈中引用的对象。<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内<code>JNI（通常说的本地方法）</code>引用的对象方法区中类静态属性引用的对象。<ul>
<li>比如：Java类的引用类型静态变量。</li>
</ul>
</li>
<li>方法区中常量引用的对象。<ul>
<li>比如：字符串常量池（string Table）里的引用。</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象。</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712104622677.png" alt="image-20200712104622677"></p>
<blockquote>
<ol>
<li>总结一句话就是，==除了堆空间外的一些结构，比如虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。==</li>
<li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。<ul>
<li><code>比如：分代收集和局部回收（PartialGC）。</code></li>
<li><code>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</code></li>
</ul>
</li>
<li>小技巧<ul>
<li>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</li>
</ul>
</li>
<li>注意<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li>
<li><code>这点也是导致GC进行时必须“stop The World”的一个重要原因。</code></li>
<li>即使是号称（几乎）<code>不会发生停顿的CMS收集器</code>中，枚举根节点时也是必须要停顿的。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="3-对象的finalization机制"><a href="#3-对象的finalization机制" class="headerlink" title="3. 对象的finalization机制"></a>3. 对象的finalization机制</h3><blockquote>
<ol>
<li><p>Java语言提供了<code>对象终止（finalization）机制</code>，来==允许开发人员提供对象被销毁之前的自定义处理逻辑。==</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即：<code>垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</code></p>
</li>
<li><p><code>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放</code>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li><p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在<code>finalize()</code> 时可能会导致对象复活。</li>
<li><code>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</code><ul>
<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收。</li>
</ul>
</li>
<li>一个糟糕的<code>finalize()</code> 会严重影响GC的性能。</li>
</ul>
</li>
<li><p>从功能上来说，<code>finalize() 方法与C++中的析构函数比较相似</code>，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以<code>finalize()方法</code>在本质上不同于C++中的析构函数。</p>
</li>
<li><p>由于<code>finalize()</code> 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
</li>
<li><p>==如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。==<code>一个无法触及的对象有可能在某一个条件下“复活”自己</code>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><code>可触及的：</code>从根节点开始，可以到达这个对象。</li>
<li><code>可复活的：</code>对象的所有引用都被释放，但是对象有可能在<code>finalize()</code> 中复活。</li>
<li><code>不可触及的：</code>对象的<code>finalize()</code> 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为==finalize()只会被调用一次==。</li>
</ul>
</li>
<li><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</li>
</ol>
</blockquote>
<h4 id="3-1-具体过程"><a href="#3-1-具体过程" class="headerlink" title="3.1 具体过程"></a>3.1 具体过程</h4><blockquote>
<p>判定一个<code>对象objA是否</code>可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果<code>对象objA到GC Roots没有引用链</code>，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize（）方法。<ol>
<li><code>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</code></li>
<li>如果对象objA重写了finalize（）方法，且还未执行过，==那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。==</li>
<li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。<code>如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</code>之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<code>一个对象的finalize方法只会被调用一次。</code></li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712110411885.png" alt="image-20200712110411885"></p>
<blockquote>
<p><code>上图就是我们看到的Finalizer线程</code></p>
</blockquote>
<h4 id="3-2-代码演示"><a href="#3-2-代码演示" class="headerlink" title="3.2 代码演示"></a>3.2 代码演示</h4><blockquote>
<p>们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中。`</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法</span></span><br><span class="line"><span class="comment"> * 对象复活场景</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">             obj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">             obj = <span class="keyword">null</span>;</span><br><span class="line">             System.gc();</span><br><span class="line">                </span><br><span class="line">             System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">             <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">             <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">             System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">             obj = <span class="keyword">null</span>;</span><br><span class="line">             System.gc();</span><br><span class="line">             <span class="comment">// 下面代码和上面代码是一样的，但是 obj 却自救失败了</span></span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">             <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">             &#125;     </span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后运行结果：</p>
<ul>
<li>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>



<h3 id="4-MAT与JProfiler的GC-Roots溯源"><a href="#4-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4. MAT与JProfiler的GC Roots溯源"></a>4. MAT与JProfiler的GC Roots溯源</h3><h4 id="4-1-MAT是什么？"><a href="#4-1-MAT是什么？" class="headerlink" title="4.1 MAT是什么？"></a>4.1 MAT是什么？</h4><blockquote>
<ol>
<li><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
</li>
<li><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
</li>
<li><p>可以在<a href="http://www.eclipse.org/mat/下载并使用MAT" target="_blank" rel="noopener">http://www.eclipse.org/mat/下载并使用MAT</a></p>
</li>
</ol>
</blockquote>
<h4 id="4-2-命令行使用-jmap"><a href="#4-2-命令行使用-jmap" class="headerlink" title="4.2 命令行使用 jmap"></a>4.2 命令行使用 jmap</h4><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024103959220.png" alt="image-20201024103959220"></p>
<blockquote>
<p>生成的dump文件在当前工程目录结构下。</p>
</blockquote>
<h4 id="4-3-使用JVisualVM"><a href="#4-3-使用JVisualVM" class="headerlink" title="4.3 使用JVisualVM"></a>4.3 使用JVisualVM</h4><blockquote>
<p><code>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</code></p>
<ol>
<li>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</li>
<li>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</li>
<li>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024104539148.png" alt="image-20201024104539148"></p>
<h4 id="4-4-使用MAT打开Dump文件"><a href="#4-4-使用MAT打开Dump文件" class="headerlink" title="4.4 使用MAT打开Dump文件"></a>4.4 使用MAT打开Dump文件</h4><blockquote>
<p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024105448207.png" alt="image-20201024105448207"></p>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024105609013.png" alt="image-20201024105609013"></p>
<blockquote>
<p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p>
</blockquote>
<h4 id="4-5-JProfiler的GC-Roots溯源"><a href="#4-5-JProfiler的GC-Roots溯源" class="headerlink" title="4.5 JProfiler的GC Roots溯源"></a>4.5 JProfiler的GC Roots溯源</h4><blockquote>
<p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024110209353.png" alt="image-20201024110209353"></p>
<blockquote>
<p>我们通过Show Selection In Heap Walker 来查询char[] 的具体情况：</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024110411415.png" alt="image-20201024110411415"> </p>
<blockquote>
<p>可以通过References中的Incoming references（溯源）来查看从哪个GC Root关联的。</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20201024110828713.png" alt="image-20201024110828713"></p>
<h4 id="4-6-如何判断什么原因造成OOM"><a href="#4-6-如何判断什么原因造成OOM" class="headerlink" title="4.6 如何判断什么原因造成OOM"></a>4.6 如何判断什么原因造成OOM</h4><blockquote>
<p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用-XX:+HeapDumpOnOutOfMemoryError将出错时候的dump文件输出。</code></li>
<li>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712150229048.png" alt="image-20200712150229048"></p>
<blockquote>
<p>然后我们通过线程，还能够定位到哪里出现OOM</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712150303710.png" alt="image-20200712150303710"></p>
<h3 id="5-清除阶段—标记-清除算法"><a href="#5-清除阶段—标记-清除算法" class="headerlink" title="5. 清除阶段—标记-清除算法"></a>5. 清除阶段—标记-清除算法</h3><blockquote>
<ol>
<li><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p>
<ul>
<li>`标记一清除算法（Mark-Sweep）``</li>
<li>``复制算法（copying）`</li>
<li>标记-压缩算法（Mark-Compact）`</li>
</ul>
</li>
<li><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，<code>该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</code></p>
</li>
</ol>
</blockquote>
<h4 id="5-1-标记-清除算法的执行过程"><a href="#5-1-标记-清除算法的执行过程" class="headerlink" title="5.1 标记-清除算法的执行过程"></a>5.1 标记-清除算法的执行过程</h4><blockquote>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ol>
<li><code>标记：</code>Collector从引用根节点开始遍历，<code>标记所有被引用的对象</code>。一般是在对象的Header中记录为可达对象。<ul>
<li><code>标记的是引用的对象，不是垃圾！！</code></li>
</ul>
</li>
<li><code>清除：</code>Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712150935078.png" alt="image-20200712150935078"></p>
<h4 id="5-2-什么是清除？"><a href="#5-2-什么是清除？" class="headerlink" title="5.2 什么是清除？"></a>5.2 什么是清除？</h4><blockquote>
<p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。<a href="https://blog.csdn.net/weixin_45267102/article/details/109162466" target="_blank" rel="noopener">关于空闲列表是在为对象分配内存的时候提过：</a></p>
<ul>
<li>如果内存规整：<ul>
<li>采用指针碰撞的方式进行内存分配。</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个列表。</li>
<li>空闲列表分配。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5-3-标记—清除算法的缺点"><a href="#5-3-标记—清除算法的缺点" class="headerlink" title="5.3 标记—清除算法的缺点"></a>5.3 标记—清除算法的缺点</h4><blockquote>
<ol>
<li><code>标记清除算法的效率不算高。</code></li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差。</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表。</li>
</ol>
</blockquote>
<h3 id="6-清除阶段—复制算法"><a href="#6-清除阶段—复制算法" class="headerlink" title="6. 清除阶段—复制算法"></a>6. 清除阶段—复制算法</h3><blockquote>
<p>为了解决标记—清除算法在垃圾收集效率方面的缺陷，<code>M.L.Minsky</code>于1963年发表了著名的论文，<code>“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”</code>。==M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法==，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
</blockquote>
<h4 id="6-1-核心思想"><a href="#6-1-核心思想" class="headerlink" title="6.1 核心思想"></a>6.1 核心思想</h4><blockquote>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712151916991.png" alt="image-20200712151916991"></p>
<blockquote>
<p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法。</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712152029615.png" alt="image-20200712152029615"></p>
<h4 id="6-2-优缺点"><a href="#6-2-优缺点" class="headerlink" title="6.2 优缺点"></a>6.2 优缺点</h4><blockquote>
<p><code>优点：</code></p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li><code>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</code></li>
</ul>
<p>特别地：</p>
<ul>
<li>如果系统中的垃圾对象很多，<code>复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</code>（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</li>
<li><code>即特别适合垃圾对象很多, 存活对象很少的场景; 例如:Young 区的Survivor0 和Survivor1 区。</code></li>
</ul>
</blockquote>
<h4 id="6-3-应用场景"><a href="#6-3-应用场景" class="headerlink" title="6.3 应用场景"></a>6.3 应用场景</h4><blockquote>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712152847218.png" alt="image-20200712152847218"></p>
<h3 id="7-清除阶段—标记-整理算法"><a href="#7-清除阶段—标记-整理算法" class="headerlink" title="7. 清除阶段—标记-整理算法"></a>7. 清除阶段—标记-整理算法</h3><blockquote>
<p>背景：</p>
<ol>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li>
<li><code>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</code></li>
<li>1970年前后，<code>G.L.Steele、C.J.Chene和D.s.Wise等</code>研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ol>
</blockquote>
<h4 id="7-1-执行过程"><a href="#7-1-执行过程" class="headerlink" title="7.1 执行过程"></a>7.1 执行过程</h4><blockquote>
<ol>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
</li>
<li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
</li>
<li><p><code>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</code></p>
</li>
<li><p>标清和标整的区别</p>
<ul>
<li>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li>
</ul>
</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712153236508.png" alt="image-20200712153236508"></p>
<h4 id="7-2-标记整理算法的优缺点"><a href="#7-2-标记整理算法的优缺点" class="headerlink" title="7.2 标记整理算法的优缺点"></a>7.2 标记整理算法的优缺点</h4><blockquote>
<p>优点：</p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p>缺点：</p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW.</li>
</ul>
</blockquote>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h3><blockquote>
<ol>
<li><code>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</code></li>
<li>而为了尽量兼顾上面提到的三个指标，==标记-整理算法相对来说更平滑一些==，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>标记-清除算法</th>
<th>标记-整理算法</th>
<th>复制算法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p><code>综合我们可以找到，没有最好的算法，只有最合适的算法</code></p>
</blockquote>
<h4 id="8-1-分代收集算法"><a href="#8-1-分代收集算法" class="headerlink" title="8.1 分代收集算法"></a>8.1 分代收集算法</h4><blockquote>
<ol>
<li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
</li>
<li><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
</li>
<li><p><code>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</code></p>
</li>
<li><p>目前几乎所有的<code>GC</code>都采用分代收集算法执行垃圾回收的。</p>
</li>
<li><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li><code>年轻代（Young Gen）特点：</code>==区域相对老年代较小，对象生命周期短、存活率低，回收频繁。==这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li>
<li><code>老年代（Tenured Gen）特点：</code>==区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。==这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>compact阶段的开销与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep（标记清除）实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact（标记整理）算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行Full GC以达到对老年代内存的整理。</code></p>
</li>
<li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
</li>
</ol>
</blockquote>
<h4 id="8-2-增量收集算法"><a href="#8-2-增量收集算法" class="headerlink" title="8.2 增量收集算法"></a>8.2 增量收集算法</h4><blockquote>
<p>概述：</p>
<ol>
<li>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</li>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</li>
<li>总的来说，<code>增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</code></li>
</ol>
<p>缺点：</p>
<ol>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</li>
</ol>
</blockquote>
<h4 id="8-3-分区算法"><a href="#8-3-分区算法" class="headerlink" title="8.3 分区算法"></a>8.3 分区算法</h4><blockquote>
<ol>
<li><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
</li>
<li><p><code>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</code>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
</li>
</ol>
</blockquote>
<p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-JVM/image-20200712165318590.png" alt="image-20200712165318590"></p>
<h4 id="8-3-写到最后"><a href="#8-3-写到最后" class="headerlink" title="8.3 写到最后"></a>8.3 写到最后</h4><blockquote>
<p>==注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。==</p>
</blockquote>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DuanChaojie</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://www.itbuild.cn/2020/12/19/JavaSE-JVM/16.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/">http://www.itbuild.cn/2020/12/19/JavaSE-JVM/16.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.itbuild.cn">it❤ld</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/12/19/JavaSE-JVM/17.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"><i class="fas fa-angle-left">&nbsp;</i><span>JavaSE-JVM/17.JVM之垃圾回收相关概念</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/12/19/JavaSE-JVM/15.JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"><span>JavaSE-JVM/15.JVM之垃圾回收概述</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2020 By DuanChaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>