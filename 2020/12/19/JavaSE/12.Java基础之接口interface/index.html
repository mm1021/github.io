<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaSE/12.Java基础之接口interface"><meta name="keywords" content=""><meta name="author" content="DuanChaojie,undefined"><meta name="copyright" content="DuanChaojie"><title>JavaSE/12.Java基础之接口interface【it❤ld】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/images/itbui.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="it❤ld" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java基础之接口"><span class="toc-text">1. Java基础之接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-接口的定义"><span class="toc-text">1.1 接口的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-定义一个接口"><span class="toc-text">1.2 定义一个接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-接口和抽象类区别"><span class="toc-text">1.3 接口和抽象类区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-（接口）抽象方法的定义"><span class="toc-text">1.4 （接口）抽象方法的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#jdk7–接口中只能存在"><span class="toc-text">jdk7–接口中只能存在</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#jdk8-–接口中扩展的内容"><span class="toc-text">jdk8 –接口中扩展的内容</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#jdk9-–扩展的内容"><span class="toc-text">jdk9 –扩展的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-接口的特征"><span class="toc-text">1.5 接口的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-接口的多实现"><span class="toc-text">1. 接口的多实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-接口的多继承"><span class="toc-text">2. 接口的多继承</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#☆"><span class="toc-text">☆</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/images/qad.jpg"></div><div class="author-info-name">DuanChaojie</div><div class="author-info-description">DuanChaojie的个人博客</div><div class="links-buttons"><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">QQ: 1585636331<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">手机：17351015389<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">星星</span><span class="pull-bottom">122</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">11</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.cyc2018.xyz/" target="_blank">算法训练</a><a class="friend-link-text" href="https://www.bilibili.com/" target="_blank">相约B站</a><a class="friend-link-text" href="https://account.aliyun.com/" target="_blank">图床地址</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">it❤ld</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JavaSE/12.Java基础之接口interface</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-12-19 | 更新于 2020-12-19</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/JavaSE/">JavaSE</a></div><div class="button-hover tags"></div></div></div><div class="main-content"><p>庭院深深深几许，杨柳堆烟，帘幕无重数。</p>
<p align="right">——欧阳修《蝶恋花》</p>
<a id="more"></a>


<h2 id="1-Java基础之接口"><a href="#1-Java基础之接口" class="headerlink" title="1. Java基础之接口"></a>1. Java基础之接口</h2><h4 id="1-1-接口的定义"><a href="#1-1-接口的定义" class="headerlink" title="1.1 接口的定义"></a>1.1 接口的定义</h4><blockquote>
<ol>
<li>是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么<code>接口</code>的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</li>
<li><code>接口</code>就是多个类的公共的规范,接口是一种引用数据类型(引用数据类型：数组，类，接口。)，接口中最重要的内容就是：抽象方法。</li>
</ol>
</blockquote>
<h4 id="1-2-定义一个接口"><a href="#1-2-定义一个接口" class="headerlink" title="1.2 定义一个接口"></a>1.2 定义一个接口</h4><blockquote>
<p>备注：把class替换成interface。但是.java文件编译之后依然是生成class字节码文件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口的名称</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//常量;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//抽象方法;(并不是所有的方法都是抽象方法)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义实现类</p>
<ol>
<li>既然说接口中存在大量抽象方法，无法直接创建对象，必须有一个<strong>实现类</strong>来实现当前的接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.实现类的格式为： </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名</span>&#123;</span><br><span class="line">    <span class="comment">// 实现所有的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.接口的实现中，必须实现（重写）接口中的所有的从抽象方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建实现类，调用具体的放。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义一个抽象实现类//如果在抽象的类中，可以重写也可以不重写抽象方法(而接口中必须重写抽象方法)。</li>
<li>定义一个普通类//如果在普通的类中，必须重写接口中的所有的抽象方法。</li>
<li>如果实现类中没有覆盖重写所有的抽象方法,那么这个实现类必须是一个抽象类。</li>
</ol>
</blockquote>
<h4 id="1-3-接口和抽象类区别"><a href="#1-3-接口和抽象类区别" class="headerlink" title="1.3 接口和抽象类区别"></a>1.3 <a href="http://blog.csdn.net/sunboard/article/details/3831823" target="_blank" rel="noopener">接口和抽象类区别</a></h4><blockquote>
<ol>
<li>Animal 抽象类   <code>Dog ex Animal;     dog is a Animal;</code> <strong>抽象类是用来抽取是实现类的模板。</strong></li>
<li>Computer 接口   <code>USB implements Computer;      computer has a USB;</code>  <strong>接口是用来扩展功能的。</strong></li>
</ol>
</blockquote>
<h4 id="1-4-（接口）抽象方法的定义"><a href="#1-4-（接口）抽象方法的定义" class="headerlink" title="1.4 （接口）抽象方法的定义"></a>1.4 （接口）抽象方法的定义</h4><blockquote>
<p>在任何的java版本里面，接口中只能定义抽象方法，不能定义普通方法。但是扩展了默认方法和静态方法和私有方法。</p>
<ol>
<li><code>Public  abstract 方法的返回值类型  方法名称（参数列表）</code></li>
<li>修饰符：接口中的抽象类必须使用public修饰。如果你不写，默认会加上一个public</li>
<li>abstract修饰当前方法为一个抽象方法。即使没写，默认会加上一个abstract</li>
<li>public abstract 都可以不写。默认加上。</li>
</ol>
</blockquote>
<h6 id="jdk7–接口中只能存在"><a href="#jdk7–接口中只能存在" class="headerlink" title="jdk7–接口中只能存在"></a><code>jdk7</code>–接口中只能存在</h6><blockquote>
<ol>
<li><p>常量；其中接口中的成员属性都是常量（全大写，单词用下划线分割），常量在使用的时候必须先赋值。</p>
<ol>
<li>不写默认加<code>public static final</code>：<code>public static final int VOICE_NUM</code> = <code>30</code>;</li>
</ol>
</li>
<li><p>抽象方法；</p>
</li>
</ol>
</blockquote>
<h6 id="jdk8-–接口中扩展的内容"><a href="#jdk8-–接口中扩展的内容" class="headerlink" title="jdk8 –接口中扩展的内容"></a><code>jdk8</code> –接口中扩展的内容</h6><blockquote>
<ol>
<li><p>添加默认方法的功能，解决接口升级所来的大量影响。默认方法可以直接使用实现类的对象来调用</p>
</li>
<li><p>静态方法—不能使用实现了的对象调用，应该使用接口名.静态方法名来调用。</p>
</li>
</ol>
</blockquote>
<h6 id="jdk9-–扩展的内容"><a href="#jdk9-–扩展的内容" class="headerlink" title="jdk9 –扩展的内容"></a><code>jdk9</code> –扩展的内容</h6><blockquote>
<ol>
<li>私有方法。私有方法只能在接口中调用–私有方法解决了–抽取公共代码，减少代码冗余，提高了代码的复用性。</li>
</ol>
</blockquote>
<h4 id="1-5-接口的特征"><a href="#1-5-接口的特征" class="headerlink" title="1.5 接口的特征"></a>1.5 接口的特征</h4><h6 id="1-接口的多实现"><a href="#1-接口的多实现" class="headerlink" title="1. 接口的多实现"></a>1. 接口的多实现</h6><blockquote>
<ol>
<li>如果一类实现的多个接口中出现了相同的抽象方法，只会重写其中的一个方法</li>
<li>如果一个类实现的多个接口中出现了相同的默认方法，（因为默认方法不需要重写，所以通过当前类的对象调用的时候，会发生冲突。所以<code>jdk8</code>提供了强制的要求） 那么应该将当前的默认方法在本类中重写。</li>
<li>接口中不允许有static静态代码块，接口中，没有构造方法。</li>
</ol>
</blockquote>
<h6 id="2-接口的多继承"><a href="#2-接口的多继承" class="headerlink" title="2. 接口的多继承"></a>2. 接口的多继承</h6><blockquote>
<p>java是单继承的但是接口是多继承的。如果在继承的多个接口中，出现了每个接口里面有相同默认方法，那么实现的接口中，重写默认方法。可以写成default类型的，也可以写成抽象方法。</p>
</blockquote>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DuanChaojie</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://www.itbuild.cn/2020/12/19/JavaSE/12.Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3interface/">http://www.itbuild.cn/2020/12/19/JavaSE/12.Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3interface/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.itbuild.cn">it❤ld</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/12/19/JavaSE/13.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/"><i class="fas fa-angle-left">&nbsp;</i><span>JavaSE/13.面向对象特性之多态</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/12/19/JavaSE/11.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"><span>JavaSE/11.面向对象特性之继承</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2020 ～ 2021 By DuanChaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>