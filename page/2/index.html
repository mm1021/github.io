<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="DuanChaojie的个人博客"><meta name="keywords"><meta name="author" content="DuanChaojie,undefined"><meta name="copyright" content="DuanChaojie"><title>【it❤ld】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/images/avatar.jpg"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="it❤ld" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/images/avatar.jpg"></div><div class="author-info-name">DuanChaojie</div><div class="author-info-description">DuanChaojie的个人博客</div><div class="links-buttons"><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">QQ:1585636331<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="https://www.itbuild.cn" target="_blank">手机：17351015389<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">星星</span><span class="pull-bottom">20</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/archives">归档</a></nav><div class="right-info"><a class="title-name" href="/">it❤ld</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/5.AMQP/">rabbitmq笔记/5.AMQP</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-14</time></div><div class="post-content"><div class="main-content content"><h1 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h1><h2 id="1-相关概念介绍"><a href="#1-相关概念介绍" class="headerlink" title="1. 相关概念介绍"></a>1. 相关概念介绍</h2><p>AMQP  一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>
<p>AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。</p>
<p>RabbitMQ是AMQP协议的Erlang的实现。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>连接Connection</td>
<td>一个网络连接，比如TCP/IP套接字连接。</td>
</tr>
<tr>
<td>会话Session</td>
<td>端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。</td>
</tr>
<tr>
<td>信道Channel</td>
<td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td>
</tr>
<tr>
<td>客户端Client</td>
<td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td>
</tr>
<tr>
<td>服务节点Broker</td>
<td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td>
</tr>
<tr>
<td>端点</td>
<td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td>
</tr>
<tr>
<td>消费者Consumer</td>
<td>一个从消息队列里请求消息的客户端程序。</td>
</tr>
<tr>
<td>生产者Producer</td>
<td>一个向交换机发布消息的客户端应用程序。</td>
</tr>
</tbody></table>
<h2 id="2-RabbitMQ运转流程"><a href="#2-RabbitMQ运转流程" class="headerlink" title="2. RabbitMQ运转流程"></a>2. RabbitMQ运转流程</h2><p>在入门案例中：</p>
<ul>
<li>生产者发送消息<ol>
<li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li>
<li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li>
<li>将路由键（空字符串）与队列绑定起来；</li>
<li>发送消息至RabbitMQ Broker；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
<li>消费者接收消息<ol>
<li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li>
<li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li>
<li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li>
<li>确认（ack，自动确认）接收到的消息；</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
</ul>
<p><img src="assets/1565105223969.png" alt="1565105223969"></p>
<h2 id="3-生产者流转过程说明"><a href="#3-生产者流转过程说明" class="headerlink" title="3. 生产者流转过程说明"></a>3. 生产者流转过程说明</h2><ol>
<li>客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li>
<li>客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="assets/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E5%9B%BE.bmp" alt="生产者流转过程图"></p>
<h2 id="4-消费者流转过程说明"><a href="#4-消费者流转过程说明" class="headerlink" title="4. 消费者流转过程说明"></a>4. 消费者流转过程说明</h2><ol>
<li>消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li>
<li>消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。</li>
<li>在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。</li>
<li>Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。</li>
<li>消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="assets/%E6%B6%88%E8%B4%B9%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E5%9B%BE.bmp" alt="消费者流转过程图"></p>
<h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/5.AMQP/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/4.RabbitMQ%E5%85%A5%E9%97%A8/">rabbitmq笔记/4.RabbitMQ入门</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-14</time></div><div class="post-content"><div class="main-content content"><p>[toc]</p>
<h2 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h2><h3 id="1-搭建示例工程"><a href="#1-搭建示例工程" class="headerlink" title="1. 搭建示例工程"></a>1. 搭建示例工程</h3><h4 id="1-1-创建工程"><a href="#1-1-创建工程" class="headerlink" title="1.1 创建工程"></a>1.1 创建工程</h4><p><img src="assets/1558319510387.png" alt="1555991321159"></p>
<p><img src="assets/1558319546688.png" alt="1555991353704"></p>
<h4 id="1-2-添加依赖"><a href="#1-2-添加依赖" class="headerlink" title="1.2 添加依赖"></a>1.2 添加依赖</h4><p>往heima-rabbitmq的pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-编写生产者"><a href="#2-编写生产者" class="headerlink" title="2. 编写生产者"></a>2. 编写生产者</h3><p>编写消息生产者com.itheima.producer.Producer_HelloWorld;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer_HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">"106.15.72.229"</span>);<span class="comment">//ip  默认值 localhost</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">//端口  默认值 5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/itcast"</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">        factory.setUsername(<span class="string">"heima"</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">        factory.setPassword(<span class="string">"heima"</span>);<span class="comment">//密码 默认值 guest</span></span><br><span class="line">        <span class="comment">//3. 创建连接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4. 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5. 创建队列Queue</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            1. queue：队列名称</span></span><br><span class="line"><span class="comment">            2. durable:是否持久化，当mq重启之后，还在</span></span><br><span class="line"><span class="comment">            3. exclusive：</span></span><br><span class="line"><span class="comment">                * 是否独占。只能有一个消费者监听这队列</span></span><br><span class="line"><span class="comment">                * 当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">            4. autoDelete:是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">            5. arguments：参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果没有一个名字叫hello_world的队列，则会创建该队列，如果有则不会创建</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"hello_world"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            1. exchange：交换机名称。简单模式下交换机会使用默认的 ""</span></span><br><span class="line"><span class="comment">            2. routingKey：路由名称</span></span><br><span class="line"><span class="comment">            3. props：配置信息</span></span><br><span class="line"><span class="comment">            4. body：发送消息数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        String body = <span class="string">"hello rabbitmq~~~"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">"hello_world"</span>, <span class="keyword">null</span>, body.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息：</p>
<p><img src="assets/image-20201214231440832.png" alt="image-20201214231440832"></p>
<p><img src="assets/image-20201214231617494.png" alt="image-20201214231617494"></p>
<h3 id="3-编写消费者"><a href="#3-编写消费者" class="headerlink" title="3. 编写消费者"></a>3. 编写消费者</h3><p>编写消息的消费者com.itheima.consumer.Consumer_HelloWorld;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer_HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">"106.15.72.229"</span>);<span class="comment">//ip  默认值 localhost</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">//端口  默认值 5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/itcast"</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">        factory.setUsername(<span class="string">"heima"</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">        factory.setPassword(<span class="string">"heima"</span>);<span class="comment">//密码 默认值 guest</span></span><br><span class="line">        <span class="comment">//3. 创建连接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4. 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5. 创建队列Queue</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            1. queue：队列名称</span></span><br><span class="line"><span class="comment">            2. durable:是否持久化，当mq重启之后，还在</span></span><br><span class="line"><span class="comment">            3. exclusive：</span></span><br><span class="line"><span class="comment">                * 是否独占。只能有一个消费者监听这队列</span></span><br><span class="line"><span class="comment">                * 当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">            4. autoDelete:是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">            5. arguments：参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果没有一个名字叫hello_world的队列，则会创建该队列，如果有则不会创建</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"hello_world"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            1. queue：队列名称</span></span><br><span class="line"><span class="comment">            2. autoAck：是否自动确认</span></span><br><span class="line"><span class="comment">            3. callback：回调对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                1. consumerTag：标识</span></span><br><span class="line"><span class="comment">                2. envelope：获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">                3. properties:配置信息</span></span><br><span class="line"><span class="comment">                4. body：数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"consumerTag："</span>+consumerTag);</span><br><span class="line">                System.out.println(<span class="string">"Exchange："</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">"RoutingKey："</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">"properties："</span>+properties);</span><br><span class="line">                System.out.println(<span class="string">"body："</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">"hello_world"</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源？不要</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20201214231933716.png" alt="image-20201214231933716"></p>
<p><img src="assets/image-20201214232206963.png" alt="image-20201214232206963"></p>
<p><img src="assets/image-20201214232226947.png" alt="image-20201214232226947"></p>
<p><img src="assets/image-20201214232238896.png" alt="image-20201214232238896"></p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>抽取创建connection的工具类com.itheima.util.ConnectionUtil；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机地址;默认为 localhost</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"106.15.72.229"</span>);</span><br><span class="line">        <span class="comment">//连接端口;默认为 5672</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//虚拟主机名称;默认为 /</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/itcast"</span>);</span><br><span class="line">        <span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"heima"</span>);</span><br><span class="line">        <span class="comment">//连接密码；默认为guest</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">"heima"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的入门案例中中其实使用的是如下的<code>简单模式：</code></p>
<p><img src="assets/1555991074575.png" alt="1555991074575"></p>
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/4.RabbitMQ%E5%85%A5%E9%97%A8/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/3.RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">rabbitmq笔记/3.RabbitMQ的安装和配置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-15</time></div><div class="post-content"><div class="main-content content"><p>[toc]</p>
<h2 id="RabbitMQ的安装和配置"><a href="#RabbitMQ的安装和配置" class="headerlink" title="RabbitMQ的安装和配置"></a>RabbitMQ的安装和配置</h2><p><a href="https://blog.csdn.net/Kermit_father/article/details/105181740" target="_blank" rel="noopener">https://blog.csdn.net/Kermit_father/article/details/105181740</a></p>
<h3 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h3><p>在线安装依赖环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>

<h3 id="2-安装Erlang"><a href="#2-安装Erlang" class="headerlink" title="2. 安装Erlang"></a>2. 安装Erlang</h3><p>上传下面三个安装包</p>
<p><code>erlang-18.3-1.el7.centos.x86_64.rpm</code></p>
<p><code>socat-1.7.3.2-5.el7.lux.x86_64.rpm</code></p>
<p><code>rabbitmq-server-3.6.5-1.noarch.rpm</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载erlang</span></span><br><span class="line">wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载socat</span></span><br><span class="line">wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载rabbitmq-server</span></span><br><span class="line">wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>如果出现如下错误</p>
<p><img src="assets/1565526174751.png" alt="1565526174751"></p>
<p>说明gblic 版本太低。我们可以查看当前机器的gblic 版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure>

<p><img src="assets/1565526264426.png" alt="1565526264426"></p>
<p>当前最高版本2.12，需要2.15.所以需要升级glibc</p>
<ul>
<li><p>使用yum更新安装依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载rpm包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装rpm包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完毕后再查看glibc版本,发现glibc版本已经到2.17了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p><img src="assets/1565528746057.png" alt="1565528746057"></p>
<h3 id="3-安装RabbitMQ"><a href="#3-安装RabbitMQ" class="headerlink" title="3. 安装RabbitMQ"></a>3. 安装RabbitMQ</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>


<h3 id="4-开启管理界面及配置"><a href="#4-开启管理界面及配置" class="headerlink" title="4. 开启管理界面及配置"></a>4. 开启管理界面及配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启管理界面</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认配置信息 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin</span><br><span class="line">vim rabbit.app </span><br><span class="line"><span class="comment"># 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;"guest"&gt;&gt;,只保留guest</span></span><br></pre></td></tr></table></figure>


<h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server  <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop rabbitmq-server  <span class="comment"># 停止服务</span></span><br><span class="line">systemctl restart rabbitmq-server  <span class="comment"># 重启服务</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>设置配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/doc/rabbitmq-server-3.6.5/</span><br><span class="line"></span><br><span class="line">cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure>

<p>启动rabbitmq</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin</span><br><span class="line"> </span><br><span class="line">rabbitmq-server start &amp;</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  rabbitmq-server -deched  --后台启动节点</span><br><span class="line"> </span><br><span class="line">  rabbitmqctl stop_app --关闭节点上的应用</span><br><span class="line"> </span><br><span class="line">  rabbitmqctl start_app --启动节点上的应用</span><br><span class="line"> </span><br><span class="line">  rabbitmqctl stop --关闭节点</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20201215115721783.png" alt="image-20201215115721783"></p>
<blockquote>
<p>修改了用户名之后，重启服务器造成创建用户丢失：</p>
<p>因为rabbitmq数据是根据当前hostname作为node节点作为数据名保存，这一点可以从rabbitmq-env文件中可以看出。</p>
<p>解决方案：</p>
<ol>
<li>不要更改hostname</li>
<li><a href="https://blog.csdn.net/qq_27037443/article/details/78050526" target="_blank" rel="noopener">https://blog.csdn.net/qq_27037443/article/details/78050526</a></li>
</ol>
</blockquote>
<h3 id="6-配置虚拟主机及用户"><a href="#6-配置虚拟主机及用户" class="headerlink" title="6. 配置虚拟主机及用户"></a>6. 配置虚拟主机及用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">执行添加用户命令</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行设置权限命令</span></span><br><span class="line">rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行设置角色命令</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行查看用户命令</span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>

<h4 id="6-1-用户角色"><a href="#6-1-用户角色" class="headerlink" title="6.1 用户角色"></a>6.1 用户角色</h4><p>RabbitMQ在安装好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：</p>
<p><img src="assets/1565098043833.png" alt="1565098043833"> </p>
<p><img src="assets/1565098315375.png" alt="1565098315375"></p>
<p><strong>角色说明</strong>：</p>
<p>1、 超级管理员(administrator)</p>
<p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p>
<p>2、 监控者(monitoring)</p>
<p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>
<p>3、 策略制定者(policymaker)</p>
<p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p>
<p>4、 普通管理者(management)</p>
<p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p>
<p>5、 其他</p>
<p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p>
<h4 id="6-2-Virtual-Hosts配置"><a href="#6-2-Virtual-Hosts配置" class="headerlink" title="6.2 Virtual Hosts配置"></a>6.2 Virtual Hosts配置</h4><p><code>像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；</code>在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。</p>
<h6 id="创建Virtual-Hosts"><a href="#创建Virtual-Hosts" class="headerlink" title="创建Virtual Hosts"></a>创建Virtual Hosts</h6><p><img src="assets/1565098496482.png" alt="1565098496482"></p>
<h6 id="设置Virtual-Hosts权限"><a href="#设置Virtual-Hosts权限" class="headerlink" title="设置Virtual Hosts权限"></a>设置Virtual Hosts权限</h6><p><img src="assets/1565098585317.png" alt="1565098585317"></p>
<p><img src="assets/1565098719054.png" alt="1565098719054"></p>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/3.RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/2.RabbitMQ%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">rabbitmq笔记/2.RabbitMQ基本介绍</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-14</time></div><div class="post-content"><div class="main-content content"><p>[toc]</p>
<h2 id="RabbitMQ基本介绍"><a href="#RabbitMQ基本介绍" class="headerlink" title="RabbitMQ基本介绍"></a>RabbitMQ基本介绍</h2><p><code>AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议</code>，是<code>应用层协议</code>的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。<code>2006年，AMQP 规范发布。类比HTTP。</code></p>
<p><img src="assets/image-20201214204900113.png" alt="image-20201214204900113"></p>
<p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。<code>Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</code></p>
<h3 id="1-RabbitMQ-基础架构"><a href="#1-RabbitMQ-基础架构" class="headerlink" title="1. RabbitMQ 基础架构"></a>1. RabbitMQ 基础架构</h3><p><img src="assets/image-20201214204938331.png" alt="image-20201214204938331"></p>
<h3 id="2-RabbitMQ-中的相关概念"><a href="#2-RabbitMQ-中的相关概念" class="headerlink" title="2. RabbitMQ 中的相关概念"></a>2. RabbitMQ 中的相关概念</h3><p><code>Broker：</code>接收和分发消息的应用，<code>RabbitMQ Server就是 Message Broker。</code></p>
<p><code>Virtual host：</code>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
<p><code>Connection：</code>publisher／consumer 和 broker 之间的 TCP 连接。</p>
<p><code>Channel：</code>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</p>
<p><code>Exchange：</code>message 到达 broker 的第一站，根据分发规则，<code>匹配查询表中的 routing key，</code>分发消息到queue 中去。常用的类型有：</p>
<ul>
<li><code>direct (point-to-point)</code></li>
<li><code>topic (publish-subscribe)</code> </li>
<li><code>fanout (multicast)</code></li>
</ul>
<p><code>Queue：</code>消息最终被送到这里等待 consumer 取走</p>
<p><code>Binding：</code>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>
<h3 id="3-RabbitMQ的6-种工作模式"><a href="#3-RabbitMQ的6-种工作模式" class="headerlink" title="3. RabbitMQ的6 种工作模式"></a>3. RabbitMQ的6 种工作模式</h3><p>RabbitMQ 提供了 6 种工作模式：</p>
<p>==简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。==</p>
<p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="assets/1555988678324.png" alt="1555988678324"></p>
<h3 id="4-AMQP-和-JMS"><a href="#4-AMQP-和-JMS" class="headerlink" title="4. AMQP 和 JMS"></a>4. AMQP 和 JMS</h3><p>MQ是消息通信的模型；<code>实现MQ的大致有两种主流方式：AMQP、JMS。</code></p>
<h4 id="4-1-AMQP"><a href="#4-1-AMQP" class="headerlink" title="4.1 AMQP"></a>4.1 AMQP</h4><p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h4 id="4-2-JMS"><a href="#4-2-JMS" class="headerlink" title="4.2 JMS"></a>4.2 JMS</h4><p><code>JMS即Java消息服务（JavaMessage Service）应用程序接口，</code>是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<p> JMS 是 JavaEE 规范中的一种，类比JDBC。</p>
<h4 id="4-3-AMQP-与-JMS-区别☆"><a href="#4-3-AMQP-与-JMS-区别☆" class="headerlink" title="4.3 AMQP 与 JMS 区别☆"></a>4.3 AMQP 与 JMS 区别☆</h4><p>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</p>
<p>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</p>
<p>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</p>
<h4 id="4-4-再谈市场上常见的消息队列"><a href="#4-4-再谈市场上常见的消息队列" class="headerlink" title="4.4 再谈市场上常见的消息队列"></a>4.4 再谈市场上常见的消息队列</h4><p>ActiveMQ：基于JMS</p>
<p>ZeroMQ：基于C语言开发</p>
<p>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</p>
<p>RocketMQ：基于JMS，阿里巴巴产品</p>
<p>Kafka：类似MQ的产品；分布式消息系统，高吞吐量。</p>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/2.RabbitMQ%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/12.SpringBoot%E4%B8%AD%E9%9B%86%E6%88%90ActiveMQ/">rabbitmq笔记/12.SpringBoot中集成ActiveMQ</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-16</time></div><div class="post-content"><div class="main-content content"><h2 id="SpringBoot中集成ActiveMQ"><a href="#SpringBoot中集成ActiveMQ" class="headerlink" title="SpringBoot中集成ActiveMQ"></a>SpringBoot中集成ActiveMQ</h2><h3 id="1-JMS-和-ActiveMQ-介绍"><a href="#1-JMS-和-ActiveMQ-介绍" class="headerlink" title="1. JMS 和 ActiveMQ 介绍"></a>1. JMS 和 ActiveMQ 介绍</h3><h4 id="1-1-JMS-是啥"><a href="#1-1-JMS-是啥" class="headerlink" title="1.1 JMS 是啥"></a>1.1 JMS 是啥</h4><p>百度百科的解释：</p>
<blockquote>
<p><code>JMS 即 Java 消息服务（Java Message Service）应用程序接口</code>，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>
</blockquote>
<p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p>
<blockquote>
<p>连接工厂：ConnectionFactory</p>
<p>JMS连接：Connection</p>
<p>JMS会话：Session</p>
<p>JMS目的：Destination</p>
<p>JMS生产者：Producer</p>
<p>JMS消费者：Consumer</p>
<p><code>JMS消息两种类型：点对点和发布/订阅。</code></p>
</blockquote>
<p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p>
<h4 id="1-2-ActiveMQ"><a href="#1-2-ActiveMQ" class="headerlink" title="1.2 ActiveMQ"></a>1.2 ActiveMQ</h4><p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。</p>
<p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p>
<h3 id="2-ActiveMQ安装"><a href="#2-ActiveMQ安装" class="headerlink" title="2. ActiveMQ安装"></a>2. ActiveMQ安装</h3><p>使用 ActiveMQ 首先需要去官网下载，官网地址为：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a></p>
<p>本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个  activemq-all-5.15.3.jar ，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。</p>
<p>消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费启动完成后，在浏览器中输入  <a href="http://127.0.0.1:8161/admin/" target="_blank" rel="noopener">http://127.0.0.1:8161/admin/</a> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p>
<p><img src="assets/image-20201216134216543.png" alt="image-20201216134216543"></p>
<p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p>
<p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。</p>
<p>Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p>
<h3 id="3-ActiveMQ集成"><a href="#3-ActiveMQ集成" class="headerlink" title="3. ActiveMQ集成"></a>3. ActiveMQ集成</h3><h4 id="3-1-依赖导入和配置"><a href="#3-1-依赖导入和配置" class="headerlink" title="3.1 依赖导入和配置"></a>3.1 依赖导入和配置</h4><p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">activemq:</span></span><br><span class="line">  <span class="comment"># activemq url</span></span><br><span class="line">  <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">  <span class="attr">in-memory:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pool:</span></span><br><span class="line">   <span class="comment"># 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-Queue-和-Topic-的创建"><a href="#3-2-Queue-和-Topic-的创建" class="headerlink" title="3.2 Queue 和 Topic 的创建"></a>3.2 Queue 和 Topic 的创建</h4><p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* activemq的配置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发布/订阅模式队列名称</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"activemq.topic"</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 点对点模式队列名称</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"activemq.queue"</span>;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">topic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(TOPIC_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(QUEUE_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出创建 Queue 和 Topic 两种消息，分别使用  new ActiveMQQueue 和  new ActiveMQTopic 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p>
<h4 id="3-3-消息的发送接口"><a href="#3-3-消息的发送接口" class="headerlink" title="3.3 消息的发送接口"></a>3.3 消息的发送接口</h4><p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消息发送者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, String msg)</span> </span>&#123;</span><br><span class="line">    jmsMessagingTemplate.convertAndSend(destination, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>convertAndSend 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p>
<h4 id="3-4-点对点消息生产与消费"><a href="#3-4-点对点消息生产与消费" class="headerlink" title="3.4 点对点消息生产与消费"></a>3.4 点对点消息生产与消费</h4><h6 id="3-4-1-点对点消息的生产"><a href="#3-4-1-点对点消息的生产" class="headerlink" title="3.4.1 点对点消息的生产"></a>3.4.1 点对点消息的生产</h6><p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在Controller 中我们直接注入进来即可。然后调用上文的消息发送方法  sendMessage 即可成功生产一条消息。</p>
</div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/12.SpringBoot%E4%B8%AD%E9%9B%86%E6%88%90ActiveMQ/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/11.RabbitMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">rabbitmq笔记/11.RabbitMQ集群搭建</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-15</time></div><div class="post-content"><div class="main-content content"><h2 id="RabbitMQ集群搭建"><a href="#RabbitMQ集群搭建" class="headerlink" title="RabbitMQ集群搭建"></a>RabbitMQ集群搭建</h2><p>摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理</p>
<p>一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。</p>
<h3 id="3-1-集群方案的原理"><a href="#3-1-集群方案的原理" class="headerlink" title="3.1 集群方案的原理"></a>3.1 集群方案的原理</h3><p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。<code>因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。</code>集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</p>
<p><img src="assets/1566073768274.png" alt="1565245219265"></p>
<h3 id="3-2-单机多实例部署"><a href="#3-2-单机多实例部署" class="headerlink" title="3.2 单机多实例部署"></a>3.2 单机多实例部署</h3><p>由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。</p>
<p>主要参考官方文档：<a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">https://www.rabbitmq.com/clustering.html</a></p>
<p>首先确保RabbitMQ运行没有问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@super ...</span><br><span class="line">[&#123;pid,10232&#125;,</span><br><span class="line"> &#123;running_applications,</span><br><span class="line">     [&#123;rabbitmq_management,"RabbitMQ Management Console","3.6.5"&#125;,</span><br><span class="line">      &#123;rabbitmq_web_dispatch,"RabbitMQ Web Dispatcher","3.6.5"&#125;,</span><br><span class="line">      &#123;webmachine,"webmachine","1.10.3"&#125;,</span><br><span class="line">      &#123;mochiweb,"MochiMedia Web Server","2.13.1"&#125;,</span><br><span class="line">      &#123;rabbitmq_management_agent,"RabbitMQ Management Agent","3.6.5"&#125;,</span><br><span class="line">      &#123;rabbit,"RabbitMQ","3.6.5"&#125;,</span><br><span class="line">      &#123;os_mon,"CPO  CXC 138 46","2.4"&#125;,</span><br><span class="line">      &#123;syntax_tools,"Syntax tools","1.7"&#125;,</span><br><span class="line">      &#123;inets,"INETS  CXC 138 49","6.2"&#125;,</span><br><span class="line">      &#123;amqp_client,"RabbitMQ AMQP Client","3.6.5"&#125;,</span><br><span class="line">      &#123;rabbit_common,[],"3.6.5"&#125;,</span><br><span class="line">      &#123;ssl,"Erlang/OTP SSL application","7.3"&#125;,</span><br><span class="line">      &#123;public_key,"Public key infrastructure","1.1.1"&#125;,</span><br><span class="line">      &#123;asn1,"The Erlang ASN1 compiler version 4.0.2","4.0.2"&#125;,</span><br><span class="line">      &#123;ranch,"Socket acceptor pool for TCP protocols.","1.2.1"&#125;,</span><br><span class="line">      &#123;mnesia,"MNESIA  CXC 138 12","4.13.3"&#125;,</span><br><span class="line">      &#123;compiler,"ERTS  CXC 138 10","6.0.3"&#125;,</span><br><span class="line">      &#123;crypto,"CRYPTO","3.6.3"&#125;,</span><br><span class="line">      &#123;xmerl,"XML parser","1.3.10"&#125;,</span><br><span class="line">      &#123;sasl,"SASL  CXC 138 11","2.7"&#125;,</span><br><span class="line">      &#123;stdlib,"ERTS  CXC 138 10","2.8"&#125;,</span><br><span class="line">      &#123;kernel,"ERTS  CXC 138 10","4.2"&#125;]&#125;,</span><br><span class="line"> &#123;os,&#123;unix,linux&#125;&#125;,</span><br><span class="line"> &#123;erlang_version,</span><br><span class="line">     "Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [hipe] [kernel-poll:true]\n"&#125;,</span><br><span class="line"> &#123;memory,</span><br><span class="line">     [&#123;total,56066752&#125;,</span><br><span class="line">      &#123;connection_readers,0&#125;,</span><br><span class="line">      &#123;connection_writers,0&#125;,</span><br><span class="line">      &#123;connection_channels,0&#125;,</span><br><span class="line">      &#123;connection_other,2680&#125;,</span><br><span class="line">      &#123;queue_procs,268248&#125;,</span><br><span class="line">      &#123;queue_slave_procs,0&#125;,</span><br><span class="line">      &#123;plugins,1131936&#125;,</span><br><span class="line">      &#123;other_proc,18144280&#125;,</span><br><span class="line">      &#123;mnesia,125304&#125;,</span><br><span class="line">      &#123;mgmt_db,921312&#125;,</span><br><span class="line">      &#123;msg_index,69440&#125;,</span><br><span class="line">      &#123;other_ets,1413664&#125;,</span><br><span class="line">      &#123;binary,755736&#125;,</span><br><span class="line">      &#123;code,27824046&#125;,</span><br><span class="line">      &#123;atom,1000601&#125;,</span><br><span class="line">      &#123;other_system,4409505&#125;]&#125;,</span><br><span class="line"> &#123;alarms,[]&#125;,</span><br><span class="line"> &#123;listeners,[&#123;clustering,25672,"::"&#125;,&#123;amqp,5672,"::"&#125;]&#125;,</span><br><span class="line"> &#123;vm_memory_high_watermark,0.4&#125;,</span><br><span class="line"> &#123;vm_memory_limit,411294105&#125;,</span><br><span class="line"> &#123;disk_free_limit,50000000&#125;,</span><br><span class="line"> &#123;disk_free,13270233088&#125;,</span><br><span class="line"> &#123;file_descriptors,</span><br><span class="line">     [&#123;total_limit,924&#125;,&#123;total_used,6&#125;,&#123;sockets_limit,829&#125;,&#123;sockets_used,0&#125;]&#125;,</span><br><span class="line"> &#123;processes,[&#123;limit,1048576&#125;,&#123;used,262&#125;]&#125;,</span><br><span class="line"> &#123;run_queue,0&#125;,</span><br><span class="line"> &#123;uptime,43651&#125;,</span><br><span class="line"> &#123;kernel,&#123;net_ticktime,60&#125;&#125;]</span><br></pre></td></tr></table></figure>

<p>停止rabbitmq服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@super sbin]# service rabbitmq-server stop</span><br><span class="line">Stopping rabbitmq-server: rabbitmq-server.</span><br></pre></td></tr></table></figure>



<p>启动第一个节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@super sbin]# RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start</span><br><span class="line"></span><br><span class="line">              RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc.</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Logs: /var/log/rabbitmq/rabbit1.log</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##        /var/log/rabbitmq/rabbit1-sasl.log</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########</span></span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 6 plugins.</span><br></pre></td></tr></table></figure>

<p>启动第二个节点：</p>
<blockquote>
<p>web管理插件端口占用,所以还要指定其web插件占用的端口号。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@super ~]# RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15674&#125;]" RABBITMQ_NODENAME=rabbit2 rabbitmq-server start</span><br><span class="line"></span><br><span class="line">              RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc.</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Logs: /var/log/rabbitmq/rabbit2.log</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##        /var/log/rabbitmq/rabbit2-sasl.log</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########</span></span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 6 plugins.</span><br></pre></td></tr></table></figure>

<p>结束命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl -n rabbit1 stop</span><br><span class="line">rabbitmqctl -n rabbit2 stop</span><br></pre></td></tr></table></figure>



<p>rabbit1操作作为主节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 stop_app  </span><br><span class="line">Stopping node rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 reset	 </span><br><span class="line">Resetting node rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 start_app</span><br><span class="line">Starting node rabbit1@super ...</span><br><span class="line">[root@super ~]#</span><br></pre></td></tr></table></figure>

<p>rabbit2操作为从节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 stop_app</span><br><span class="line">Stopping node rabbit2@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 reset</span><br><span class="line">Resetting node rabbit2@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 join_cluster rabbit1@'super' ###''内是主机名换成自己的</span><br><span class="line">Clustering node rabbit2@super with rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 start_app</span><br><span class="line">Starting node rabbit2@super ...</span><br></pre></td></tr></table></figure>

<p>查看集群状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl cluster_status -n rabbit1</span><br><span class="line">Cluster status of node rabbit1@super ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit1@super,rabbit2@super]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit2@super,rabbit1@super]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit1@super&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit2@super,[]&#125;,&#123;rabbit1@super,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>web监控：</p>
<p><img src="assets/1566065096459.png" alt="1566065096459"></p>
<h3 id="3-3-集群管理"><a href="#3-3-集群管理" class="headerlink" title="3.3 集群管理"></a>3.3 集群管理</h3><p><strong>rabbitmqctl join_cluster {cluster_node} [–ram]</strong><br>将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。</p>
<p><strong>rabbitmqctl cluster_status</strong><br>显示集群的状态。</p>
<p><strong>rabbitmqctl change_cluster_node_type {disc|ram}</strong><br>修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。</p>
<p><strong>rabbitmqctl forget_cluster_node [–offline]</strong><br>将节点从集群中删除，允许离线执行。</p>
<p><strong>rabbitmqctl update_cluster_nodes {clusternode}</strong></p>
<p>在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。</p>
<p><strong>rabbitmqctl cancel_sync_queue [-p vhost] {queue}</strong><br>取消队列queue同步镜像的操作。</p>
<p><strong>rabbitmqctl set_cluster_name {name}</strong><br>设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。</p>
<h3 id="3-4-RabbitMQ镜像集群配置"><a href="#3-4-RabbitMQ镜像集群配置" class="headerlink" title="3.4 RabbitMQ镜像集群配置"></a>3.4 RabbitMQ镜像集群配置</h3><blockquote>
<p>上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。</p>
<p>镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。</p>
</blockquote>
<p><strong>设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。</strong></p>
<blockquote>
<p>rabbitmqctl set_policy my_ha “^” ‘{“ha-mode”:”all”}’</p>
</blockquote>
<p><img src="assets/1566072300852.png" alt="1566072300852"></p>
<blockquote>
<ul>
<li>Name:策略名称</li>
<li>Pattern：匹配的规则，如果是匹配所有的队列，是^.</li>
<li>Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。</li>
</ul>
</blockquote>
<h3 id="3-5-负载均衡-HAProxy"><a href="#3-5-负载均衡-HAProxy" class="headerlink" title="3.5 负载均衡-HAProxy"></a>3.5 负载均衡-HAProxy</h3><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。</p>
<h5 id="3-5-1-安装HAProxy"><a href="#3-5-1-安装HAProxy" class="headerlink" title="3.5.1  安装HAProxy"></a>3.5.1  安装HAProxy</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//下载依赖包</span><br><span class="line">yum install gcc vim wget</span><br><span class="line">//上传haproxy源码包</span><br><span class="line">//解压</span><br><span class="line">tar -zxvf haproxy-1.6.5.tar.gz -C /usr/local</span><br><span class="line">//进入目录、进行编译、安装</span><br><span class="line">cd /usr/local/haproxy-1.6.5</span><br><span class="line">make TARGET=linux31 PREFIX=/usr/local/haproxy</span><br><span class="line">make install PREFIX=/usr/local/haproxy</span><br><span class="line">mkdir /etc/haproxy</span><br><span class="line">//赋权</span><br><span class="line">groupadd -r -g 149 haproxy</span><br><span class="line">useradd -g haproxy -r -s /sbin/nologin -u 149 haproxy</span><br><span class="line">//创建haproxy配置文件</span><br><span class="line">mkdir /etc/haproxy</span><br><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>




<h5 id="3-5-2-配置HAProxy"><a href="#3-5-2-配置HAProxy" class="headerlink" title="3.5.2 配置HAProxy"></a>3.5.2 配置HAProxy</h5><p>配置文件路径：/etc/haproxy/haproxy.cfg</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">logging options</span></span><br><span class="line">global</span><br><span class="line">	log 127.0.0.1 local0 info</span><br><span class="line">	maxconn 5120</span><br><span class="line">	chroot /usr/local/haproxy</span><br><span class="line">	uid 99</span><br><span class="line">	gid 99</span><br><span class="line">	daemon</span><br><span class="line">	quiet</span><br><span class="line">	nbproc 20</span><br><span class="line">	pidfile /var/run/haproxy.pid</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">	log global</span><br><span class="line">	</span><br><span class="line">	mode tcp</span><br><span class="line"></span><br><span class="line">	option tcplog</span><br><span class="line">	option dontlognull</span><br><span class="line">	retries 3</span><br><span class="line">	option redispatch</span><br><span class="line">	maxconn 2000</span><br><span class="line">	contimeout 5s</span><br><span class="line">   </span><br><span class="line">     clitimeout 60s</span><br><span class="line"></span><br><span class="line">     srvtimeout 15s	</span><br><span class="line"><span class="meta">#</span><span class="bash">front-end IP <span class="keyword">for</span> consumers and producters</span></span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">	bind 0.0.0.0:5672</span><br><span class="line">	</span><br><span class="line">	mode tcp</span><br><span class="line"><span class="meta">	#</span><span class="bash">balance url_param userid</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance url_param session_id check_post 64</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance hdr(User-Agent)</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance hdr(host)</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance hdr(Host) use_domain_only</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance rdp-cookie</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance leastconn</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">balance <span class="built_in">source</span> //ip</span></span><br><span class="line">	</span><br><span class="line">	balance roundrobin</span><br><span class="line">	</span><br><span class="line">        server node1 127.0.0.1:5673 check inter 5000 rise 2 fall 2</span><br><span class="line">        server node2 127.0.0.1:5674 check inter 5000 rise 2 fall 2</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">	bind 172.16.98.133:8100</span><br><span class="line">	mode http</span><br><span class="line">	option httplog</span><br><span class="line">	stats enable</span><br><span class="line">	stats uri /rabbitmq-stats</span><br><span class="line">	stats refresh 5s</span><br></pre></td></tr></table></figure>

<p>启动HAproxy负载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">//查看haproxy进程状态</span><br><span class="line">ps -ef | grep haproxy</span><br><span class="line"></span><br><span class="line">访问如下地址对mq节点进行监控</span><br><span class="line">http://172.16.98.133:8100/rabbitmq-stats</span><br></pre></td></tr></table></figure>

<p>代码中访问mq集群地址，则变为访问haproxy地址:5672</p>
</div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/11.RabbitMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/10.RabbitMQ%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/">rabbitmq笔记/10.RabbitMQ应用问题</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-15</time></div><div class="post-content"><div class="main-content content"><p>[toc]</p>
<h2 id="RabbitMQ应用问题"><a href="#RabbitMQ应用问题" class="headerlink" title="RabbitMQ应用问题"></a>RabbitMQ应用问题</h2><h3 id="1-消息可靠性保障–消息补偿"><a href="#1-消息可靠性保障–消息补偿" class="headerlink" title="1. 消息可靠性保障–消息补偿"></a>1. 消息可靠性保障–消息补偿</h3><p>需求：100%确保消息发送成功</p>
<p><img src="assets/image-20201215210520558.png" alt="image-20201215210520558"></p>
<h3 id="2-消息幂等性保障–乐观锁机制"><a href="#2-消息幂等性保障–乐观锁机制" class="headerlink" title="2. 消息幂等性保障–乐观锁机制"></a>2. 消息幂等性保障–乐观锁机制</h3><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p>
<p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。</p>
<p><img src="assets/image-20201215210820023.png" alt="image-20201215210820023"></p>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/10.RabbitMQ%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/1.MQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">rabbitmq笔记/1.MQ基本概念</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-14</time></div><div class="post-content"><div class="main-content content"><p>[toc]</p>
<h2 id="MQ基本概念"><a href="#MQ基本概念" class="headerlink" title="MQ基本概念"></a>MQ基本概念</h2><h3 id="1-MQ概述"><a href="#1-MQ概述" class="headerlink" title="1. MQ概述"></a>1. MQ概述</h3><blockquote>
<p><code>MQ全称 Message Queue（消息队列）</code>，是在消息的传输过程中保存消息的容器。<code>多</code>用于<code>分布式系统之间进行通信。</code></p>
</blockquote>
<p><img src="assets/image-20201214200516263.png" alt="image-20201214200516263"></p>
<blockquote>
<p>使用MQ中间件</p>
</blockquote>
<p><img src="assets/image-20201214200537641.png" alt="image-20201214200537641"></p>
<blockquote>
<p>小结：</p>
<ol>
<li>MQ—消息队列，存储消息的中间件。</li>
<li>分布式系统通信两种方式：<code>直接远程调用</code>和==借助第三方完成间接通信==。</li>
<li>发送方称为生产者，接收方称为消费者。</li>
</ol>
</blockquote>
<h3 id="2-MQ的优势和劣势"><a href="#2-MQ的优势和劣势" class="headerlink" title="2. MQ的优势和劣势"></a>2. MQ的优势和劣势</h3><h4 id="2-1-优势"><a href="#2-1-优势" class="headerlink" title="2.1 优势"></a>2.1 优势</h4><blockquote>
<ol>
<li>应用解耦：提高系统容错性和可维护性。</li>
<li>异步提速：提升用户体验和系统吞吐量。</li>
<li>削峰填谷：提高系统稳定性。</li>
</ol>
</blockquote>
<h6 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h6><p>系统的耦合性越高，容错性就越低，可维护性就越低。</p>
<p><img src="assets/image-20201214202740735.png" alt="image-20201214202740735"></p>
<p>使用 MQ 使得应用间解耦，提升容错性和可维护性。</p>
<p><img src="assets/image-20201214202817687.png" alt="image-20201214202817687"></p>
<h6 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a>异步提速</h6><p><img src="assets/image-20201214203001503.png" alt="image-20201214203001503"></p>
<p>一个下单操作耗时：20 + 300 + 300 + 300 = 920ms<br>用户点击完下单按钮后，需要等待920ms才能得到下单响应，太慢！</p>
<p><img src="assets/image-20201214203119022.png" alt="image-20201214203119022"></p>
<p>用户点击完下单按钮后，只需等待25ms就能得到下单响应 (20 + 5 = 25ms)。<br><code>提升用户体验和系统吞吐量（单位时间内处理请求的数目）。</code></p>
<h6 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h6><p><img src="assets/image-20201214203243219.png" alt="image-20201214203243219"></p>
<p><img src="assets/image-20201214203331072.png" alt="image-20201214203331072"></p>
<p><img src="assets/image-20201214203352618.png" alt="image-20201214203352618"></p>
<p>使用了 MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰就被“削”掉了，但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直到消费完积压的消息，这就叫做<code>“填谷”</code>。<br><code>使用MQ后，可以提高系统稳定性。</code></p>
<h4 id="2-2-劣势"><a href="#2-2-劣势" class="headerlink" title="2.2 劣势"></a>2.2 劣势</h4><p><img src="assets/image-20201214203702793.png" alt="image-20201214203702793"></p>
<h6 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h6><p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p>
<h6 id="系统复杂度提高"><a href="#系统复杂度提高" class="headerlink" title="系统复杂度提高"></a>系统复杂度提高</h6><p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
<h6 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h6><p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p>
<h4 id="2-3-既然-MQ-有优势也有劣势，那么使用-MQ-需要满足什么条件呢？"><a href="#2-3-既然-MQ-有优势也有劣势，那么使用-MQ-需要满足什么条件呢？" class="headerlink" title="2.3 既然 MQ 有优势也有劣势，那么使用 MQ 需要满足什么条件呢？"></a>2.3 既然 MQ 有优势也有劣势，那么使用 MQ 需要满足什么条件呢？</h4><ol>
<li>生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</li>
<li>容许短暂的不一致性。</li>
<li>确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</li>
</ol>
<h3 id="3-常见的MQ产品"><a href="#3-常见的MQ产品" class="headerlink" title="3. 常见的MQ产品"></a>3. 常见的MQ产品</h3><blockquote>
<p>目前业界有很多的 MQ 产品，例如 <code>RabbitMQ</code>、RocketMQ、<code>ActiveMQ、Kafka</code>、ZeroMQ、MetaMq等，也有直接使用 Redis 充当消息队列的案例，而这些消息队列产品，各有侧重，在实际选型时，需要结合自身需求及 MQ 产品特征，综合考虑。</p>
</blockquote>
<p><img src="assets/image-20201214204101628.png" alt="image-20201214204101628"></p>
<h2 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h2></div></div><a class="button-hover more" href="/2020/12/19/rabbitmq%E7%AC%94%E8%AE%B0/1.MQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/08/24/itbuild-JavaEE/">itbuild-JavaEE</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-11-15</time></div><div class="post-content"><div class="main-content content"><p>昨夜西风凋碧树，独上高楼，望尽天涯路。</p></div></div><a class="button-hover more" href="/2020/08/24/itbuild-JavaEE/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/08/06/itbuild-hadoop%E7%94%9F%E6%80%81%E5%9C%88/">itbuild-hadoop生态圈</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-08-24</time></div><div class="post-content"><div class="main-content content"><p>衣带渐宽终不悔，为伊消得人憔悴。</p></div></div><a class="button-hover more" href="/2020/08/06/itbuild-hadoop%E7%94%9F%E6%80%81%E5%9C%88/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2020 By DuanChaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>